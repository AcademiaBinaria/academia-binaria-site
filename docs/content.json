{"meta":{"title":"Academia Binaria","subtitle":"Formación en español para programadores","description":"Artículos y tutoriales sobre Angular y todo lo relacionado con JavaScript y TypeScript","author":"Alberto Basalo","url":"https://academia-binaria.com","root":"/"},"pages":[{"title":"404 No encontrado","date":"2018-05-03T08:56:05.754Z","updated":"2018-05-03T08:56:05.754Z","comments":false,"path":"/404.html","permalink":"https://academia-binaria.com//404.html","excerpt":"","text":"Lo sentimos, la ruta no se ha encontrado.Por favor, dirígete al inicio del blog– El equipo de Academia BinariaAprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo"},{"title":"Cursos Online Avanzado de Angular","date":"2019-03-20T09:07:39.000Z","updated":"2019-04-24T12:07:39.000Z","comments":true,"path":"cursos/angular-business.html","permalink":"https://academia-binaria.com/cursos/angular-business.html","excerpt":"","text":"Implantación de buenas prácticas en desarrollos empresariales con Angular.Angular Business0 - Repositorios profesionales con Nx0.1 Nx y el CLIInstalación de Nx y CLICrear y configurar un workspace0.1 Estructura de un workspaceAppsLibs0.2 ProyectosFrontend websBackend Apis0.3 Librerías4.1 Librerías en TypeScript4.2 Librerías de Angular1 - Testing de aplicaciones1.1 Tipos de testsIntegración o e2eUnitarios1.2 Test de Integración con CypressCypressTest e2e1.3 Test Unitarios con JestJestTest unitarios2 - Detección del cambio en Angular2.1 Estrategias de detección del cambioDefaultOnPush2.2 Técnicas OnPushDetectChangesAsyncInmutable2.3 OptimizaciónOnPush es más ligeroAsync, CDR y clone detectan los cambios3 - Componentes dinámicos, directivas y pipes3.1 Plantillas de contenido dinámicoUn componente comúnImplementaciones distintas3.2 Atributos custom con DirectivasGeneración de directivasConsumo de directivas3.2 Funciones de transformación con PipesGeneración de pipesConsumo de pipes4 - Redux con observables4.1 Arquitectura del patrón ReduxPrincipios de ReduxElementos de Redux4.2 Implementación de un Store con RxJsEl Store observableEl envío de accionesLa función reductora de estadoLa selección de suscripciones5 - Redux con NgRx5.1 Instalación y configuraciónInstalación de NgRxRegistro y configuraciónRouter y DevTools5.2 ActionsCreateDispatch5.3 State reducerStateCreate functionRegister in Store5.4 SelectorsCreate selectorSelecting dataFachadas5.5 EffectsInstallEfecto básicoApi async effectsMore Api async effects6 - Deploy Progressive Web Apps6.1 Angular Service Worker con el CLIInstalaciónModificaciones automáticasPaquetes recomendados6.2 Configuración de cachéAssetsAPI6.3 Actualizaciones y notificacionesActualización de versionesNotificaciones Push6.4 ShellUna animación para amenizar la cargaWIP7 - Server Side Rendering7.1 Angular Universal7.2 Despliegue con Node Express7.3 Variantes: shell y pre-rendering8 - Internacionalización y puesta en producción8.1 Traducciones8.2 Adaptaciones culturales de tiempo y moneda8.3 Otras consideraciones para aplicaciones en producción.9 - Web Components9.1 Desarrollo en Angular9.2 Consumo en cualquier frameworkMejora ya!Contenido detallado Angular Basic"},{"title":"Cookies","date":"2016-04-14T12:29:58.000Z","updated":"2016-04-18T13:48:28.000Z","comments":true,"path":"cookies.html","permalink":"https://academia-binaria.com/cookies.html","excerpt":"","text":"Utilizamos cookies para facilitar el uso de nuestra página web.Las cookies son pequeños ficheros de texto que su navegador almacena en el disco duro de su ordenador y que son necesarias para navegar por nuestra página web.Las utilizamos para entender mejor la manera en la que se usa nuestra página web y de esta manera poder mejorar consecuentemente el proceso de navegación. Las cookies son el referente que nos indica, por ejemplo, si una página de nuestra web ha sido vista conanterioridad, o si su visita es nueva o recurrente.Las cookies que utilizamos no almacenan dato personal alguno, ni ningún tipo de información que pueda identificarle.En caso de no querer recibir cookies, por favor configure su navegador de Internet para que las borre del disco duro de su ordenador, las bloquee o le avise en caso de instalación de las mismas."},{"title":"Cursos Online de introducción a Angular","date":"2019-03-20T09:07:39.000Z","updated":"2019-04-24T12:07:39.000Z","comments":true,"path":"cursos/angular-basic.html","permalink":"https://academia-binaria.com/cursos/angular-basic.html","excerpt":"","text":"Angular Basic: Curso de introducción desde cero al desarrollo con Angular.0 - Hola Angular CLI0.1 Angular y el CLIInstalación de Angular CLI 7Crear y ejecutar aplicaciones Angular0.2 Estructura de una aplicación AngularFicheros y carpetas principalesEdición de un Hola Mundo0.3 ConfiguraciónConfigurar el CLIConfigurar el WorkflowConfigurar la aplicación0.4 Angular y su ecosistemaExtensiones de Visual StudioConfigurar PrettierEcosistema de terceros1 - Base para una aplicación Angular1.1 - MódulosAnatomía de un móduloGeneración de módulos1.2 - ComponentesAnatomía de un componenteGeneración de componentes1.3 - Visibilidad entre componentesComponentes públicos y privadosImportación y exportación entre módulos1.4 - Transitividad y OrganizaciónTransitividad en una cadena de módulosOrganización de la aplicación en módulos2 - Páginas y rutas SPA2.1 RutasRouterModuleRouter OutletRouter Link2.2 Lazy LoadingWebpack y los bundles por rutaEl enrutador delegadoNavegación2.3 Rutas anidadasChildrenRouterOutlet anidado2.4 ParámetrosVariables en la rutaActivatedRoute3 - Formularios, tablas y modelos de datos3.1 BindingBaseDirectivas3.2 Doble BindingNgModelForm3.3 EstructurasngForngIf3.4 Modelo y controladorInterfaces y modelosViewModel en el controlador4 - Flujo de datos entre componentes4.1 Comunicación entre componentesNecesidad de comunicaciónEscenarios4.2 Contenedor / PresentadoresEl patrón Contenedor / PresentadoresEl contenedorEnvío hacia el presentador con @Input()Respuesta del presentador con @Output()4.3 Otras comunicacionesComunicación entre distintas páginasComunicación entre estructuras desacopladas5 - Servicios inyectables5.1 Inyección de dependenciasGeneración de serviciosConsumo de dependencias5.2 Inversión del controlInterface y servicio baseImplementacionesProvisión manualFactoría6 - Comunicaciones http6.1 El servicio HttpClientImportación y declaración de serviciosObtención de datosEnvío de datosActualización de datos6.2 ObservablesAsyncpipeoperators6.3 InterceptoresLa interfaz HttpInterceptorInversión del control vía tokenUn auditor de llamadas7 - Vigilancia y seguridad7.1 Observables para monitorizar datosProductores de observablesUn Store de notificacionesDesacoplados pero conectados7.2 Interceptores para gestionar erroresEl operador catchErrorGestión centralizada de errores7.3 Un notificador de problemasEmisión mediante el StoreRecepción desacoplada del interceptor8 - Formularios reactivos8.1 Desacople entre vista y modeloForm builderForm controlForm view8.2 Validación y estadosValidadores predefinidos y personalizadosEstados de cambio y validación8.3 Un gestor de credencialesDetección y redirección de intrusosAlmacenamiento y uso del token9 - Material Design y CLI9.1 Repositorio multi-proyectoCarpetas src y projectsCompilación multi - proyecto9.2 Instalación y configuración de MaterialAgregar dependencias con schematicsEstilos, iconos y temas básicos9.3 Componentes básicosNavegación y layoutComponentes básicosEmpieza ya!Contenido detallado Angular Business"},{"title":"Noticias Junio 2016","date":"2016-06-03T08:44:51.000Z","updated":"2016-06-06T12:28:19.000Z","comments":true,"path":"noticias-junio-16.html","permalink":"https://academia-binaria.com/noticias-junio-16.html","excerpt":"","text":"##06-06-16###Angular 2 R.C.: La evolución de la plataforma.AngularJS ha sufrido una metamorfosis. Mantiene el nombre a duras penas. Ahora ya ni le pone el sufijo …JS. Pero la esperada versión Angular2 lo cambia todo. Cambia el lenguaje, cambia la filosofía y cambia la sintaxis.Todo este cambio es necesario para competir en el ecosistema JavaScript. Continuamente aparecen y desaparecen librerías. Para sobrevivir fue necesario renacer. Ahora es una plataforma mucho más cercana al mundo empresarial.Usa esta serie de artículos sobre Angular2 como tutorial para adaptarte a esta evolución.###Enlaces para aprender####[AngularJS] : Mejorar el Rendimiento en una línea.Parece un eslogan de gancho fácil, pero funciona. La clave es la información de depuración que se genera de manera automática. Al eliminarla se reduce el peso y se mejora la velocidad.####[JavaScript] : La fatiga de frameworks comparada.Empiezo por la consabida broma de pedir una moratoria en el desarrollo de armas… digo de frameworks JavaScript . Mientras tanto mira esta tabla que compara la sintaxis de librerías muy populares.####[NodeJS] : Monitorizar aplicaciones bien y fácil.Si no sabes lo que hace tu aplicación estás perdido. Lo primero que necesitas es una estrategia para generar logs. En Node tienes muchas opciones. Además del console.log(‘ ;-) ‘).####[MongoDB] : Rendimiento y Monitorización de MongoDB.Ahora le toca a la base de datos. No es fácil entender ni usar correctamente la enorme cantidad de métricas que ofrece MongoDB. Pero es fundamental conocer y aplicar algunas para controlar y escalar las instalciones.####[CleanCode] : Escribe código pensando en mantenerlo.Escribimos una vez pero revisamos 20. Nosotros, nuestros compañeros y nuestros herederos. Unos cuantos consejos y buenas prácticas te ayudarán a tratar con lo heredado y a dejar mejores herencias.###Próximas actividadesEste es el mes de Angular2. Su estreno como Release Candidate permite ofrecer formación con garantías. Nos vemos.Keep coding, keep learning."},{"title":"Cursos Online de Angular","date":"2019-03-20T09:07:39.000Z","updated":"2019-03-20T09:07:39.000Z","comments":true,"path":"cursos.html","permalink":"https://academia-binaria.com/cursos.html","excerpt":"","text":"Contenido detallado Angular BasicContenido detallado Angular BusinessCursos con lecciones en video, chat de preguntas, tutorías y prácticas corregidas.– Te espero, Alberto BasaloAngular BasicIntroducción desde cero al desarrollo con Angular.0 - Hola Angular CLI1 - Base para una aplicación Angular2 - Páginas y rutas SPA3 - Formularios, tablas y modelos de datos4 - Flujo de datos entre componentes5 - Servicios inyectables6 - Comunicaciones http7 - Vigilancia y seguridad8 - Formularios reactivos9 - Material Design y CLIEmpieza ya!Contenido detallado Angular BasicAngular BusinessImplantación de buenas prácticas en desarrollos empresariales con Angular.0 - Repositorios profesionales con Nx1 - Testing de aplicaciones con Cypress y Jest2 - Detección del cambio en Angular3 - Componentes dinámicos, directivas y pipes4 - Redux con observables RxJs5 - Redux con NgRx6 - Deploy Progressive Web Apps7 - Server Side Rendering8 - Internacionalización y puesta en producción9 - Web ComponentsMejora ya!Contenido detallado Angular BusinessCon diploma acreditativo, bolsa de trabajo y bonificables por Fundae.– Aprende online con Alberto BasaloAngular Basic: Curso de introducción desde cero al desarrollo con Angular.Angular Business: Curso de implantación de buenas prácticas en desarrollos empresariales con Angular."},{"title":"Contacto","date":"2015-09-16T11:52:52.000Z","updated":"2017-02-14T08:21:50.000Z","comments":true,"path":"contacto.html","permalink":"https://academia-binaria.com/contacto.html","excerpt":"","text":"Vivimos en la nube y nos relacionamos contigo en cualquier sitio desde A Coruña, España.Si quieres visitarnos ven a:Ágora Binaria S.LFactoría de software y academia de programadores.Av. Primera C10. Edif Abanca Innova CP:15190A Coruña, EspañaTelefóno: +34 609884782Email: info(at)agorabinaria.comPara temas comerciales de cursos presenciales con Vita Digital S.L.:Email: vitae(at)vitaedigital.comWeb: http://www.vitaedigital.com/"},{"title":"Promociones","date":"2016-05-10T11:53:10.000Z","updated":"2016-05-27T06:46:03.000Z","comments":true,"path":"promociones.html","permalink":"https://academia-binaria.com/promociones.html","excerpt":"","text":"#Cursos de Angular2####OnlineInicio 9 de junio de 2016###Angular 2, desarrollo de aplicaciones empresariales con HTMLCon EscuelaIT####Presencial en CoruñaInicio 10 de junio de 2016###A Coruña : Curso en Abierto de Angular2, TypeScript y Estrategias de Migración de versiones 1.xCon Vitae Digital"},{"title":"[object Object]","date":"2018-05-03T08:56:05.871Z","updated":"2018-05-03T08:56:05.871Z","comments":true,"path":"scaffolds/page.html","permalink":"https://academia-binaria.com/scaffolds/page.html","excerpt":"","text":""},{"title":"[object Object]","date":"2018-05-03T08:56:05.871Z","updated":"2018-05-03T08:56:05.871Z","comments":true,"path":"scaffolds/post.html","permalink":"https://academia-binaria.com/scaffolds/post.html","excerpt":"","text":""},{"title":"[object Object]","date":"2018-05-03T08:56:05.855Z","updated":"2018-05-03T08:56:05.855Z","comments":true,"path":"scaffolds/draft.html","permalink":"https://academia-binaria.com/scaffolds/draft.html","excerpt":"","text":""},{"title":"","date":"2020-02-18T16:19:24.730Z","updated":"2020-02-18T16:19:24.730Z","comments":true,"path":"angular_9-translate.html","permalink":"https://academia-binaria.com/angular_9-translate.html","excerpt":"","text":"Ayudita conceptual…https://www.campusmvp.es/recursos/post/angular-9-ya-esta-aqui-y-estas-son-sus-novedades.aspxUn vistazo a las características principales en el lanzamiento de Angular Ivy versión 9editor de publicacionesLars Gyrup Brink Nielsen 06 de febrero de 2020 9 min de lecturaMUCHO y en todas partes, globalización dinámica, modo estricto, Bazel y mucho más.(Sí, ahora se ha lanzado Angular Ivy versión 9) *Ivy está habilitado por defectoEn versiones anteriores de Angular, tuvimos que optar por Ivy. En la versión 9, tenemos que optar por no participar en Ivy si queremos recurrir a View Engine. Esto es posible en ambas versiones 9 y 10 para garantizar una transición más fluida de View Engine a Ivy.Las librerías se pueden compilar AOT, pero no es recomendable. El equipo de Angular tiene un plan de migración de View Engine a Ivy que recomienda publicar solo librerías compatibles con View Engine compiladas con JIT para Angular versión 9. El compilador de compatibilidad Angular actualizará las librerías compatibles con View Engine a Ivy cuando se instalen en una aplicación Angular Ivy.Obtén información sobre la compatibilidad de la biblioteca y el plan de transición de View Engine-to-Ivy en “La guía de Angular Ivy para autores de librerías” .123456// tsconfig.json&#123; \"angularCompilerOptions\": &#123; \"enableIvy\": false &#125;&#125;123// polyfills.ts// Solo se usa en aplicaciones multilingües de Ivy// import '@angular/localize/init';Listado 1. Optar por no usar Ivy para recurrir a View Engine.Si tienes problemas con Ivy en tu aplicación, o en cualquiera de las librerías de las que depende, puedes optar por salir de Ivy y recurrir a View Engine. Hazlo desactivando la opción del compilador angular enableIvy y deshabilitando@angular/localize como se ve en Listado 1.Optar por evitar Ivy en un entorno de servidor es un poco más complicado. Sigue la guía oficial para darte de baja de Ivy cuando uses la renderización del lado del servidor.El principio de localidadAntes, para compilar un componente en View Engine, Angular necesitaba información sobre todas sus dependencias declaradas. Esto significa que las librerías Angular no se pueden compilar AOT usando View Engine.Ahora para compilar un componente en Ivy, Angular solo necesita información sobre el componente en sí. Pero, Ivy no necesita metadatos de ninguna dependencia declarable para compilar un componente.El principio de localidad significa que, en general, veremos tiempos de construcción más rápidos.Componentes con carga diferidaLas declaraciones entryComponents están en desuso porque ya no son necesarias. Cualquier componente Ivy puede cargarse de forma diferida y renderizarse dinámicamente.Esto significa que ahora podemos cargar de forma diferida y renderizar un componente sin enrutamiento o módulos Angular. Sin embargo, en la práctica aún tenemos que usar módulos para renderizar componentes o módulos funcionales para vincular la plantilla de un componente a sus dependencias.Las librerías que solo son utilizadas por un componente con carga diferida se agrupan en fragmentos con carga diferida.Mejoras en la carga diferencialCuando se introdujo la carga diferencial en Angular versión 8, el proceso de compilación se ejecutaba una vez para el paquete ES5 y otra vez para el paquete ES2015+.En Angular versión 9, primero se emite un paquete ES2015+. Ese paquete se transfiere a un paquete ES5 separado. De esta manera, no tenemos que pasar por un proceso de compilación completo dos veces.Compilación AOT en todas partesAOT está habilitado de forma predeterminada en las compilaciones, el servidor de desarrollo e incluso en las pruebas. Anteriormente, la compilación AOT era significativamente más lenta que la compilación JIT, por lo que JIT se usaba para el desarrollo y las pruebas. Con las mejoras de tiempo de construcción y reconstrucción en Ivy, la compilación AOT ahora ofrece una gran experiencia al desarrollador.Cuando utilizábamos la compilación JIT en desarrollo y solo la compilación AOT en la compilación final, algunos errores se detectaban solo al hacer compilaciones de producción o, peor aún, en tiempo de ejecución.Tamaños de paqueteIvy puede habilitar paquetes más pequeños porque usa el Ivy Instruction Set, que es un conjunto de instrucciones de representación de tiempo de ejecución potencialmente tree-shakable. Nuestros paquetes solo incluirán las instrucciones de renderizado que realmente usamos en nuestros proyectos.Esto es ideal para casos de uso como microfrontends, Angular Elements y aplicaciones web donde Angular no controla todo el documento.Sin embargo, la diferencia en los tamaños de nuestros paquetes entre View Engine e Ivy variará según el tamaño de nuestra aplicación y las librerías de terceros que utilizamos. En general:Las aplicaciones pequeñas y simples verán una disminución considerable del peso del paquete.Las aplicaciones complejas verán un aumento en el fichero principal, pero una disminución en los tamaños de paquetes con carga diferida.Esto significa una disminución considerable del tamaño de descarga combinada para aplicaciones grandes, pero podría significar un aumento en el peso total para aplicaciones medianas. En ambos casos, el tamaño del paquete principal probablemente aumentará, lo que es malo para el tiempo de carga inicial de la página.GlobalizaciónLas configuraciones regionales (formato de número, formato de fecha y otras configuraciones regionales) se pueden cargar dinámicamente en tiempo de ejecución en lugar de tener que registrarse en tiempo de compilación.12345678// main.tsimport '@angular/localize/init';import &#123; loadTranslations &#125; from '@angular/localize';loadTranslations (&#123; '8374172394781134519': '¡Hola, &#123;$nombre de usuario&#125;! Bienvenido a &#123;$appName&#125;. ',&#125;);Listado 2. Carga dinámica de traducciones.Como se ve en el Listado 2, los textos traducidos también se pueden cargar dinámicamente en tiempo de ejecución en lugar de ser parte de nuestros paquetes.Los textos traducidos pueden cargarse desde una base de datos o un archivo.Múltiples idiomas desde un único paquete de aplicacionesPara cambiar el idioma, tenemos que reiniciar la aplicación, pero no tenemos que servir un fichero de aplicaciones diferente.Esto significa que podemos, con alguna configuración, admitir varios idiomas con un solo paquete de aplicaciones en un solo nombre de host.Tiempo de compilación en líneaUna aplicación localizada ahora solo se compilará una vez. En lugar de múltiples compilaciones para producir un paquete por idioma, se produce un paquete por idioma reemplazando los marcadores de posición $localize con textos traducidos.Ahora hay que agregar el paquete @angular/localize para posibilitar la localización (varios idiomas). La buena noticia es que ya no tenemos que incluir el código de localización de Angular en nuestros paquetes si solo tenemos un idioma.Si no usamos plantillas localizadas, las instrucciones de Ivy i18n * se sacan del paquete principal.Textos localizables en modelos de componentes y servicios1234567// app.component.ts@Component(&#123; template: '&#123;&#123; title &#125;&#125;'&#125;)export class AppComponent &#123; title = $localize`Welcome to MyApp`;&#125;Listado 3. Un marcador de posición de texto de traducción en un modelo de componente.Una nueva característica de internacionalización es que también podemos incluir marcadores de posición para textos traducidos en el contenido de nuestros modelos como se ve en el Listado 3. Anteriormente, esto solo era posible en las plantillas.Ámbitos adicionales de proveedores de dependenciasSiempre hemos tenido alcance de módulo para los proveedores de inyección de servicios. La versión Angular 6 introdujo el alcance &#39;root&#39; y los proveedores tree-shakable, tanto para los proveedores de alcance desde el módulo raíz como desde módulos inferiores.La versión angular 9 presenta los nuevos ámbitos de proveedor &#39;platform&#39; y &#39;any&#39;. Los proveedores con ámbito de &#39;platform&#39; se pueden compartir entre múltiples aplicaciones Angular en el mismo documento. El alcance del proveedor &#39;any&#39; compartirá un proveedor por inyector de módulo. Por ejemplo, una instancia de servicio para el paquete principal cargado por adelantado y una instancia de servicio para cada módulo cargado con retraso.Experiencia mejorada del desarrolladorIvy permite que Angular Language Service admita comprobaciones adicionales durante el desarrollo. Esta es una gran mejora para la experiencia del desarrollador.Comprobaciones de ruta de archivoAngular Language Service verifica continuamente la hoja de estilo de componentes y las rutas de plantilla.Verificaciones de tipo de plantillaLas plantillas se verifican por tipo, de acuerdo con el modo de verificación de tipo de plantilla como se describe más abajo en la sección “Modo estricto”. Los nombres y tipos de miembros se verifican, incluso en vistas incrustadas. Lo que anteriormente resultaba en errores de tiempo de ejecución ahora se detecta durante el desarrollo y la construcción.Nueva API de depuración en modo de desarrollong.probe ha sido reemplazado por una nueva API de depuración en modo de desarrollo. Las funciones más notables son ng.applyChanges yng.getComponent.Modo estrictoEsquema estricto del espacio de trabajoEl comando ng new ahora es compatible con el indicador--strict que por defecto está desactivado (false).1ng new my-app --strictCuando está habilitado, este parámetro agrega algunas comprobaciones estrictas del compilador TypeScript como se ve en el Listado 4.12345678910// tsconfig.json&#123; \"compilerOptions\": &#123; \"noImplicitAny\": true, \"noImplicitReturns\": true, \"noImplicitThis\": true, \"noFallthroughCasesInSwitch\": true, \"strictlyNullChecks\": true &#125;&#125;Listado 4. Opciones del compilador TypeScript habilitadas en un estricto espacio de trabajo angular.Curiosamente, esto no agrega las mismas opciones que si simplemente estableciéramos &quot;strict&quot;: true en el objeto compilerOptions. Comparemos la opción estricta del workscpace Angular con la opción estricta del compilador TypeScript.Ambos tienen estas opciones en común:noImplicitAnynoImplicitThisstrictlyNullChecksLa opción estricta de Angular establece además estas opciones:noImplicitReturnsnoFallthroughCasesInSwitchmientras que la opción estricta del compilador TypeScript establece adicionalmente estas opciones:alwaysStrictstrictlyBindCallApplystrictlyFunctionTypesestrictoPropertyInitializationAdemás, la opción de Angular no establece la comprobación del tipo de plantilla en el nuevo modo estricto, lo deja en el modo &#39;full&#39; anterior.Verificación estricta del tipo de plantillaHemos tenido la opción de habilitar la verificación del tipo de plantilla desde Angular versión 5 configurando &quot;fullTemplateTypeCheck&quot;: true en el objetoangularCompilerOptions.Ivy presenta una estricta comprobación del tipo de plantilla como se ve en el Listado 5. Cuando se establece esta nueva opción del compilador Angular, se ignora el valor de fullTemplateTypeCheck.123456// tsconfig.json&#123; \"angularCompilerOptions\": &#123; \"strictlyTemplates\": true &#125;&#125;Listado 5. Habilita la comprobación estricta del tipo de plantilla.La comprobación de tipo de plantilla estricta verifica los tipos de enlaces de propiedades y respeta la opción stricNullChecks. También verifica los tipos de referencias de plantilla a directivas y componentes, incluidos los tipos genéricos. También se verifican los tipos de variables de contexto de plantilla, lo cual es excelente para los bucles ‘NgFor’. El tipo $ event está marcado para enlaces de eventos y animaciones. Incluso el tipo de elementos DOM nativos se verifica con una comprobación estricta del tipo de plantilla.Estas comprobaciones adicionales pueden conducir a errores y falsos positivos bajo ciertas circunstancias. Por ejemplo, cuando se usan librerías que no están compiladas con strictNullChecks. Para abordar esto, la verificación estricta del tipo de plantilla tiene opciones para optar por no participar y ajustar los controles. Por ejemplo, strictTemplates es en realidad una atajo de 8 opciones de compilador Angular.Herencia de clase de componente y directiva mejoradaLas clases base sin selector ahora son compatibles con directivas y componentes. Algunos metadatos ahora se heredan de componentes base y clases directivas. Esto hace que sea más fácil extender, por ejemplo, las directivas Angular Components y Angular Router.Últimas versiones de TypeScriptLas versiones de TypeScript 3.6 y 3.7 son compatibles con la versión angular 9. Las versiones anteriores de TypeScript ya no son compatibles. Consulta la Tabla 1 para comparar la compatibilidad de TypeScript entre todas las versiones Angular.[ver sin formato](https://gist.github.com/LayZeeDK/c822cc812f75bb07b7c55d07ba2719b3/raw/ad300b4d2bdbc51b4dd8092c059a68cb22d3774d/angular-cli-node-js-typescript-support -cs-type-script-node-type-script-code-node-code-node-type. csv](https://gist.github.com/LayZeeDK/c822cc812f75bb07b7c55d07ba2719b3#file-angular-cli-node-js-typescript-support-csv) alojado con ❤ por GitHubTabla 1. Tabla de compatibilidad de CLI angular, Angular, Node.js y TypeScript. Abrir en una pestaña nueva*TypeScript versión 3.6 presenta estas y otras características:Soporte Unicode para identificadores en destinos modernosExperiencia de desarrollador mejorada para promesasComprobación de tipo más estricto de generadoresTypeScript versión 3.7 presenta estas y otras características que podemos usar con Angular versión 9:Operador de encadenamiento opcional (?.) similar al operador de navegación segura para plantillas AngularOperador de unión con nulos (??)Funciones de afirmación de pruebas (assert parameterName is typeName y asserts parameterName)await de primer nivelAlias ​​de tipo recursivo mejoradoMejora de la experiencia del desarrollador para funciones de comprobacionesGeneración mejorada del lado del servidor con Angular UniversalAngular Universal versión 9 se lanza con un servidor de desarrollo Node.js Express para proporcionar un entorno realista durante el desarrollo.También parte de este lanzamiento es un constructor del CLI para pre-renderizar rutas estáticas usando guess-parser, inspirado en angular-prerender. Podemos pasar un archivo de rutas para renderizar rutas dinámicas (rutas con parámetros).¿Cómo empiezo?Podemos agregar Angular Universal usando el comando ng add @nguniversal/express-engine. Luego podemos usar el comando del constructor ng run myapp:serve-ssr para iniciar el servidor de desarrollo de renderizado del lado del servidor con recarga en vivo. De manera similar, podemos usar ng run myapp:prerender para detectar rutas estáticas y dinámicas y pre renderizarlas.Experiencia de clases y estilo mejoradaAl aplicación de estilo en Angular Ivy ha sido reelaborado. La combinación de clases HTML estáticas con las directivas NgStyle yNgClass es ahora totalmente compatible y más fácil de entender.Soporte de propiedades personalizadas de CSSComo parte de la reescritura del estilo Ivy, ahora se admiten las propiedades personalizadas de CSS enlazadas.Un ejemplo de enlace css puede ser así:1 &lt;div [style.--my-var]=\"myProperty || 'any value'\"&gt;&lt;/div&gt;Las propiedades personalizadas de CSS tienen control de alcance, por lo que esta propiedad de CSS se limitaría al DOM del componente.Lanzamiento estable de Bazel como opción de suscripciónBazel versión 2.1 es una herramienta de automatización de compilación opcional para Angular versión 9.¿Cómo empiezo?Para habilitar Bazel, usa ng add @angular/bazel o la colección de esquemas @angular/bazel cuando generes un espacio de trabajo Angular.Asegúrate de seguir la guía de instalación de Bazel para tu sistema operativo.Componentes AngularLa versión Angular 9 viene con componentes oficiales para YouTube y Google Maps. Se agregó una directiva y un servicio de portapapeles al Angular CDK.PruebasLa mayor sorpresa de la versión Angular versión 9 son las muchas mejoras en las pruebas. Se resuelven problemas de rendimiento, se mejoran los tipos y se introducen nuevos conceptos.Obtén información sobre las principales características y mejoras para las pruebas en “Pruebas de siguiente nivel en Angular Ivy versión 9”.ConclusiónUno de los objetivos más importantes ha sido mantener la compatibilidad hacia atrás entre Ivy y View Engine tanto como fue posible.Por supuesto, la versión Angular 9 también incluye correcciones de errores, temas obsoletos y cambios importantes. Ivy también aborda algunos problemas de antiguos que no cubrimos en este artículo.Angular Ivy es un facilitador para las características que están por venir. Como hemos discutido en este artículo, Ivy ya nos ha dado beneficios para diferentes casos de uso. Sin embargo, las mejores características llegarán en futuras versiones de Angular. ¿Cuál de las posibles características que se entregarán en las versiones 10 y 11 de Angular está por decidir?Solo discutimos qué es parte de las API públicas y estables de Angular versión 9. Algunas API experimentales son parte de esta versión, como renderComponent,markDirty y detectChanges. Sin embargo, todavía están sujetos a cambios.Con la retirada de las declaraciones de componentes de entrada y los componentes con carga diferida utilizando módulos de representación, estamos un paso más cerca de [componentes que se pueden eliminar del árbol y módulos Angular opcionales](https://indepth.dev/angular-revisited-tree-shakable-components- y-opcional-ngmodules /).Los componentes de funcionalidad también forman parte de esta versión, pero solo están expuestos para uso interno de Ivy.La versión de Angular Ivy versión 9 nos brinda mejoras para el empaquetamiento, las pruebas, la experiencia del desarrollador, las herramientas, la depuración y la verificación de tipos. Toda una buena colección de características.Recursos relacionadosComponentes con carga lentaInformación sobre los módulos de presentación en la charla “Angular revisited: Tree-shakable components and optional NgModules”.Aprende a usar los componentes de carga diferida en “Lazy load components in Angular” por Kevin Kreuzer.Comprobación de tipos en plantillasLee la guía oficial sobre la verificación de tipos en plantillas Angular para conocer los detalles de la resolución de problemas y la configuración.GlobalizaciónManfred Steyer analiza las configuraciones regionales de carga diferida en “Lazy Loading Locales with Angular”.Cédric Exbrayat analiza la globalización de Ivy en “Internationalization with @angular/localize”.Ámbitos adicionales de proveedor de dependenciasObtén información sobre los ámbitos de proveedor de &#39;any&#39; y &#39;platform&#39; en “Improved Dependeny Injection with the new providedIn scopes ‘any’ and ‘platform’” by Christian Kohler.Nueva API de depuraciónLee sobre la API de depuración completa en la documentación oficial.Angular Universal versión 9Estos dos artículos entran en detalles de Angular Universal versión 9:“Angular Universal v9: What’s New ?” by Mark Pieszak“Angular v9 &amp; Universal: SSR and prerendering out of the box!” by Sam VloeberghsAprende sobre angular-prerender, la biblioteca que inspiró estas nuevas características de Angular Universal en “Prerender Angular Apps with a single Command” by Christoph Guttandin.Enlace de propiedades personalizadas de CSSMira este tweet y la demostración de Alexey Zuev para ver los enlaces de Propiedades personalizadas de CSS en acción.RevisoresSiempre es útil tener una segunda opinión sobre nuestro trabajo o incluso detectar errores tontos. Para este artículo tuve el placer de ser revisado por:Christoph GuttandinEvgeny FedorenkoSantosh YadavLars Gyrup Brink Nielsen"},{"title":"","date":"2020-02-17T15:43:04.055Z","updated":"2020-02-17T15:43:04.055Z","comments":true,"path":"angular_9-original-clean.html","permalink":"https://academia-binaria.com/angular_9-original-clean.html","excerpt":"","text":"A look at major features in the Angular Ivy version 9 releasepost editorLars Gyrup Brink Nielsen06 February, 20209 min readCover photo by Pixabay on Pexels.AOT everywhere, dynamic globalisation, strict mode, Bazel, and much more.(Yes, Angular Ivy version 9 is now released!)Ivy is enabled by default#In previous versions of Angular, we had to opt-in to Ivy. In version 9, we instead have to opt-out of Ivy if we want to fall back to View Engine. This is possible in both versions 9 and 10 to ensure a smoother transition from View Engine to Ivy.Libraries can be AOT-compiled, but this is not recommended. The Angular team has a View Engine-to-Ivy migration plan which recommends only publishing JIT-compiled View Engine-compatible libraries for Angular version 9. The Angular compatibility compiler will upgrade View Engine-compatible libraries to Ivy when installed in an Angular Ivy application project.Learn about library compatibility and the View Engine-to-Ivy transition plan in “The Angular Ivy guide for library authors”.123456// tsconfig.json&#123; &quot;angularCompilerOptions&quot;: &#123; &quot;enableIvy&quot;: false &#125;&#125;123// polyfills.ts// Only used in multilingual Ivy applications// import &apos;@angular/localize/init&apos;;Listing 1. Opting out of Ivy to fall back to View Engine.If you experience problems with Ivy in your application or any of the libraries you depend on, you can opt out of Ivy and fall back to View Engine by clearing the enableIvy Angular compiler option and disabling @angular/localize as seen in Listing 1.Opting out of Ivy in a server environment is a bit trickier. Follow the official guide to opt out of Ivy when using server-side rendering.The principle of locality#To compile a component in View Engine, Angular needs information about all its declarable dependencies, their declarable dependencies, and so on. This means that Angular libraries cannot be AOT-compiled using View Engine.To compile a component in Ivy, Angular only needs information about the component itself, except for the name and package name of its declarable dependencies. Most notably, Ivy doesn’t need metadata of any declarable dependencies to compile a component.The principle of locality means that in general we will see faster build times.Lazy-loaded components#entryComponents declarations are deprecated as they are no longer needed. Any Ivy component can be lazy loaded and dynamically rendered.This means that we can now lazy load and render a component without routing or Angular modules. However, in practice we have to use component render modules or feature render modules to link a component’s template to its declarable dependencies.Libraries that are only used by a lazy loaded component are even bundled in lazy-loaded chunks.Improvements to differential loading#When differential loading was introduced in Angular version 8, the build process was run once for the ES5 bundle and once for the ES2015+ bundle.In Angular version 9, an ES2015+ bundle is output first. That bundle is then transpiled to a separate ES5 bundle. This way, we don’t have to go through a full build process twice.AOT compilation everywhere#AOT is enabled by default in builds, the development server and even in tests. Previously, AOT compilation was significantly slower than JIT compilation so JIT was used for development and testing. With the build and rebuild time improvements in Ivy, AOT-compilation now has a great developer experience.When we used JIT compilation in some phases of our process and only AOT compilation in the final build, errors were detected only when doing production builds or worse, at runtime.Bundle sizes#Ivy can enable smaller bundles because it uses the Ivy Instruction Set which is a set of tree-shakable runtime rendering instructions. Our bundles will only include the rendering instructions we use in our projects.This is great for use cases such as microfrontends, Angular Elements and web apps where Angular is not controlling the entire document.However, the difference in our bundle sizes between View Engine and Ivy will vary based on the size of our application and the 3rd party libraries we use. In general:Small and simple applications will see a considerable bundle size decrease.Complex applications will see an increase in the main bundle, but a decrease in lazy loaded bundle sizes.This means a considerable combined bundle size decrease for big applications, but could mean an overall increase in bundle size for medium-sized applications. In both cases, the main bundle’s size will probably increase which is bad for the initial page load time.Globalisation#Locales (number formatting, date formatting, and other regional settings) can be dynamically loaded at runtime instead of having to be registered at compile time.12345678// main.tsimport &apos;@angular/localize/init&apos;;import &#123; loadTranslations &#125; from &apos;@angular/localize&apos;;loadTranslations(&#123; &apos;8374172394781134519&apos;: &apos;Hello, &#123;$username&#125;! Welcome to &#123;$appName&#125;.&apos;,&#125;);Listing 2. Dynamically loading translations.As seen in Listing 2, translated texts can also be dynamically loaded at runtime instead of being part of our bundles.The translated texts could be loaded from a database or a file.Multiple languages from a single application bundle#To change language, we have to restart the application, but we don’t have to serve a different application bundle.This means that we can — with some setup — support multiple languages with a single application bundle on a single hostname.Compile time inlining#A localised application will now only be compiled once. Instead of multiple builds to produce a bundle per language, a bundle per language is produced by replacing $localize placeholders with translated texts.We now need to add the package @angular/localize to support localisation (multiple languages). The good news is that we no longer have to include Angular’s localisation code in our bundles if we only have a single language.If we don’t use localised templates, the i18n* Ivy instructions are tree shaked from our bundle.Localisable texts in component models and services#1234567// app.component.ts@Component(&#123; template: &apos;&#123;&#123; title &#125;&#125;&apos;&#125;)export class AppComponent &#123; title = $localize`Welcome to MyApp`;&#125;Listing 3. A translation text placeholder in a component model.A new internationalisation feature is that we can also include placeholders for translated texts in our component models as seen in Listing 3. Previously, this was only possible in templates.Additional provider scopes#We have always had Angular module scope for providers. Angular version 6 introduced the &#39;root&#39; provider scope and tree-shakable providers both for root and Angular module scope providers.Angular version 9 introduces the &#39;platform&#39; and &#39;any&#39; provider scopes. Platform-scoped providers can be shared between multiple Angular applications in the same document. The &#39;any&#39; provider scope will share a provider per module injector. For example one service instance for the eagerly loaded main bundle and one service instance for each lazy loaded Angular module.Improved developer experience#Ivy enables the Angular Language Service to support additional checks while developing. This is a big improvement to the developer experience.File path checks#The Angular Language Service continuously verifies component stylesheet and template paths.Template type checks#Templates are type checked, according to the template type checking mode as described in the “Strict mode” section. Member names and types are verified, even in embedded views. What previously resulted in runtime errors are now detected while developing and building.New debugging API in development mode#ng.probe has been replaced with a new debugging API in development mode. The most notable functions are ng.applyChanges and ng.getComponent.Strict mode#Strict workspace schematic#The ng new workspace schematic now supports the --strict flag which defaults to off (false).1ng new my-app --strictWhen enabled, this parameter adds a few strict TypeScript compiler checks as seen in Listing 4.12345678910// tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; &quot;noImplicitAny&quot;: true, &quot;noImplicitReturns&quot;: true, &quot;noImplicitThis&quot;: true, &quot;noFallthroughCasesInSwitch&quot;: true, &quot;strictNullChecks&quot;: true &#125;&#125;Listing 4. TypeScript compiler options enabled in a strict Angular workspace.Curiously enough, this doesn’t add the same options as if we would simply set &quot;strict&quot;: true in the compilerOptions object. Let’s compare the Angular workspace strict option to the TypeScript compiler strict option.Both have these options in common:noImplicitAnynoImplicitThisstrictNullChecksThe strict Angular workspace option additionally sets these options:noImplicitReturnsnoFallthroughCasesInSwitchwhile the strict TypeScript compiler option additionally sets these options:alwaysStrictstrictBindCallApplystrictFunctionTypesstrictPropertyInitializationWhat’s more, the strict Angular workspace option doesn’t set template type checking to the new strict mode, only the previous full mode.Strict template type checking#We have had the option to enable template type checking since Angular version 5 by setting &quot;fullTemplateTypeCheck&quot;: true in the angularCompilerOptions object.Ivy introduces strict template type checking as seen in Listing 5. When this new Angular compiler option is set, the value offullTemplateTypeCheck is ignored.123456// tsconfig.json&#123; &quot;angularCompilerOptions&quot;: &#123; &quot;strictTemplates&quot;: true &#125;&#125;Listing 5. Enable strict template type checking.The strict template type checking verifies the types of property bindings and respects the strictNullChecks option. It also checks the types of template references to directives and components, including generic types. Template context variables’ types are also checked which is great for NgFor loops. The $event type is checked for event bindings and animations. Even the type of native DOM elements is verified with strict template type checking.These extra checks can lead to errors and false positives under certain circumstance, for eaxmple when using libraries that are not compiled with strictNullChecks. To address this, strict template type checking has options to opt-out and tweak the checks. For example, strictTemplates is actually a shorthand for 8 different Angular compiler options.Improved component and directive class inheritance#Selectorless base classes are now supported for directives and components. Some metadata is now inherited from base component and directive classes. This makes it easier to extend for example Angular Components and Angular Router directives.Latest TypeScript versions#TypeScript versions 3.6 and 3.7 are supported in Angular version 9. Previous TypeScript versions are no longer supported. Refer to Table 1 to compare TypeScript compatibility between all Angular versions.view raw angular-cli-node-js-typescript-support.csv hosted with ❤ by GitHubTable 1. Angular CLI, Angular, Node.js and TypeScript compatibility table.Open in new tab.TypeScript version 3.6 introduces these and other features:Unicode support for identifiers in modern targetsImproved developer experience for promisesStricter type checking of generatorsTypeScript version 3.7 introduces these and other features that we can use with Angular version 9:Optional chaining operator (?.) similar to the safe navigation operator for Angular templatesNullish coalescing operator (??)Assertion functions (assert parameterName is typeName and asserts parameterName)Top-level awaitImproved recursive type aliasesImproved developer experience for functions such as function truthy checksImproved server-side rendering with Angular Universal#Angular Universal version 9 is released with a Node.js Express development server to provide a realistic environment during development.Also part of this release is an Angular CLI builder to prerender static routes using guess-parser, inspired by angular-prerender. We can pass a routes file to prerender dynamic routes (routes with parameters).How do I get started?#We can add Angular Universal using the command ng add @nguniversal/express-engine. We can then use the builder command ng run myapp:serve-ssr to start the server-side rendering development server with live reload. Similarly, we can use ng run myapp:prerender to detect static and dynamic routes and prerender them.Improved styling experience#Styling in Angular Ivy has been reworked. Combining static HTML classes with NgStyle and NgClass directives is now fully supported and easier to reason about.CSS Custom Properties support#As part of the Ivy styling rewrite, binding CSS Custom Properties is now supported.An example binding looks like this:&lt;div [style.--my-var]=&quot;myProperty || &apos;any value&apos;&quot;&gt;&lt;/div&gt;CSS Custom Properties have scope, so this CSS property would be scoped to the component’s DOM.Stable Bazel release as opt-in option#Bazel version 2.1 is an opt-in build automation tool for Angular version 9.How do I get started?#To enable Bazel, use ng add @angular/bazel or use the @angular/bazel schematics collection when generating an Angular workspace.Make sure to follow the Bazel installation guide for your operating system.Angular Components#Angular version 9 comes with official components for YouTube and Google Maps. A clipboard directive and service are added to the Angular CDK.Testing#The biggest surprise of the Angular version 9 release is the many improvements to testing. Long-standing performance issues are resolved, types are improved and new concepts are introduced.Learn about major features and improvements for testing in “Next-level testing in Angular Ivy version 9”.translatedConclusion#One of the most important goals has been to keep backwards compatibility between Ivy and View Engine as much as possible.Of course, Angular version 9 also includes bugfixes, deprecations, and breaking changes. Ivy also addresses some long-standing issues that we did not cover in this article.Angular Ivy is an enabler for features to come. As we have discussed in this article, Ivy has already given us benefits for different use cases. However, the best features are to come in future versions of Angular. Which of the possible features that will be delivered in Angular versions 10 and 11, that is still to be decided.We only discussed what is part of the public, stable Angular version 9 APIs. A few experimental APIs are part of this release, such as renderComponent, markDirty, and detectChanges. However, they are still subject to change.With the deprecation of entry component declarations and lazy loaded components using render modules, we are one step closer to tree-shakable components and optional Angular modules.Component features are also part of this release, but only exposed for internal use by Ivy.The Angular Ivy version 9 release gives us improvements for bundling, testing, the developer experience, tooling, debugging, and type checking. Quite a good collection of features.Related resources#Lazy loaded components#Learn about render modules in my talk “Angular revisited: Tree-shakable components and optional NgModules”.Learn how to lazy load components in “Lazy load components in Angular” by Kevin Kreuzer.Template type checking#Read the official guide on Angular template type checking to learn the details of troubleshooting and configuration.Globalisation#Manfred Steyer discusses lazy-loading locales in “Lazy Loading Locales with Angular”.Cédric Exbrayat discusses Ivy globalisation in “Internationalization with @angular/localize”.Additional provider scopes#Learn about the &#39;any&#39; and &#39;platform&#39; provider scopes in “Improved Dependeny Injection with the new providedIn scopes ‘any’ and ‘platform’” by Christian Kohler.New debugging API#Read about the full debugging API in the official documentation.Angular Universal version 9#These two articles goes into the details of Angular Universal version 9:“Angular Universal v9: What’s New ?” by Mark Pieszak“Angular v9 &amp; Universal: SSR and prerendering out of the box!” by Sam VloeberghsLearn about angular-prerender, the library that inspired these new Angular Universal features in “Prerender Angular Apps with a single Command” by Christoph Guttandin.CSS Custom Properties binding#See this tweet and demo by Alexey Zuev to see CSS Custom Properties bindings in action.Peer reviewers#It’s always helpful to have a second opinion on our work or even just catch silly errors. For this article I had the pleasure of being reviewed by:Christoph GuttandinEvgeny FedorenkoSantosh YadavLars Gyrup Brink Nielsen"}],"posts":[{"title":"Un vistazo a las características principales en el lanzamiento de Angular _Ivy_ versión 9","slug":"un-vistazo-a-las-características-principales-en-el-lanzamiento-de-Angular-Ivy-versión-9","date":"2020-02-19T16:19:39.000Z","updated":"2020-02-19T15:56:31.180Z","comments":true,"path":"un-vistazo-a-las-características-principales-en-el-lanzamiento-de-Angular-Ivy-versión-9/","link":"","permalink":"https://academia-binaria.com/un-vistazo-a-las-características-principales-en-el-lanzamiento-de-Angular-Ivy-versión-9/","excerpt":"Un vistazo a las características principales en el lanzamiento de Angular Ivy versión 9Este artículo es una traducción aprobada por el autor y editor originales.Enlace original en inglés A look at major features in the Angular Ivy version 9 release del 6 de febrero de 2020Autor original Lars Gyrup Brink NielsenEn resumen con Angular 9 tenemos cambios. MUCHOS y en todas partes: globalización dinámica, modo estricto, Bazel y mucho más.(Y sí, ahora por fin se ha lanzado Angular Ivy versión 9)","text":"Un vistazo a las características principales en el lanzamiento de Angular Ivy versión 9Este artículo es una traducción aprobada por el autor y editor originales.Enlace original en inglés A look at major features in the Angular Ivy version 9 release del 6 de febrero de 2020Autor original Lars Gyrup Brink NielsenEn resumen con Angular 9 tenemos cambios. MUCHOS y en todas partes: globalización dinámica, modo estricto, Bazel y mucho más.(Y sí, ahora por fin se ha lanzado Angular Ivy versión 9)Ivy está habilitado por defectoEn versiones anteriores de Angular, tuvimos que optar por Ivy. En la versión 9, tenemos que optar por no participar en Ivy si queremos recurrir a View Engine. Esto es posible en ambas versiones 9 y 10 para garantizar una transición más fluida de View Engine a Ivy.Las librerías se pueden compilar AOT, pero no es recomendable. El equipo de Angular tiene un plan de migración de View Engine a Ivy que recomienda publicar solo librerías compatibles con View Engine compiladas con JIT para Angular versión 9. El compilador de compatibilidad Angular actualizará las librerías compatibles con View Engine a Ivy cuando se instalen en una aplicación Angular Ivy.Obtén información sobre la compatibilidad de la biblioteca y el plan de transición de View Engine-to-Ivy en “La guía de Angular Ivy para autores de librerías” .123456// tsconfig.json&#123; \"angularCompilerOptions\": &#123; \"enableIvy\": false &#125;&#125;123// polyfills.ts// Solo se usa en aplicaciones multilingües de Ivy// import '@angular/localize/init';Listado 1. Optar por no usar Ivy para recurrir a View Engine.Si tienes problemas con Ivy en tu aplicación, o en cualquiera de las librerías de las que depende, puedes optar por salir de Ivy y recurrir a View Engine. Hazlo desactivando la opción del compilador angular enableIvy y deshabilitando@angular/localize como se ve en Listado 1.Optar por evitar Ivy en un entorno de servidor es un poco más complicado. Sigue la guía oficial para darte de baja de Ivy cuando uses la renderización del lado del servidor.El principio de localidadAntes, para compilar un componente en View Engine, Angular necesitaba información sobre todas sus dependencias declaradas. Esto significa que las librerías Angular no se pueden compilar AOT usando View Engine.Ahora para compilar un componente en Ivy, Angular solo necesita información sobre el componente en sí. Pero, Ivy no necesita metadatos de ninguna dependencia declarable para compilar un componente.El principio de localidad significa que, en general, veremos tiempos de construcción más rápidos.Componentes con carga diferidaLas declaraciones entryComponents están en desuso porque ya no son necesarias. Cualquier componente Ivy puede cargarse de forma diferida y renderizarse dinámicamente.Esto significa que ahora podemos cargar de forma diferida y renderizar un componente sin enrutamiento o módulos Angular. Sin embargo, en la práctica aún tenemos que usar módulos para renderizar componentes o módulos funcionales para vincular la plantilla de un componente a sus dependencias.Las librerías que solo son utilizadas por un componente con carga diferida se agrupan en fragmentos con carga diferida.Mejoras en la carga diferencialCuando se introdujo la carga diferencial en Angular versión 8, el proceso de compilación se ejecutaba una vez para el paquete ES5 y otra vez para el paquete ES2015+.En Angular versión 9, primero se emite un paquete ES2015+. Ese paquete se transfiere a un paquete ES5 separado. De esta manera, no tenemos que pasar por un proceso de compilación completo dos veces.Compilación AOT en todas partesAOT está habilitado de forma predeterminada en las compilaciones, el servidor de desarrollo e incluso en las pruebas. Anteriormente, la compilación AOT era significativamente más lenta que la compilación JIT, por lo que JIT se usaba para el desarrollo y las pruebas. Con las mejoras de tiempo de construcción y reconstrucción en Ivy, la compilación AOT ahora ofrece una gran experiencia al desarrollador.Cuando utilizábamos la compilación JIT en desarrollo y solo la compilación AOT en la compilación final, algunos errores se detectaban solo al hacer compilaciones de producción o, peor aún, en tiempo de ejecución.Tamaños de paqueteIvy puede habilitar paquetes más pequeños porque usa el Ivy Instruction Set, que es un conjunto de instrucciones de representación de tiempo de ejecución potencialmente tree-shakable. Nuestros paquetes solo incluirán las instrucciones de renderizado que realmente usamos en nuestros proyectos.Esto es ideal para casos de uso como micro-frontends, Angular Elements y aplicaciones web donde Angular no controla todo el documento.Sin embargo, la diferencia en los tamaños de nuestros paquetes entre View Engine e Ivy variará según el tamaño de nuestra aplicación y las librerías de terceros que utilizamos. En general:Las aplicaciones pequeñas y simples verán una disminución considerable del peso del paquete.Las aplicaciones complejas verán un aumento en el fichero principal, pero una disminución en los tamaños de paquetes con carga diferida.Esto significa una disminución considerable del tamaño de descarga combinada para aplicaciones grandes, pero podría significar un aumento en el peso total para aplicaciones medianas. En ambos casos, el tamaño del paquete principal probablemente aumentará, lo que es malo para el tiempo de carga inicial de la página.GlobalizaciónLas configuraciones regionales (formato de número, formato de fecha y otras configuraciones regionales) se pueden cargar dinámicamente en tiempo de ejecución en lugar de tener que registrarse en tiempo de compilación.12345678// main.tsimport '@angular/localize/init';import &#123; loadTranslations &#125; from '@angular/localize';loadTranslations (&#123; '8374172394781134519': '¡Hola, &#123;$nombre de usuario&#125;! Bienvenido a &#123;$appName&#125;. ',&#125;);Listado 2. Carga dinámica de traducciones.Como se ve en el Listado 2, los textos traducidos también se pueden cargar dinámicamente en tiempo de ejecución en lugar de ser parte de nuestros paquetes.Los textos traducidos pueden cargarse desde una base de datos o un archivo.Múltiples idiomas desde un único paquete de aplicacionesPara cambiar el idioma, tenemos que reiniciar la aplicación, pero no tenemos que servir un fichero de aplicaciones diferente.Esto significa que podemos, con alguna configuración, admitir varios idiomas con un solo paquete de aplicaciones en un solo nombre de host.Tiempo de compilación en líneaUna aplicación localizada ahora solo se compilará una vez. En lugar de múltiples compilaciones para producir un paquete por idioma, se produce un paquete por idioma reemplazando los marcadores de posición $localize con textos traducidos.Ahora hay que agregar el paquete @angular/localize para posibilitar la localización (varios idiomas). La buena noticia es que ya no tenemos que incluir el código de localización de Angular en nuestros paquetes si solo tenemos un idioma.Si no usamos plantillas localizadas, las instrucciones de Ivy i18n * se sacan del paquete principal.Textos localizables en modelos de componentes y servicios1234567// app.component.ts@Component(&#123; template: '&#123;&#123; title &#125;&#125;'&#125;)export class AppComponent &#123; title = $localize`Welcome to MyApp`;&#125;Listado 3. Un marcador de posición de texto de traducción en un modelo de componente.Una nueva característica de internacionalización es que también podemos incluir marcadores de posición para textos traducidos en el contenido de nuestros modelos como se ve en el Listado 3. Anteriormente, esto solo era posible en las plantillas.Ámbitos adicionales de proveedores de dependenciasSiempre hemos tenido alcance de módulo para los proveedores de inyección de servicios. La versión Angular 6 introdujo el alcance &#39;root&#39; y los proveedores tree-shakable, tanto para los proveedores de alcance desde el módulo raíz como desde módulos inferiores.La versión angular 9 presenta los nuevos ámbitos de proveedor &#39;platform&#39; y &#39;any&#39;. Los proveedores con ámbito de &#39;platform&#39; se pueden compartir entre múltiples aplicaciones Angular en el mismo documento. El alcance del proveedor &#39;any&#39; compartirá un proveedor por inyector de módulo. Por ejemplo, una instancia de servicio para el paquete principal cargado por adelantado y una instancia de servicio para cada módulo cargado con retraso.Experiencia mejorada del desarrolladorIvy permite que Angular Language Service admita comprobaciones adicionales durante el desarrollo. Esta es una gran mejora para la experiencia del desarrollador.Comprobaciones de ruta de archivoAngular Language Service verifica continuamente la hoja de estilo de componentes y las rutas de plantilla.Verificaciones de tipo de plantillaLas plantillas se verifican por tipo, de acuerdo con el modo de verificación de tipo de plantilla como se describe más abajo en la sección “Modo estricto”. Los nombres y tipos de miembros se verifican, incluso en vistas incrustadas. Lo que anteriormente resultaba en errores de tiempo de ejecución ahora se detecta durante el desarrollo y la construcción.Nueva API de depuración en modo de desarrollong.probe ha sido reemplazado por una nueva API de depuración en modo de desarrollo. Las funciones más notables son ng.applyChanges yng.getComponent.Modo estrictoEsquema estricto del espacio de trabajoEl comando ng new ahora es compatible con el indicador--strict que por defecto está desactivado (false).1ng new my-app --strictCuando está habilitado, este parámetro agrega algunas comprobaciones estrictas del compilador TypeScript como se ve en el Listado 4.12345678910// tsconfig.json&#123; \"compilerOptions\": &#123; \"noImplicitAny\": true, \"noImplicitReturns\": true, \"noImplicitThis\": true, \"noFallthroughCasesInSwitch\": true, \"strictlyNullChecks\": true &#125;&#125;Listado 4. Opciones del compilador TypeScript habilitadas en un estricto espacio de trabajo angular.Curiosamente, esto no agrega las mismas opciones que si simplemente estableciéramos &quot;strict&quot;: true en el objeto compilerOptions. Comparemos la opción estricta del workspace Angular con la opción estricta del compilador TypeScript.Ambos tienen estas opciones en común:noImplicitAnynoImplicitThisstrictlyNullChecksLa opción estricta de Angular establece además estas opciones:noImplicitReturnsnoFallthroughCasesInSwitchmientras que la opción estricta del compilador TypeScript establece adicionalmente estas opciones:alwaysStrictstrictlyBindCallApplystrictlyFunctionTypesestrictoPropertyInitializationAdemás, la opción de Angular no establece la comprobación del tipo de plantilla en el nuevo modo estricto, lo deja en el modo &#39;full&#39; anterior.Verificación estricta del tipo de plantillaHemos tenido la opción de habilitar la verificación del tipo de plantilla desde Angular versión 5 configurando &quot;fullTemplateTypeCheck&quot;: true en el objetoangularCompilerOptions.Ivy presenta una estricta comprobación del tipo de plantilla como se ve en el Listado 5. Cuando se establece esta nueva opción del compilador Angular, se ignora el valor de fullTemplateTypeCheck.123456// tsconfig.json&#123; \"angularCompilerOptions\": &#123; \"strictlyTemplates\": true &#125;&#125;Listado 5. Habilita la comprobación estricta del tipo de plantilla.La comprobación de tipo de plantilla estricta verifica los tipos de enlaces de propiedades y respeta la opción stricNullChecks. También verifica los tipos de referencias de plantilla a directivas y componentes, incluidos los tipos genéricos. También se verifican los tipos de variables de contexto de plantilla, lo cual es excelente para los bucles NgFor. El tipo $ event está marcado para enlaces de eventos y animaciones. Incluso el tipo de elementos DOM nativos se verifica con una comprobación estricta del tipo de plantilla.Estas comprobaciones adicionales pueden conducir a errores y falsos positivos bajo ciertas circunstancias. Por ejemplo, cuando se usan librerías que no están compiladas con strictNullChecks. Para abordar esto, la verificación estricta del tipo de plantilla tiene opciones para optar por no participar y ajustar los controles. Por ejemplo, strictTemplates es en realidad una atajo de 8 opciones de compilador Angular.Herencia de clase de componente y directiva mejoradaLas clases base sin selector ahora son compatibles con directivas y componentes. Algunos metadatos ahora se heredan de componentes base y clases directivas. Esto hace que sea más fácil extender, por ejemplo, las directivas Angular Components y Angular Router.Últimas versiones de TypeScriptLas versiones de TypeScript 3.6 y 3.7 son compatibles con la versión angular 9. Las versiones anteriores de TypeScript ya no son compatibles. Consulta la Tabla 1 para comparar la compatibilidad de TypeScript entre todas las versiones Angular.Tabla 1. Tabla de compatibilidad del Angular CLI, Angular, Node.js y TypeScript. Abrir en una pestaña nueva*TypeScript versión 3.6 presenta estas y otras características:Soporte Unicode para identificadores en destinos modernosExperiencia de desarrollador mejorada para promesasComprobación de tipo más estricto de generadoresTypeScript versión 3.7 presenta estas y otras características que podemos usar con Angular versión 9:Operador de encadenamiento opcional (?.) similar al operador de navegación segura para plantillas AngularOperador de unión con nulos (??)Funciones de afirmación de pruebas (assert parameterName is typeName y asserts parameterName)await de primer nivelAlias ​​de tipo recursivo mejoradoMejora de la experiencia del desarrollador para funciones de comprobacionesGeneración mejorada del lado del servidor con Angular UniversalAngular Universal versión 9 se lanza con un servidor de desarrollo Node.js Express para proporcionar un entorno realista durante el desarrollo.También parte de este lanzamiento es un constructor del CLI para pre-renderizar rutas estáticas usando guess-parser, inspirado en angular-prerender. Podemos pasar un archivo de rutas para renderizar rutas dinámicas (rutas con parámetros).¿Cómo empiezo?Podemos agregar Angular Universal usando el comando ng add @nguniversal/express-engine. Luego podemos usar el comando del constructor ng run myapp:serve-ssr para iniciar el servidor de desarrollo de renderizado del lado del servidor con recarga en vivo. De manera similar, podemos usar ng run myapp:prerender para detectar rutas estáticas y dinámicas y pre renderizarlas.Experiencia de clases y estilo mejoradaAl aplicación de estilo en Angular Ivy ha sido reelaborado. La combinación de clases HTML estáticas con las directivas NgStyle yNgClass es ahora totalmente compatible y más fácil de entender.Soporte de propiedades personalizadas de CSSComo parte de la reescritura del estilo Ivy, ahora se admiten las propiedades personalizadas de CSS enlazadas.Un ejemplo de enlace css puede ser así:1 &lt;div [style.--my-var]=\"myProperty || 'any value'\"&gt;&lt;/div&gt;Las propiedades personalizadas de CSS tienen control de alcance, por lo que esta propiedad de CSS se limitaría al DOM del componente.Lanzamiento estable de Bazel como opción de suscripciónBazel versión 2.1 es una herramienta de automatización de compilación opcional para Angular versión 9.¿Cómo empiezo?Para habilitar Bazel, usa ng add @angular/bazel o la colección de esquemas @angular/bazel cuando generes un espacio de trabajo Angular.Asegúrate de seguir la guía de instalación de Bazel para tu sistema operativo.Componentes AngularLa versión Angular 9 viene con componentes oficiales para YouTube y Google Maps. Se agregó una directiva y un servicio de portapapeles al Angular CDK.PruebasLa mayor sorpresa de la versión Angular versión 9 son las muchas mejoras en las pruebas. Se resuelven problemas de rendimiento, se mejoran los tipos y se introducen nuevos conceptos.Obtén información sobre las principales características y mejoras para las pruebas en “Pruebas de siguiente nivel en Angular Ivy versión 9”.ConclusiónUno de los objetivos más importantes ha sido mantener la compatibilidad hacia atrás entre Ivy y View Engine tanto como fue posible.Por supuesto, la versión Angular 9 también incluye correcciones de errores, temas obsoletos y cambios importantes. Ivy también aborda algunos problemas de antiguos que no cubrimos en este artículo.Angular Ivy es un facilitador para las características que están por venir. Como hemos discutido en este artículo, Ivy ya nos ha dado beneficios para diferentes casos de uso. Sin embargo, las mejores características llegarán en futuras versiones de Angular. ¿Cuál de las posibles características que se entregarán en las versiones 10 y 11 de Angular está por decidir?Solo discutimos qué es parte de las API públicas y estables de Angular versión 9. Algunas API experimentales son parte de esta versión, como renderComponent,markDirty y detectChanges. Sin embargo, todavía están sujetos a cambios.Con la retirada de las declaraciones de componentes de entrada y los componentes con carga diferida utilizando módulos de representación, estamos un paso más cerca de tener componentes que se pueden eliminar del árbol y módulos Angular opcionales.Los componentes de funcionalidad también forman parte de esta versión, pero solo están expuestos para uso interno de Ivy.La versión de Angular Ivy versión 9 nos brinda mejoras para el empaquetamiento, las pruebas, la experiencia del desarrollador, las herramientas, la depuración y la verificación de tipos. Toda una buena colección de características.Recursos relacionadosComponentes con carga lentaInformación sobre los módulos de presentación en la charla “Angular revisited: Tree-shakable components and optional NgModules”.Aprende a usar los componentes de carga diferida en “Lazy load components in Angular” por Kevin Kreuzer.Comprobación de tipos en plantillasLee la guía oficial sobre la verificación de tipos en plantillas Angular para conocer los detalles de la resolución de problemas y la configuración.GlobalizaciónManfred Steyer analiza las configuraciones regionales de carga diferida en “Lazy Loading Locales with Angular”.Cédric Exbrayat analiza la globalización de Ivy en “Internationalization with @angular/localize”.Ámbitos adicionales de proveedor de dependenciasObtén información sobre los ámbitos de proveedor de &#39;any&#39; y &#39;platform&#39; en “Improved Dependeny Injection with the new providedIn scopes ‘any’ and ‘platform’” by Christian Kohler.Nueva API de depuraciónLee sobre la API de depuración completa en la documentación oficial.Angular Universal versión 9Estos dos artículos entran en detalles de Angular Universal versión 9:“Angular Universal v9: What’s New ?” by Mark Pieszak“Angular v9 &amp; Universal: SSR and prerendering out of the box!” by Sam VloeberghsAprende sobre angular-prerender, la biblioteca que inspiró estas nuevas características de Angular Universal en “Prerender Angular Apps with a single Command” by Christoph Guttandin.Enlace de propiedades personalizadas de CSSMira este tweet y la demostración de Alexey Zuev para ver los enlaces de Propiedades personalizadas de CSS en acción.RevisoresSiempre es útil tener una segunda opinión sobre nuestro trabajo o incluso detectar errores tontos. Para este artículo el autor tuvo el placer de ser revisado por:Christoph GuttandinEvgeny FedorenkoSantosh YadavCover photo by Pixabay on Pexels.El autor original: Lars Gyrup Brink NielsenEl traductor al español: Alberto BasaloAprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular9","slug":"Angular9","permalink":"https://academia-binaria.com/tag/Angular9/"},{"name":"Ivy","slug":"Ivy","permalink":"https://academia-binaria.com/tag/Ivy/"}]},{"title":"Elementos Angular para los Web Components","slug":"elementos-Angular-para-los-Web-Components","date":"2019-10-29T08:19:39.000Z","updated":"2019-10-28T16:29:59.402Z","comments":true,"path":"elementos-Angular-para-los-Web-Components/","link":"","permalink":"https://academia-binaria.com/elementos-Angular-para-los-Web-Components/","excerpt":"La industria web vive un momento de esplendor y le crecen los frameworks como hierbas primaverales. Pero el estándar HTML no se queda atrás y evoluciona hacia tecnologías potentes y genéricas. Angular Elements promueve la reutilización de código en distintos frameworks para que puedas usar tus componentes Angular en otros entornos.Siendo como es Google una empresa web first, se esfuerzan en incorporar y adaptar de la mejor manera los estándares HTML a sus productos. Con el desarrollo de Angular siempre tuvieron la vista puesta en la tecnología de los Web Components. Buscando que los usos futuros del código se garantizasen más allá del framework de creación.","text":"La industria web vive un momento de esplendor y le crecen los frameworks como hierbas primaverales. Pero el estándar HTML no se queda atrás y evoluciona hacia tecnologías potentes y genéricas. Angular Elements promueve la reutilización de código en distintos frameworks para que puedas usar tus componentes Angular en otros entornos.Siendo como es Google una empresa web first, se esfuerzan en incorporar y adaptar de la mejor manera los estándares HTML a sus productos. Con el desarrollo de Angular siempre tuvieron la vista puesta en la tecnología de los Web Components. Buscando que los usos futuros del código se garantizasen más allá del framework de creación.Partiendo del código tal como quedó en Internacionalización y puesta en producción. Al finalizar tendrás unos componentes que podrás utilizar fuera de Angular.Código asociado a este tutorial en GitHub: AcademiaBinaria/angular-boss1. Componentes independientes del frameworkHay lácteos que aguantan más que algunos frameworks.Seguramente este no sea el caso de Angular, ni de otros frameworks de adopción masiva como React, Vue o Svelte. Todos ellos tienen un presente brillante y un futuro garantizado al plazo que la tecnología pueda vislumbrar. Pero más temprano que tarde otra tecnología o paradigma disruptivo los desplazará. O al menos los obligará a cambiar tanto que sean irreconocibles.Para entonces, y también mientras tanto, nuestro código será cautivo del framework en el que nació. Pero eso cambiará con los Web Components.1.1 Origen y potencialLos Web Components son independientes de los frameworks. Esta es la idea clave; se pueden desarrollar con el estándar pelado de JavaScript o con cualquier framework moderno. Pero lo fundamental es que no exigen nada especial para ejecutarse. Esto permite la interoperabilidad y también extiende la vida útil de tus creaciones.Usos posiblesPartiendo de dichas premisas es fácil entrever todo el potencial y casos dónde aplicarlos. Por ejemplo:Librerías de diseño multiplataforma.Migración paulatina de aplicaciones legacy.Integración dinámica en grandes soluciones CMS.Mejoras funcionales en aplicaciones server side.1.2 Estándares y tecnologíaBajo el término Web Components se esconden diversas tecnologías. No todas ellas están al mismo nivel de aceptación, e incluso alguna no ha visto la luz, pero este es un esbozo de lo que tenemos:Shadow DOM: Manipulación de un árbol en memoria antes de aplicar sus cambios al verdadero.HTML templates: Fragmentos de HTML que no se utilizan en la carga de la página, pero que se pueden instanciar más adelante.ES Modules: Inclusión de documentos JS en forma de módulos de manera estándar y ágil.Custom elements: son etiquetas HTML con funciones encapsuladas, reutilizables y listas para usar en páginas y aplicaciones web.El estándar:Los Custom Web Elements sólo requieren HTML y JavaScript.La tecnología:Angular Elements empaqueta tus componentes como Custom Web Elements.2. Desarrollo y despliegue con AngularUn componente común de AngularPartimos de un componente Angular normal y corriente. Un conversor (sí, ya sé que es sólo un miserable multiplicador) de monedas.libs\\currency\\src\\lib\\converter\\converter.component.html123456789101112&lt;form&gt; &lt;label&gt;Amount to convert: &lt;/label&gt; &lt;input name=\"amount\" [(ngModel)]=\"amount\" type=\"number\" (change)=\"convert()\" /&gt; &lt;label&gt;Converted amount: &lt;/label&gt; &lt;input name=\"convertedAmount\" [(ngModel)]=\"convertedAmount\" type=\"number\" readonly /&gt;&lt;/form&gt;libs\\currency\\src\\lib\\converter\\converter.component.ts12345678910111213141516171819@Component(&#123; selector: 'angular-boss-converter', templateUrl: './converter.component.html', styleUrls: ['./converter.component.css']&#125;)export class ConverterComponent implements OnInit &#123; @Input() factor = 1.1; @Input() amount = 0; @Output() converted = new EventEmitter&lt;number&gt;(); convertedAmount = 0; constructor() &#123;&#125; ngOnInit() &#123; this.convert(); &#125; convert() &#123; this.convertedAmount = this.amount * this.factor; this.converted.next(this.convertedAmount); &#125;&#125;El componente sigue siendo AngularEs tan normal y corriente que puedo importar su módulo y usarlo en cualquier aplicación Angular.apps\\warehouse\\src\\app\\app.module.ts12345678import &#123; CurrencyModule &#125; from '@angular-boss/currency';@NgModule(&#123; imports: [ CurrencyModule ],&#125;)export class AppModule &#123;&#125;apps\\warehouse\\src\\app\\app.component.html12&lt;angular-boss-converter amount=\"100\" factor=\"1.5\"&gt;&lt;/angular-boss-converter&gt;2.1 Exponer los componentesPero ahora todo va a cambiar. Necesitamos un proyecto de exportación. Nada especial. Yo le pongo aquí el prefijo external para hacer hincapié en su función de exportación.ng g @nrwl/angular:application external-currencySi el componente a exportar ya ha sido probado, y debería, en este proyecto no necesitamos nada más que el módulo. Así que puedes borrar tranquilamente el AppComponent, e incluso el index.html.Pongámonos con la exportación, para la cual hacen falta herramientas. Pues adelante con ellas. Incorporamos Angular Elements.ng add @angular/elementsAhora ya importamos el componente en el array imports y lo exportamos, pero no en exports ni tampoco en bootstrap. Vamos a incluirlo en entryComponents.apps\\external-currency\\src\\app\\app.module.ts123456789101112131415161718import &#123; ConverterComponent, CurrencyModule &#125; from '@angular-boss/currency';import &#123; Injector, NgModule &#125; from '@angular/core';import &#123; createCustomElement &#125; from '@angular/elements';import &#123; BrowserModule &#125; from '@angular/platform-browser';import 'zone.js';@NgModule(&#123; imports: [BrowserModule, CurrencyModule], entryComponents: [ConverterComponent]&#125;)export class AppModule &#123; constructor(private injector: Injector) &#123;&#125; ngDoBootstrap() &#123; const el = createCustomElement(ConverterComponent, &#123; injector: this.injector &#125;); customElements.define('external-currency-converter', el); &#125;&#125;Los entryComponents son cargados por Angular de forma imperativa, sin necesidad de incluirlos en un html. Menos mal porque este proyecto ni siquiera usa el index.hmlngDoBootstrapJustamente la falta de componentes en el array bootstrap obliga a arrancar la aplicación mediante código. Esto lo hacemos programando en el hook ngDoBootstrap(), un método que será invocado al inicio y en el meteremos la lógica necesaria para definir el Web Component.Son solamente dos instrucciones que usarás para cada componente que quieras transformar en un elemento.1234const el = createCustomElement(ConverterComponent, &#123; injector: this.injector&#125;);customElements.define('external-currency-converter', el);En la primera se crea el elemento mediante una función constructora que ofrece @angular/elements. Para ello necesita un puntero al componente original y el sistema de inyección de dependencias de Angular. (El cual a su vez reclamamos en el constructor del módulo).La segunda instrucción ya no es propia de Angular. Simplemente se le asigna al elemento recién creado el selector tag por el que será conocido.Atención a la importación de zone.js.Es necesaria para poder usar la detección de cambios en aplicaciones no Angular.2.2 Compilación y despliegueA partir de aquí se acabó el trabajo de programación. Y toca el más tedioso de operaciones de compilación y distribución.Afortunadamente podemos aplicar la magia de @angular/elements y utilidades como ngx-build-plus para compilarlo como un Web Component.Agregar herramientas de ayudaLo primero es instalar una herramienta que mejora el proceso de compilación del CLI.ng add ngx-build-plus --project external-currencyEsencialmente usa webpack para empaquetar el resultado de la compilación build nativa del CLI. Pero no necesitas profundizar en su interior para usarla en el día día.PolyfillsCon el Internet Explorer hemos topado. Y otros navegadores antiguos, claro. El caso es que para que entiendan este nuevo estándar, tenemos que incluir una serie de arreglos llamados polyfills, que rellenan los huecos de incomprensión de los viejos exploradores. Así que para garantizar la compatibilidad en todos los navegadores instalamos todo lo necesario usando ngx-build-plus.ng g ngx-build-plus:wc-polyfill --project external-currencyOjo que en algunas versiones se equivoca en la generación de los assets y hay que moverlos a mano.CompilaciónYa solo falta lanzar el comando de compilación ng build. Pero para ajustar un poco más el resultado te propongo que deshabilites el nombrado con hash y por supuesto que uses algunos parámetros que ha incluido ngx-build-plus.Nombres legibles: &quot;outputHashing&quot;: &quot;none&quot;,Generación: ng build --prod --single-bundle --project external-currency3. Consumo en HTMLYa está, el resultado se podrá utilizar en cualquier aplicación HTML. Por ejemplo en una página prácticamente vacía y completamente estándar.apps\\vanilla\\index.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Vanilla Currency&lt;/title&gt; &lt;base href=\"/apps/vanilla/\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Convert money:&lt;/h2&gt; &lt;external-currency-converter amount=\"15\"&gt;&lt;/external-currency-converter&gt; &lt;/body&gt;&lt;/html&gt;¿Que no funciona? Obvio, el navegador no entiende el tag external-currency-converter. Necesitamos el JavaScript de la compilación anterior3.1 CopiarCopia los dos archivos generados en la carpeta de distribucióndist\\apps\\external-currencyY pégalos al lado del html que quieras. Por ejemplo:apps\\vanilla\\3.2 ImportarSon dos porque hay versión clásica y modular. Importa la que necesites o ambas, y ya está.12345&lt;script src=\"main-es2015.js\" type=\"module\"&gt;&lt;/script&gt;&lt;script src=\"main-es5.js\" nomodule defer&gt;&lt;/script&gt;Una web HTML pura, mostrando un componente creado en AngularAhora ya tienes código creado en Angular pero que puedes integrar en cualquier web. Todo este proceso aún puede resultar tedioso, pero es el futuro. Continúa tu formación avanzada para crear aplicaciones Angular fijándote en el Angular Blueprint creado por la iniciativa Angular.Builders y verás como aprendes a programar grandes aplicaciones con Angular.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Elements","slug":"Elements","permalink":"https://academia-binaria.com/tag/Elements/"},{"name":"WebComponents","slug":"WebComponents","permalink":"https://academia-binaria.com/tag/WebComponents/"}]},{"title":"Internacionalización y puesta en producción","slug":"internacionalizacion-y-puesta-en-produccion-con-Angular","date":"2019-10-15T17:50:27.000Z","updated":"2019-10-24T11:38:34.300Z","comments":true,"path":"internacionalizacion-y-puesta-en-produccion-con-Angular/","link":"","permalink":"https://academia-binaria.com/internacionalizacion-y-puesta-en-produccion-con-Angular/","excerpt":"Las aplicaciones web, son la expresión perfecta del mundo globalizado en el que vivimos. Preparar tu aplicación para ese mundo se conoce como internationalization, o recortadamente i18n. Pero globalizar no significa “café con leche para todos”. Atender a las necesidades específicas de tus usuarios es el proceso de localization.Para empezar esto afecta las traducciones de los contenidos: sean datos o textos fijos. Pero también a las adaptaciones culturales para la presentación de fechas, números, iconos… En Angular tenemos herramientas y soluciones para poner en marcha proyectos globalizados.","text":"Las aplicaciones web, son la expresión perfecta del mundo globalizado en el que vivimos. Preparar tu aplicación para ese mundo se conoce como internationalization, o recortadamente i18n. Pero globalizar no significa “café con leche para todos”. Atender a las necesidades específicas de tus usuarios es el proceso de localization.Para empezar esto afecta las traducciones de los contenidos: sean datos o textos fijos. Pero también a las adaptaciones culturales para la presentación de fechas, números, iconos… En Angular tenemos herramientas y soluciones para poner en marcha proyectos globalizados.Partiendo del código tal como quedó en Velocidad y SEO con el SSR de Angular Universal. Al finalizar tendrás una aplicación que adapta a la cultura del usuario.Código asociado a este tutorial en GitHub: AcademiaBinaria/angular-boss1 Traducciones y contenidoTraducir una aplicación es el primer paso para que un usuario la acepte y comprenda mejor. Afecta a los datos que venga dese un API, y afecta a los textos fijos que acompañan a los datos.Como estamos viendo Angular en frontend, me centraré en el problema de los literales en las templates. Existen varias estrategias para tratarlo, aquí veremos la oficial. Se apuesta por dos principios:El programador vea el texto en la plantilla en el idioma nativo escogido para el desarrollo. Así puede hacerse una idea del tamaño y apariencia inicial y facilita mucho la legibilidad del HTML.El usuario descargue la aplicación específica para su idioma, de forma que no necesite llamadas extra ni resolución dinámica para los textos y menajes fijos.1.1 xi18nPara cumplir con esos criterios se necesita extraer del código los literales que se van traducir. Para ello se usa una herramienta y un convenio.La herramienta es xi18n que viene con el CLI. El convenio es la directiva i18n que viene con Angular. El uso es muy sencillo, como puedes ver este ejemplo.apps\\warehouse\\src\\app\\app.component.html123456789101112&lt;header&gt; &lt;h1 i18n&gt;Welcome to the Angular Builders Warehouse&lt;/h1&gt;&lt;/header&gt;&lt;img src=\"../assets/Warehouse-Building.jpg\" alt=\"Warehouse building\" i18n-alt&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;footer&gt; &lt;a href=\"https://angular.builders\" target=\"blank\"&gt;Angular.Builders: &lt;/a&gt; &lt;span i18n&gt;a store of resources for developers and software architects.&lt;/span&gt;&lt;/footer&gt;Para la extracción se recomienda, como siempre, crear un script en el package.json123&#123; \"i18n:warehouse\": \"ng xi18n warehouse --output-path src/locale\",&#125;Atención IVY: por el momento debemos desactivar el renderizador Ivy para poder realizar la extracción.apps\\warehouse\\tsconfig.app.json12345&#123;\"angularCompilerOptions\": &#123; \"enableIvy\": false &#125;&#125;Aparecerá un fichero xml un tanto feo: /src/locale/messages.xlf. Aunque es procesable automáticamente, por ahora vamos a usarlo de forma manual. Para empezar crea una copia y nómbrala incluyendo el idioma destino. Por ejemplomessages.es.xlfSólo tendrás que duplicar cada etiqueta source en su equivalente traducido target… y traducirlo, claro. Te pongo aquí un ejemplo de como quedaría.12345678&lt;trans-unit id=\"5c08a98fac06c803712ab27dbb81d889af5ef5fb\" datatype=\"html\"&gt; &lt;source&gt;Welcome to the Angular Builders Warehouse&lt;/source&gt; &lt;target&gt;Bienvenido al almacén de Angular Builders&lt;/target&gt; &lt;context-group purpose=\"location\"&gt; &lt;context context-type=\"sourcefile\"&gt;src/app/app.component.html&lt;/context&gt; &lt;context context-type=\"linenumber\"&gt;2&lt;/context&gt; &lt;/context-group&gt;&lt;/trans-unit&gt;Necesitarás crear tantos ficheros como idiomas tengas que mantener. Si son muchos te recomiendo usar alguna herramienta. Tampoco debes olvidarte de realizar este proceso ante cada despliegue para incorporar los posibles cambios.Y hablando de despliegue..1.2 Build configurationsUna vez que tenemos las traducciones en los ficheros de idioma, ahora hay que compilarlos para generar una versión distribuible específica para cada idioma. De nuevo esto es un proceso un tanto tedioso la primera vez, y que desde luego merece ser automatizado.Se trata de crear una nueva entrada en la rama architect/build/configurations de tu aplicación en el fichero angular.json.12345678910111213\"production-es\": &#123; \"fileReplacements\": [ &#123; \"replace\": \"apps/warehouse/src/environments/environment.ts\", \"with\": \"apps/warehouse/src/environments/environment.prod.es.ts\" &#125;, ], \"outputPath\": \"dist/apps/warehouse/es/\", \"i18nFile\": \"apps/warehouse/src/locale/messages.es.xlf\", \"i18nFormat\": \"xlf\", \"i18nLocale\": \"es\", \"baseHref\": \"es\",&#125;Esencialmente se le dicen las rutas y los ficheros que debe utilizar durante el proceso de construcción. Para usarla definimos un par de scripts. Uno para la construcción en sí mediante ng build y el otro para poder ver el resultado con un servidor de ficheros estáticos.1234&#123; \"build:warehouse-es\": \"ng build warehouse --configuration=production-es\", \"start:warehouse-es\": \"npm run build:warehouse-es &amp;&amp; angular-http-server --path ./dist/apps/warehouse/es\",&#125;2 Adaptaciones culturales de tiempo y monedaPero no todo van a ser textos. También hay fechas, número, imágenes… Se necesitan hacer pequeñas adaptaciones en un montón de lugares. En Angular, algunas son casi gratis.2.1 Registro manual en app.module o Auto registro en angular.jsonHabrás usado pipes como date o number desde el día que empezaste con Angular. Si no haces nada especial seguro que te chocó ver que las fechas y los números en formato norte americano. Es el que viene de fábrica, pero e fácil cambiarlo.ManualPuedes asignar la cultura en tu aplicación de forma implícita registrándola al inicio del módulo raíz. La clave está en importar el fichero con las definiciones particulares de tu cultura.Todo está descargado en node-modules. Pero sólo se empaqueta y envía al navegador la cultura seleccionada.1234import &#123; registerLocaleData &#125; from '@angular/common';import localeEs from '@angular/common/locales/es';registerLocaleData(localeEs);AutomáticoOtra forma es usar el fichero package.json para configurarlo. Puedes establece la cultura deseada en la propiedad i18nLocale.1\"i18nLocale\": \"es\"2.2 Tiempo, moneda y contenidoEn cualquier caso, todos los pipes deAngular empezarán a comportarse educadamente conforme a la cultura establecida.apps\\warehouse\\src\\app\\app.component.html1234&lt;article class=\"card\"&gt; &lt;p&gt;&#123;&#123; building.date | date:'long' &#125;&#125;&lt;/p&gt; &lt;p&gt;$&#123;&#123; building.value | number &#125;&#125;&lt;i&gt; &#123;&#123; building.status &#125;&#125;&lt;/i&gt;&lt;/p&gt;&lt;/article&gt;apps\\warehouse\\src\\app\\app.component.ts123456789101112public building = &#123; date: Date.now(), value: 2345.897, status: 'buy'&#125;;constructor() &#123; if (this.building.status === 'buy') &#123; this.building.status = environment.buy; &#125; else &#123; this.building.status = environment.sell; &#125;&#125;Otra cosa pueden ser pequeños textos, lógica , iconos o clases css. A veces todo esto varía de un país a otro. Esas variaciones puedes almacenarla en ficheros externos o dentro del código. Pero si optas por esto ultimo entonces es mejor que uses los environments para almacenar configuraciones específicas.12345678910# Original environment.prod.ts&#123; buy: 'for buy', sell: 'for sell'&#125;# En español environment.prod.es.ts&#123; buy: 'para comprar', sell: 'para vender'&#125;Ahora ya tienes una aplicación que se puede desplegar adaptada a las preferencias culturales de tus usuarios. Continúa tu formación avanzada para crear aplicaciones más allá del framework con los Elementos Angular para los Web Components y verás como aprendes a programar con Angular 8.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"i18n","slug":"i18n","permalink":"https://academia-binaria.com/tag/i18n/"}]},{"title":"Velocidad y SEO con el SSR de Angular Universal","slug":"velocidad-y-seo-con-el-ssr-de-angular-universal","date":"2019-10-09T11:50:27.000Z","updated":"2019-10-16T14:23:01.028Z","comments":true,"path":"velocidad-y-seo-con-el-ssr-de-angular-universal/","link":"","permalink":"https://academia-binaria.com/velocidad-y-seo-con-el-ssr-de-angular-universal/","excerpt":"Las SPA JavaScript, muy balanceadas hacia el navegador, nacieron para crear con tecnología web aplicaciones de negocio. Normalmente se desplegaban en intranets, o en internet para usuarios autorizados. Eran aplicaciones de uso intensivo, visita recurrente y alto rendimiento diario. El éxito tecnológico de frameworks como Angular las llevó a ser usadas para desarrollar webs clásicas de internet y ser utilizadas por visitantes ocasionales.Pero en esta situación presentaron dos problemas para los que inicialmente no estaban preparadas. Por un lado la primera visita de un humano obligaba a la descarga completa de la aplicación antes de poder ver nada. Y nada era lo que veían los visitantes robóticos que pretendían indexar un sitio. Las soluciones a estos problemas incluyen, entre otras medidas, una vuelta al servidor. Lo que en Angular se conoce como aplicación universal.","text":"Las SPA JavaScript, muy balanceadas hacia el navegador, nacieron para crear con tecnología web aplicaciones de negocio. Normalmente se desplegaban en intranets, o en internet para usuarios autorizados. Eran aplicaciones de uso intensivo, visita recurrente y alto rendimiento diario. El éxito tecnológico de frameworks como Angular las llevó a ser usadas para desarrollar webs clásicas de internet y ser utilizadas por visitantes ocasionales.Pero en esta situación presentaron dos problemas para los que inicialmente no estaban preparadas. Por un lado la primera visita de un humano obligaba a la descarga completa de la aplicación antes de poder ver nada. Y nada era lo que veían los visitantes robóticos que pretendían indexar un sitio. Las soluciones a estos problemas incluyen, entre otras medidas, una vuelta al servidor. Lo que en Angular se conoce como aplicación universal.Partiendo del código tal como quedó en PWA, Entre la web y las apps con Angular. Al finalizar tendrás una aplicación que ofrece lo que buscan tanto a personas como a robots.Código asociado a este tutorial en GitHub: AcademiaBinaria/angular-boss1 Angular Universal1.1 Vuelta al servidorTenemos: Angular nació para vivir en el navegador.Para quitarle carga al servidor generando el contenido dinámico en el navegador en base a plantillas.Para enviar por la red primero la aplicación y después los datos, ahorrando transferencia durante un uso continuado.Para mejorar la experiencia del usuario al no percibir recarga de página durante la navegación dentro de la aplicación.Ideal en entornos de intranet o aplicaciones de gestión de uso intensivo.Problemático para uso esporádico o indexable públicamente.Queremos: Indexado SEO y velocidad en la primera visita y también en las sucesivas.1.2 Para mejorar el SEOEl contenido se genera durante la ejecución del JavaScript en el navegador.Los robots no tienen nada significativo que indexar.Las redes sociales no encuentran cabeceras para mejorar la presentación de enlaces.Hay que enviar el contenido ya generado.Pero sin perder la experiencia de usuario durante la ejecución.1.3 Para mejorar la experiencia en la primera visitaPara mostrar contenido antes hay que descargar y ejecutar la aplicación.Los usuarios ven una página vacía demasiado tiempo.El peso de la descarga inicial es desproporcionado a pesar de lazy loading.Hay que enviar el contenido ya generado.Descargar la aplicación en segundo plano.2 Despliegue con Node ExpressEl reto está en mantener lo bueno de las aplicaciones JavaScript como es la transición fluida entre páginas, la interactividad o la descarga de datos bajo demanda, pero combinado con una mejor primera experiencia. Para ello la descarga del index.html tiene que venir con un documento html ya preparado con algo para mostrar y tardar lo menos posible en permitir la interacción.El tiempo para el primer pintado se ve penalizado por el tamaño del bundle principal de Angular, pues en él reside habitualmente el componente app que actúa de raíz. Por supuesto que utilizar la carga diferida de módulos es una manera obligada de reducir el peso del main. Todas las rutas, incluida la ruta base, deben ser lazy para retrasar la navegación y que la descarga se produzca más tarde. Sólo el componente raíz con la shell de navegación básica debería venir en el bundle principal.Pero ni con eso es suficiente. El usuario no verá nada hasta que Angular se descargue, reclame el bundle main, lo procese y renderice ese shell. Hay usar alguna estrategia extra para reducir el tiempo de espera y entretener al usuario.2.1 Add Express EngineClaro que esto es sólo un truco para que ese primer momento de espera se reduzca y no perdamos potenciales visitantes. Si queremos algo más, como por ejemplo que el contenido a descargar sea más fresco, entonces necesitaremos renderizar en el servidor. Y para ello necesitaremos un servidor de verdad. El propuesto y mejor documentado es Express de NodeJS.Para empezar tendrás que instalar y registrar las librarías necesarias. Además habrá que crear el pequeño servidor Express, y configurar al CLI para que haga el despliegue de ambos: cliente y servidor. Este laborioso trabajo se ha automatizado y ahora mismo se resuelve casi todo con una instrucción.1ng add @nguniversal/express-engine --clientProject shop2.2 Scripts de compilado y despliegueCuando termina la generación e instalación, comienza el compilado. En este caso es doble, porque además de la compilación habitual que llamaremos client-bundle, habrá que compilar el servidor con su propia versión de la aplicación cliente. Será el server-bundle.Además necesitamos una tercera compilación (aunque no es propiamente de Angular) para el servidor node/express que ejecutará el server-bundle. Y por último ya sólo nos queda poner en marcha dicho servidor que se quedará a la espera de peticiones de páginas.Todo esto se resume en los siguientes scripts, casi todos auto generados por el CLI.1234567&#123; \"start:ssr\": \"npm run build:ssr &amp;&amp; npm run serve:ssr\", \"build:ssr\": \"npm run build:client-and-server-bundles &amp;&amp; npm run compile:server\", \"build:client-and-server-bundles\": \"ng build --prod &amp;&amp; ng run shop:server:production --bundleDependencies all\", \"compile:server\": \"webpack --config webpack.server.config.js --progress --colors\", \"serve:ssr\": \"node dist/server\"&#125;2.3 Control de rutasEl resultado es un servidor Node que a cada petición web responde enviando el index.html. Pero, y esta es la clave, resolverá la ruta ejecutando la aplicación Angular antes de responder al navegador. De esa forma el index.html irá recién generado con el contenido tal cual lo vería el usuario tras la ejecución de Angular en local. Así que la espera al primer pintado significativo se reduce y eso es bueno.Por si fuera poco, la principal ventaja al usar este método es que al traer información dinámica puede usarse para indexar el contenido real del sitio. Esto es doblemente bueno, porque ahora todos los robots indexadores podrán catalogar tu site como si de una web clásica se tratase. Y los usuarios humanos podrán continuar la ejecución en local disfrutando de las ventajas de una SPA.El trabajo del servidor a partir de ese momento será mayúsculo. Recibe la petición, invoca a su versión de nuestra aplicación Angular y la ejecuta en memoria. El resultado es un documento HTML que devolverá al usuario. Dará lo mismo que ruta se le pida y si se resuelve por lazy-loading. Va totalmente preparado y configurado para cargar el JavaScript oportuno y ejecutarlo como lo haría un navegador.Compruébalo solicitando diversas rutas e inspeccionando la respuesta del servidor.12http://localhost:4000http://localhost:4000/ratesDe todas formas tengo que advertirte de que tomes todo esto con cautela por varios motivos:Tecnología compleja estable pero con carenciasHerramientas de generación buenas pero incompletasTransferencia de estado manual para evitar llamadas repetidas al APITampoco es sencilla la convivencia con librerías propias del browser, y menos si se trata de una PWA. Yo procuro usar un servicio que aisle al servidor de ciertas llamadas sólo disponibles en el navegador, como por ejemplo todo lo relativo al localStorage.123456789101112131415161718192021222324import &#123; isPlatformBrowser, isPlatformServer &#125; from '@angular/common';import &#123; Inject, Injectable, PLATFORM_ID &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root'&#125;)export class UniversalService &#123; constructor(@Inject(PLATFORM_ID) private platformId: string) &#123;&#125; public isBrowser() =&gt; isPlatformBrowser(this.platformId); public isServer() =&gt; isPlatformServer(this.platformId); public saveOnStorage(key, value) &#123; if (this.isBrowser()) &#123; sessionStorage.setItem(key, value); &#125; else &#123; &#125; &#125; public loadFromStorage(key) &#123; if (this.isBrowser()) &#123; sessionStorage.getItem(key); &#125; else &#123; return null; &#125; &#125;&#125;3 Variantes: shell y pre-renderingLa técnica vista anteriormente resuelve los problemas de usuario y de robot SEO, pero a costa de cierta complejidad. Y, sobre todo, a costa de necesitar un servidor node en producción.En algunas situaciones queremos desplegar la aplicación en un sencillo servidor de ficheros. A veces ni siquiera tenemos la necesidad del indexado completo.Para esos caso tenemos alternativas más sencillas.3.1 Shell para mejora de experiencia inicialMuestra un contenido instantáneo mientras descarga la app.Mejora la experiencia de usuario en la primera visita.De cara al SEO, sólo indexa el contenido inicial.Adecuado para aplicaciones de usuario registrado, pero con un portal de bienvenida indexable y rápido.La más sencilla es hacer que el index.html, habitualmente vacío, se rellene con un contenido visualizable mientras el proceso principal de Angular no arranca. En ocasiones basta con poner a mano algún mensaje o animación que indique que estamos cargando. Pero cuanto más se parezca esa primera visión al resultado final mejor para el usuario. Así que lo propio sería que el index.html ya bajase con el shell real de la aplicación.Montar eso a mano no es la mejor opción. La solución parte de renderizar el html durante el proceso de deploy. Se trata de configurar el CLI para que ejecute la aplicación en la máquina del desarrollador sobre una ruta predefinida; y que copie el resultado sobre el index.html que enviará a distribución.Este trabajo se ha automatizado y se resuelve con un par de comandos del Angular CLI.1ng g app-shell --client-project shop --universal-project server-shopEl efecto de este comando se materializa especialmente con la aparición de nuevos targets para los builders del CLI en el fichero angular.json.Con el comando ng run shop:app-shell podrás generar una versión especial de distribución en al que el index.html ya va prerenderizado con el contenido del componente asociado a la ruta shell. Realmente lo que hace es ejecutar tu aplicación sobre una ruta predefinida, tomar el html resultado e inyectarlo en el body del index.html que irá a distribución.Por cierto, esta técnica no obliga a disponer de ningún servidor web especial. Sigue funcionando con un servidor estático de ficheros pues la prerenderización se produjo en la máquina del programador.3.2 Pre renderizado de toda la aplicaciónSe trata de volver no sólo al servidor web, si no al servidor de ficheros.La idea es invocar repetidamente al SSR y almacenar el HTML resultante en ficheros físicos.En producción, los robots y los usuarios recibirán ya esas copias pre generadas.Para mantener el sistema actualizado se necesita regenerar frecuentemente los ficherosAdecuado para blogs y sitios que no puedan o no quieran tener un servidor web corriendo.A falta de una solución oficial, podemos seguir la pista a iniciativas tipo Angular Prerender4 SEO en la página, en el navegador y en el servidorCon lo visto hasta ahora tu aplicación estará más que cubierta en cuanto a ofrecer la mejor experiencia para usuarios al tiempo que envía contenido indexable para robots… Pero falta algo.Habitualmente las aplicaciones Angular manejan el contenido visible de una página web; es decir, el body. Para acceder y cambiar el contenido del header, tan utilizado por los robots de redes sociales, hay que usar algo más.4.1 Titulo y meta etiquetas de páginaComo parte del framework viene la librería platform-browser dónde tenemos un par de servicios para manipular el título y cualquier etiqueta de meta información de la página.Para ello suele usarse un código similar a este en el componente raíz de la aplicación. Es muy sencillo pero te dará una idea del potencial de estos servicios:123456789101112import &#123; Meta, Title &#125; from '@angular/platform-browser';@Component(&#123; selector: 'app-root', template: `&lt;p&gt;Aprende a usar el framework Angular&lt;/p&gt;`,&#125;)export class AppComponent implements OnInit &#123; constructor(private title: Title, private meta: Meta) &#123;&#125; ngOnInit() &#123; this.title.setTitle('My title'); this.meta.addTag(&#123; property: 'og:title', content: 'My title' &#125;, true); &#125;&#125;Ahora ya tienes una aplicación que satisface a usuarios y robots por igual. Continúa tu formación avanzada para crear aplicaciones Angular para el mundo globalizado con técnicas de Internacionalización y puesta en producción y verás como aprendes a programar con Angular 8.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Universal","slug":"Universal","permalink":"https://academia-binaria.com/tag/Universal/"},{"name":"SSR","slug":"SSR","permalink":"https://academia-binaria.com/tag/SSR/"}]},{"title":"PWA, Entre la web y las apps con Angular","slug":"pwa-entre-la-web-y-las-apps-con-angular","date":"2019-10-03T17:50:27.000Z","updated":"2019-10-09T11:58:29.618Z","comments":true,"path":"pwa-entre-la-web-y-las-apps-con-angular/","link":"","permalink":"https://academia-binaria.com/pwa-entre-la-web-y-las-apps-con-angular/","excerpt":"Las aplicaciones web han evolucionado desde el contenido estático al dinámico, luego al adaptable y ahora se acercan progresivamente a la experiencia y rendimiento de aplicaciones nativas. En Angular se incorporan esas capacidades desde el propio framework.Mediante la librería @ngular/pwa dispondremos de todo lo necesario para ofrecer instalación en escritorio, actualizar la aplicación controladamente, recibir notificaciones del servidor e incluso mejoras en la caché de comunicaciones que pudieran permitir un funcionamiento offline.","text":"Las aplicaciones web han evolucionado desde el contenido estático al dinámico, luego al adaptable y ahora se acercan progresivamente a la experiencia y rendimiento de aplicaciones nativas. En Angular se incorporan esas capacidades desde el propio framework.Mediante la librería @ngular/pwa dispondremos de todo lo necesario para ofrecer instalación en escritorio, actualizar la aplicación controladamente, recibir notificaciones del servidor e incluso mejoras en la caché de comunicaciones que pudieran permitir un funcionamiento offline.Partiendo del código tal como quedó en El patrón Redux con NgRx en Angular. Al finalizar tendrás una aplicación que se instala, actualiza y comporta como una aplicación nativa.Código asociado a este tutorial en GitHub: AcademiaBinaria/angular-boss1 Las herramientas de la librería PWAAprovechando las nuevas características del Angular CLI tenemos el comando ng add @angular/pwa que instala los paquetes y configura cualquier aplicación Angular convirtiéndola en una PWA básica.Estos son los actores y ficheros involucrados en este proceso tras la agregación del paquete pwa.ServiceWorkerModule./angular.json { “serviceWorker”: true }./ngsw-config.json./src/manifest.webmanifest./src/index.html./assets/icons/..Con todo instalado y configurado, querrás probar que funciona. Pero, a primera vista no ocurre nada. Las características PWA están preparadas para funcionar en modo producción. Así que lo primero será ejecutar el comando ng build --prod y lanzar un servidor sobre la carpeta de distribución recién creada.De entre los nuevos ficheros que aparecen hay dos que debes conocer especialmente, el manifest y el service worker.1.1 El manifest.webmanifestEste sencillo documento acompaña al index.html y le da indicaciones al navegador para que trate esta aplicación de manera especial. El fichero en sí contiene una metadata con textos descriptivos, colores e iconos para ser usados por el navegador y el sistema operativo y ofrecerle al usuario que instale la web como una app.Casi todo es cosmético, pero merece la pena prestar especial atención a los iconos. Por defecto el CLI instala distintas versiones del logo oficial de Angular. Una forma cómoda de sustituirlo por los tuyos es usar la herramienta ngx-pwa-icons1234567891011121314151617&#123; \"name\": \"shop\", \"short_name\": \"shop\", \"theme_color\": \"#1976d2\", \"background_color\": \"#fafafa\", \"display\": \"standalone\", \"scope\": \"/\", \"start_url\": \"/\", \"icons\": [ &#123; \"src\": \"assets/icons/icon-72x72.png\", \"sizes\": \"72x72\", \"type\": \"image/png\" &#125;, ... ]&#125;Asegúrate de que en la start_url apunte a la página de inicio correcta y despliega en modo producción en un servidor seguro con https. Pruébalo varias veces en distintos navegadores y verás las distintas experiencias de instalación que ofrecen.1.2 El ngsw-worker.jsEl otro gran fichero, y más importante para los desarrolladores, es el configurador del Service Worker. Cuando un navegador ejecuta un script lo hace en thread dedicado a la interacción con el usuario y la manipulación del DOM. Normalmente ese hilo está muy ocupado, cuando no está saturado. La solución para agilizar los procesos está en usar más threads. Presentamos el worker thread.Se le llama así a los hilos creados a partir del principal y que le ayudan en tareas en segundo plano. Esos hilos tienen prohibido el acceso al DOM, ni lo escuchan ni lo manipulan. Pero a cambio están muy liberados para realizar cálculos complejos o llamadas a servicios. Se comunican con el thread principal a través de un sencillo protocolo de eventos y subscripciones.Una de las tareas para las que más se les utiliza es para la gestión inteligente de las comunicaciones. Este fichero viene pre programado para realizar las siguientes funciones PWA de Angular:Caché de contenido estático para funcionamiento offlineCaché de datos dinámicos para mayor velocidadGestión de instalaciones y versionesNotificaciones de datos pushTodo lo que hay que hacer es configurar estas funciones en un fichero, el ngsw-config.json, ya generado con valores por defecto. El CLI, durante el proceso de construcción en modo producción, copiará y manipulará los scripts y sus configuraciones. En ejecución, el AppModule registrará el script en el navegador, se subscribirá a sus eventos y ejecutará lo configurado por el programador en el json.2 Comunicaciones y cachéEl service worker de Angular está especialmente diseñado para hacerse cargo de las comunicaciones con el servidor. Digamos que se convierte en un interceptor transparente de todas las peticiones http. Tanto de los ficheros propios de la aplicación como de las comunicaciones de datos.2.1 Descarga y actualización de la aplicaciónUna vez descargado el index.html con el contenido mínimo de Angular, diríamos que la aplicación se ha instalado y está lista para ejecutarse. A partir de ese momento el ngsw toma el control y puede pre descargar ficheros en segundo plano; de forma que cuando sean reclamados ya estén disponibles y mejoren la experiencia del usuario.Rutinariamente el servicio se ocupará de consultar novedades en el servidor para mantener los ficheros locales actualizados. Todo ello se configura en la sección assetGroups del ngsw-config.json.Default: Full AppSe descarga la aplicación completa. Tranquilidad, esto sucede en segundo plano y una vez arrancado angular y con el usuario contento viendo ya la página pedida. Al navegar por las páginas la respuesta es instantánea porque los módulos con el código ya están ahí.1234567891011121314151617181920212223\"assetGroups\": [ &#123; \"name\": \"app\", \"installMode\": \"prefetch\", \"resources\": &#123; \"files\": [ \"/favicon.ico\", \"/index.html\", \"/manifest.webmanifest\", \"/*.css\", \"/*.js\" ] &#125; &#125;, &#123; \"name\": \"assets\", \"installMode\": \"lazy\", \"updateMode\": \"prefetch\", \"resources\": &#123; \"files\": [ \"/assets/**\", \"/*.(eot|svg|cur|jpg|png|webp|gif|otf|ttf|woff|woff2|ani)\" ] &#125; &#125;],Eso sí, la descarga consume línea. En cierto casos, con usuarios móviles y grandes aplicaciones quizás no sea adecuado. Si prefieres que los módulos Lazy no se descarguen hasta que nose visiten, te propongo esta otra configuración.Proposed: Lazy App123456789101112131415161718192021222324252627\"assetGroups\":[ &#123; \"name\": \"coreapp\", \"installMode\": \"prefetch\", \"resources\": &#123; \"files\": [ \"/favicon.ico\", \"/index.html\", \"/manifest.webmanifest\", \"/*.css\", \"/common*.js\", \"/main*.js\", \"/ngsw*.js\", \"/*woker*.js\", \"/*polyfills*.js\", \"/runtime*.js\" ] &#125; &#125;, &#123; \"name\": \"lazyapp\", \"installMode\": \"lazy\", \"updateMode\": \"prefetch\", \"resources\": &#123; \"files\": [\"/*.js\"] &#125; &#125;...2.2 Caché inteligente de datosEl control de la recepción de datos dinámicos es la otra gran tarea del service worker. En este caso para tener una caché que acelere la presentación de datos o que incluso permita un funcionamiento offline.Mediante dos estrategias complementarias que tratan de mantener los datos actualizados y disponibles en todo momento. En este caso configurándolo en los dataGroups.La idea del cache-first es tener el dato ya listo para ser usado cuanto antes. Mientras que con api-first se pretende tener la versión más actual posible, y usar la última descargada en caso de problemas o desconexión total.1234567891011121314151617181920212223242526 \"dataGroups\": [ &#123; \"name\": \"cache-first-greeting\", \"urls\": [ \"http://localhost:3333/api\" ], \"cacheConfig\": &#123; \"strategy\": \"performance\", \"maxAge\": \"1d\", \"maxSize\": 10 &#125; &#125;, &#123; \"name\": \"api-first-rates\", \"urls\": [ \"https://api.exchangeratesapi.io/latest?symbols=GBP\", \"https://api.exchangeratesapi.io/latest\" ], \"cacheConfig\": &#123; \"strategy\": \"freshness\", \"timeout\": \"5s\", \"maxAge\": \"1h\", \"maxSize\": 10, &#125; &#125;]3 ServiciosLa librería @angular/pwa publica el módulo ServiceWorkerModule que contiene la lógica de registro del service worker y dos servicios programables con los que interactuar desde el código de tu aplicación Angular.3.1 Actualización con el SwUpdateCuando despliegas una nueva versión seguro que estás deseando que los usuarios disfruten cuanto antes de las mejoras o correcciones. Pero en las aplicaciones SPA resulta que la actualización no es tan inmediata como pudiera parecer. Al no forzar la recarga del documento en las navegaciones internas, el index.html puede residir sin cambios más de lo debido. Confiar en que lo hagan el navegador o el usuario puede no ser una opción.La solución PWA es usar el ServiceWorker para detectar nuevas versiones en el servidor. Para ello utiliza un sistema propio de hashes que le permite comparar la versión descargada y la disponible en el servidor.** Cuando detecta un cambio emite un evento al que te puedes subscribir** usando el servicio SwUpdate. En ese momento puedes consultar al usuario, o forzar a lo bestia la recarga ;-).123456789constructor(private swUpdate: SwUpdate) &#123; if (this.swUpdate.isEnabled) &#123; this.swUpdate.available.subscribe((event: UpdateAvailableEvent) =&gt; &#123; if (confirm(`Do you want to update?`)) &#123; window.location.reload(); &#125; &#125;); &#125;&#125;3.2 Notificaciones con el SwPushUna característica de las apps nativas muy aprecia por los usuarios es la capacidad de mostrar mensajes recibidos vía push por parte del servidor. Pueden ser avisos, novedades o simple marketing. Pero lo importante es que lo recibe el sistema operativo, la aplicación no necesita estar en marcha y el mensaje se muestra de forma nativa.Obviamente para ello hay que involucrar código de servidor y un servicio de mensajería de terceros. Pero la parte Angular del desarrollo es muy sencilla. Consiste en registrar al usuario, que voluntariamente decide ser notificado, y luego escuchar los mensajes provenientes en forma de eventos. Todo ello reclamando una dependencia al servicio de notificaciones constructor(private swPush: SwPush).12345678910constructor(private swUpdate: SwUpdate) &#123; if (this.swPush.isEnabled) &#123; this.swPush .requestSubscription(&#123; serverPublicKey: 'VAPID_PUBLIC_KEY' &#125;) .then(sub =&gt; &#123; console.log('send subscription to your server and wait form messages', sub.toJSON()); this.swPush.messages.subscribe(msg =&gt; console.log('Received: ', msg)); &#125;) &#125;&#125;Ya tienes una web que se comporta progresivamente como una App nativa, una Progressive Web Application. Las mejoras en rendimiento y experiencia de usuario son recompensa más que suficiente para que le des una oportunidad a las Angular PWA.Continúa tu formación avanzada para crear aplicaciones con mayor Velocidad y SEO con el SSR de Angular Universal y verás como aprendes a programar con Angular 8.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"PWA","slug":"PWA","permalink":"https://academia-binaria.com/tag/PWA/"}]},{"title":"El patrón Redux con NgRx en Angular","slug":"el-patron-redux-con-ngrx-en-angular","date":"2019-09-25T11:08:50.000Z","updated":"2019-10-09T11:59:57.492Z","comments":true,"path":"el-patron-redux-con-ngrx-en-angular/","link":"","permalink":"https://academia-binaria.com/el-patron-redux-con-ngrx-en-angular/","excerpt":"Le pasa a todas las aplicaciones, crecen y crecen en funcionalidad y complejidad. En Angular estamos preparados para modularizar, componentizar e inyectar servicios. Pero con grandes aplicaciones, o con grandes equipos, parece que nada es suficiente. Se necesita una gestión del estado centralizada como la del patrón Redux.Si decíamos que Redux no hace rápido lo simple, sino mantenible lo complejo, ahora te digo que NgRx no hace rápido a Redux, sino mantenible su boilerplate. Así que si tienes delante un desarrollo funcionalmente complejo, te recomiendo que uses NgRX; la solución estándar para implementar Redux con Angular.","text":"Le pasa a todas las aplicaciones, crecen y crecen en funcionalidad y complejidad. En Angular estamos preparados para modularizar, componentizar e inyectar servicios. Pero con grandes aplicaciones, o con grandes equipos, parece que nada es suficiente. Se necesita una gestión del estado centralizada como la del patrón Redux.Si decíamos que Redux no hace rápido lo simple, sino mantenible lo complejo, ahora te digo que NgRx no hace rápido a Redux, sino mantenible su boilerplate. Así que si tienes delante un desarrollo funcionalmente complejo, te recomiendo que uses NgRX; la solución estándar para implementar Redux con Angular.Partiendo del código tal como quedó en Redux, flujo reactivo unidireccional con Angular y RxJs. Al finalizar tendrás una aplicación que gestiona centralizadamente los cambios, que permite conocer qué ocurrió y predecir lo que ocurrirá usando NgRx.Código asociado a este tutorial en GitHub: AcademiaBinaria/angular-boss1 Instalación y configuraciónNgRx es el estándar de facto para implementar Redux en Angular. Está basada en RxJS y es una librería modular con todo lo necesario para crear grandes aplicaciones. Esto son los módulos que la componen:store: Es el módulo principal con el administrador del estado centralizado y reactivo.store-devtools: Instrumentación para depurar desde el navegador. Vale su peso en oro.router-Store : Almacena el estado del router de Angular en el store, tratando cada evento como una acción Redux.effects: Los reductores son funciones puras sin efectos colaterales. Este módulo es la solución para comandos asíncronos.schematics, entity, ngrx-data: Son otros módulos opcionales con ayudas y plantillas de NgRX.1.1 Instalación de NgRxPara agregar NgRx a un app te propongo que uses los schematics de NxDev pues disponen de más opciones de configuración inmediata. Aunque la alternativa con el CLI también es suficiente para empezar.1234# with Nx.dev toolsng g @nrwl/angular:ngrx app --module=apps/shop/src/app/app.module.ts --root --minimal# with only CLIng add @ngrx/storeCon esto habrás instalado y configurado NgRx y tu AppModule tendrá algo así:123456789101112131415161718@NgModule(&#123; imports: [ CommonModule, RouterModule, StoreModule.forRoot( &#123;&#125;, &#123; metaReducers: !environment.production ? [] : [], runtimeChecks: &#123; strictActionImmutability: true, strictStateImmutability: true &#125; &#125; ), EffectsModule.forRoot([]) ]&#125;)export class AppModule &#123;&#125;El código generado por cualquiera de los dos schematics no es para todos los gustos. Tómalo como un punto de partida y crea la estructura que mejor te encaje.1.2 DevToolsLa razón principal de usar Redux es la capacidad que da al programador para comprender cómo el estado de sus variables ha variado en el tiempo. Es decir ¿Cómo hemos llegado hasta aquí?. Esta es claramente una cuestión de análisis y depuración de código. Y para ello necesitamos herramientas de desarrollador. Presentamos las Redux DevTools for Chrome.Este es un plugin que se engancha a cualquier solución Redux (no sólo NgRx, ni siquiera sólo Angular) y que permite explorar el valor del estado y lo más interesante: la secuencia de acciones que se ha despachado y el efecto que cada una tuvo sobre el valor del estado.Para realizar el enganche sirve la línea que verás también en el AppModule. La cual activa la monitorización cuando no estamos en producción. Normal, esto es un herramienta para el desarrollador, nunca para el usuario.1!environment.production ? StoreDevtoolsModule.instrument() : [],Para verlo en funcionamiento tienes que ejecutar y abrir tu app en Chrome. Después en la pantalla de inspección del código aparecerá una pestaña al final de todo (más allá de Network y Application…) llamada Redux. La interfaz es muy intuitiva; no tardarás en hacerte con ella. aunque ahora mismo un poco pobre…1.3 RouterPara darle algo de contenido y de paso acercarnos a las capacidades de Redux y NgRx vamos a conectarle el RouterModule de la aplicación. Para ello sirve la siguiente línea que tienes que poner también en la importaciones del AppModule.1StoreRouterConnectingModule.forRoot(&#123; routerState: RouterState.Minimal &#125;)A partir de este momento cada evento de navegación del router va a generar una acción que NgRx recogerá y registrará. Esas acciones y su impacto en el estado se pueden visualizar con el plugin de Redux. Podrás ver los cambios y reproducirlos hacia adelante y atrás. Es como viajar en el tiempo dentro de la ejecución de app.2 ActionsHasta el momento ha sido todo muy de infraestructura, pero es hora de que hagamos algo funcional. Un ejemplo sería agregar a nuestra app un módulo para la gestión de medios de pago de un usuario. Algo así:1234567891011As a: customer, I want: to add payment methods so that: I can pay with themAs a: customer, I want: to select one as preferred so that: I can make fewer clicksAs a: customer, I want: to change de expiration date so that: I get my cards up to datePara ello, y valiendo una vez más de los schematics vamos a agregar una feature12ng g m payments --project=shop --module=app.module.ts --routing --route=paymentsng g @ngrx/schematics:feature payments/store/paymentMethod --project=shop --module=payments/payments.module.ts --no-flat --no-spec --creatorsEsto habrá generado un buen montón de código. Pero todo demasiado genérico. Vamos a empezar a adaptarlo a nuestro problema aportando un modelo de datos.apps\\shop\\src\\app\\payments\\store\\payment-method\\payment-method.model.ts123456789export interface PaymentMethod &#123; id: string; expiration: Date;&#125;export interface PaymentMethods &#123; list: PaymentMethod[]; preferred: string;&#125;Y ahora sí, vamos a por las acciones.2.1 CreateUno de los parámetros usados durante la generación de la feature fue --creators. Esto le indicó a NgRx que preferimos usar funciones en lugar de clases para definir nuestras acciones. Así que en el fichero de definición de acciones te encontrarás con llamadas a una función como esta createAction(&#39;Descripción de la acción&#39;, props&lt;{ parametro: Tipo }&gt;() ).Con esto tenemos que cubrir los dos requerimientos de Redux: las acciones han de tener un tipo y una payload.apps\\shop\\src\\app\\payments\\store\\payment-method\\payment-method.actions.ts123456789101112131415161718export const loadPaymentMethods = createAction( '[PaymentMethod] Load PaymentMethods');export const addPaymentMethod = createAction( '[PaymentMethod] Add PaymentMethod', props&lt;&#123; newPaymentMethod: PaymentMethod &#125;&gt;());export const selectPreferredPaymentMethod = createAction( '[PaymentMethod] Select preferred PaymentMethod', props&lt;&#123; preferredId: string &#125;&gt;());export const setExpirationPaymentMethod = createAction( '[PaymentMethod] Set Expiration Date on PaymentMethod', props&lt;&#123; updatedPaymentMethod: PaymentMethod &#125;&gt;());El código puede resultar extraño a primera vista; pero es siempre igual y acabas familiarizando muy rápido. Esencialmente se trata de dar un nombre a la acción y luego configurarla. Lo imprescindible va a ser un string que la describa. Es recomendable seguir el convenio con el formato [Origen] Nombre acción descriptivo.El segundo argumento de la función creteAction es a su vez otra función. La parte interesante de la función propos&lt;&gt;() está en su tipo genérico. Es ahí dónde definimos el tipo de datos de la payload que puede transportar la acción.2.2 DispatchDefinir el catálogo de acciones es la primera parte del problema. Ahora nos toca invocarlas, o como se dice en el argot Redux: despacharlas. Para ello voy a crear un servicio auxiliar que encapsule toda la interacción con NgRx. Es una implementación del patrón fachada para unificar y facilitar el trabajo con Redux desde fuera.apps\\shop\\src\\app\\payments\\store\\payment-method\\payment-method.service.ts12345678910import &#123; Injectable &#125; from '@angular/core';import &#123; Store &#125; from '@ngrx/store';import * as PaymentMethodActions from './payment-method.actions';import &#123; PaymentMethod, PaymentMethods &#125; from './payment-method.model';@Injectable(&#123; providedIn: 'root'&#125;)export class PaymentMethodService &#123; constructor(private store: Store&lt;PaymentMethods&gt;) &#123;&#125;&#125;Y aquí puedo crear los métodos funcionales que despachen las acciones sobre el store de NgRx.12345678910111213141516171819202122public loadPaymentMethods() &#123; this.store.dispatch(PaymentMethodActions.loadPaymentMethods());&#125;public addPaymentMethod(newPaymentMethod: PaymentMethod) &#123; this.store.dispatch( PaymentMethodActions.addPaymentMethod(&#123; newPaymentMethod: &#123; ...newPaymentMethod &#125; &#125;) ); &#125;public selectPreferredPaymentMethod(preferredId: string) &#123; this.store.dispatch( PaymentMethodActions.selectPreferredPaymentMethod(&#123; preferredId &#125;) );&#125;public setExpirationPaymentMethod(updatedPaymentMethod: PaymentMethod) &#123; this.store.dispatch( PaymentMethodActions.setExpirationPaymentMethod(&#123; updatedPaymentMethod: &#123; ...updatedPaymentMethod &#125; &#125;) );&#125;Es necesario enviar siempre un clon de los argumentos para desconectarlos del origen. En Redux queremos tener la fuente única de la verdad, y eso sólo es posible si los argumentos que recibimos están sellados y aislados del resto del mundo.Para una primera aproximación, reconozco que es mucho código para tan poca funcionalidad. Claro que para quien use esta fachada el mundo es mucho más sencillo. Y por dentro es muy potente y controlable.apps\\shop\\src\\app\\payments\\payments.component.ts123456789101112131415export class PaymentsComponent implements OnInit &#123; constructor(private paymentMethodService: PaymentMethodService) &#123;&#125; ngOnInit() &#123; this.paymentMethodService.loadPaymentMethods(); const visa: PaymentMethod = &#123; id: '1234 7896 3214 6549', expiration: new Date(2020, 6-1, 30) &#125;; this.paymentMethodService.addPaymentMethod(visa); this.paymentMethodService.selectPreferredPaymentMethod(visa.id); visa.expiration = new Date(2021, 12-1, 31); this.paymentMethodService.setExpirationPaymentMethod(visa); &#125;&#125;3 State reducer3.1 StateEl estado en redux es un objeto tipado a partir de una interfaz, inicialmente llamada State a secas, aunque yo prefiero identificarla como PaymentMethodsState. Tendrá propiedades para almacenar objetos más o menos complejos. Cada propiedad tendrá su propio tipo complejo y necesita un estado inicial. Eso es lo que hace este código:apps\\shop\\src\\app\\payments\\store\\payment-method\\payment-method.reducer.ts123456789export const paymentMethodFeatureKey = 'paymentMethod';export interface PaymentMethodsState &#123; paymentMethods: PaymentMethods;&#125;export const initialState: PaymentMethodsState = &#123; paymentMethods: &#123; list: [], preferred: null &#125;&#125;;3.2 Create functionPero todo estado necesita su reductor, y una vez más lo crearemos mediante una función. En este caso es la createReducer(state, on(action1, function1) ). Su encarnación más básica tiene la siguiente pinta:1234const paymentMethodReducer = createReducer( initialState, on(PaymentMethodActions.loadPaymentMethods, state =&gt; state));Lo que hace es definir una serie de hooks para enganchar funciones de mutación en respuesta a las acciones despachadas. Empezamos con la acción loadPaymentMethods y en este caso no por ahora hacemos ninguna mutación al estado. Es un reductor transparente e innecesario. Lo pongo para familiarizarnos con la sintaxis.Vamos a algo más complejo y útil como la acción addPaymentMethod. Funcionalmente queremos agregar el nuevo método de pago que viene en su carga al array actual de métodos de pago. Nada complejo, ya sí deben ser todas las funciones reductoras.Pero, siempre hay un pero, resulta que una función reductora debe ser también una función pura. Y esto nos obliga a mutar el estado sin mutar los argumentos; es decir, nos obliga a clonar el estado y sus propiedades antes de cambiarlas.123456789on(PaymentMethodActions.addPaymentMethod, (state, &#123; newPaymentMethod &#125;) =&gt; &#123; return &#123; ...state, paymentMethods: &#123; ...state.paymentMethods, list: [...state.paymentMethods.list, newPaymentMethod] &#125; &#125;;&#125;)El proceso de clonado puedes hacerlo con mayor o menor profundidad, pero al menos un clonado superficial del estado es obligatorio. Yo aquí he optado por clonar incluso el array interno, aunque no sea estrictamente obligatorio.3.3 Register in StoreEl resultado de esta invocación a createReducer() se será a su vez otra función que yo almacené en la contante paymentMethodReducer. Por requerimiento del proceso de empaquetado con webpack que nada tiene que ver con NgRx, estamos obligados a exportar la función mediante un wrapper como este:apps\\shop\\src\\app\\payments\\store\\payment-method\\payment-method.reducer.ts123export function reducer(state: PaymentMethodsState | undefined, action: Action) &#123; return paymentMethodReducer(state, action);&#125;Hecho esto tenemos ya una función reductora que debemos registrar en el store. Lo que hacemos es decirle a NgRx que cuando llegue una acción de mutado invoque a esta acción pasándole la propiedad del estado encargada gestionar.apps\\shop\\src\\app\\payments\\payments.module.ts1234567import * as fromPaymentMethod from './store/payment-method/payment-method.reducer';@NgModule(&#123; imports: [ StoreModule.forFeature( fromPaymentMethod.paymentMethodFeatureKey, fromPaymentMethod.reducer )]Normalmente el nombre de dicha propiedad se estable en una constante exportada para evitar fallos de tecleo con consecuencias imprevisibles.4 SelectorsHasta ahora hemos definido el estado, y creado las acciones que despachamos conta él. Y hemos creado las funciones reductoras que lo modifican al recibir las acciones. No es poco, pero es la mitad del camino. Nos queda enterarnos de los cambios que se ha realizado. Y para eso nos ofrecen un concepto muy de base de datos select.4.1 Create selectorLos selectores, mejor dicho las funciones selectoras, se crean mediante una función factoría igual que hemos visto para las reductoras y las acciones. La diferencia es que aquí las tenemos que llamar a dos niveles: el de la funcionalidad y el de la propiedad específica que nos interesa.apps\\shop\\src\\app\\payments\\store\\payment-method\\payment-method.selectors.ts12345678910111213141516import &#123; createFeatureSelector, createSelector &#125; from '@ngrx/store';import &#123; paymentMethodFeatureKey, State &#125; from './payment-method.reducer';export const getPaymentMethodState = createFeatureSelector&lt;State&gt;( paymentMethodFeatureKey);export const getPaymentMethodsList = createSelector( getPaymentMethodState, (state: State) =&gt; state.paymentMethods.list);export const getPreferredPaymentMethod = createSelector( getPaymentMethodState, (state: State) =&gt; state.paymentMethods.preferred);Podemos tener tantos selectores como queramos. Se aconseja crearlos para cada tema de interés que pueda tener el resto de la aplicación. Pueden ser simples vista parciales del estado o complejas transformaciones a gusto del consumidor. NgRx lo hace de forma que optimiza cálculos y llamadas así que nos sugieren que abusemos de ellos y encapsulemos aquí todo el acceso al valor y a los cambios del estado.4.2 Selecting dataUna vez más, si queremos que nuestra aplicación se desacople lo más posible de ngRx, debemos llamar a los selectores desde un servicio fachada. Así que añadimos al apps\\shop\\src\\app\\payments\\store\\payment-method\\payment-method.service.ts un par de nuevos métodos públicos.1234567public getPaymentMethodsList$(): Observable&lt;PaymentMethod[]&gt; &#123; return this.store.select(PaymentMethodSelectors.getPaymentMethodsList);&#125;public getPreferredPaymentMethod$(): Observable&lt;string&gt; &#123; return this.store.select(PaymentMethodSelectors.getPreferredPaymentMethod);&#125;4.3 Showing dataEstos métodos devuelven observables a los que suscribirse para mostrar los valores cambiantes del estado. Gracias a la fachada anterior el componente consumidor es completamente inconsciente de la existencia de NgRx.12345678910export class PaymentsComponent implements OnInit &#123; public paymentMethodsList$: Observable&lt;PaymentMethod[]&gt;; public preferredPaymentMethod$: Observable&lt;string&gt;; constructor(private paymentMethodService: PaymentMethodService) &#123;&#125; ngOnInit() &#123; this.paymentMethodsList$ = this.paymentMethodService.getPaymentMethodsList$(); this.preferredPaymentMethod$ = this.paymentMethodService.getPreferredPaymentMethod$(); &#125;&#125;Por supuesto, desde la template lo tratamos como a cualquier otro dato asíncrono.1234&lt;p&gt;Payment Methods List:&lt;/p&gt;&lt;pre&gt;&#123;&#123; paymentMethodsList$ | async | json &#125;&#125;&lt;/pre&gt;&lt;p&gt;Preferred Payment Method:&lt;/p&gt;&lt;pre&gt;&#123;&#123; preferredPaymentMethod$ | async | json &#125;&#125;&lt;/pre&gt;5 EffectsLas funciones reductoras, como ya se ha dicho, deben ser puras. La idea es que puedan ser auditadas, re-ejecutadas y testeadas sin que necesiten servicios externos ni causen efectos colaterales. Y esto es un problema con la cantidad de ejecuciones asíncronas en las aplicaciones web. Cualquier tentación de lanzar una llamada AJAX dentro de un reductor debe ser eliminada de inmediato.Dos razones: por un lado en Angular se necesita invocar al httpClient de alguna manera para realizar la llamada AJAX. Y ya que la función reductora no pertenece a ninguna clase Angular, no puede haber constructor que reclame la inyección de la dependencia a dicho servicio. Tampoco las funciones puras tienen permitido usar nada que no venga entre sus argumentos. Por otra parte las funciones puras han de ser predecibles, y una llamada a un servidor remoto no es en absoluto predecible. Puede pasarle de todo, así que los reductores no son país para procesos asíncronos.La solución que proponen NgRX es usar un artificio llamado efecto, porque será encargado de los efectos secundarios que provocan las las instrucciones asíncronas. De una forma simplista, diremos que las acciones asíncronas se multiplicarán por tres. El comando que genera la llamada, y los dos potenciales eventos con la respuesta correcta o el error.Para manejarlo todo incluyen en la librería el módulo EffectsModule que ha de registrarse junto al StoreModule. Desde ese momento NgRX activa un sistema de seguimiento que trata las acciones como un stream de RxJS y permite subscribirse a la invocación de dichas acciones y tratarlas adecuadamente.5.1 InstallSegún el proceso que hayas escogido para agregar Ngrx puede que ya tengas los efectos agregados o que tengas que hacerlo manualmente mediante un instrucción como esta:1ng add @ngrx/effectsEn cualquier caso aparecerá una instrucción de registro en el módulo raíz o funcional que lo necesite. Por ejemplo el de PaymentsModule es:1EffectsModule.forFeature([])5.2 Efecto básicoEn un ejemplo inicial vamos a intentar almacenar y recuperar los métodos de pago desde el local storage del navegador. Esta es claramente una actividad de riesgo (y no lo dogo sólo por el evidente peligro de seguridad). Pero el acceso puede fallar o no estar disponible. Y en el mejor de los casos es un recurso externo que nunca podría ir dentro de una función reductora.Así que vamos a ver el trabajo necesario para montar esto como Redux manda.AccionesPara empezar agregamos dos nuevas acciones en respuesta a los potenciales eventos que puedan surgir del acceso al local storageapps\\shop\\src\\app\\payments\\store\\payment-method\\payment-method.actions.ts123456789101112export const loadPaymentMethods = createAction( '[PaymentMethod] Load Payment Methods');export const loadPaymentMethodsSucess = createAction( '[PaymentMethod] Load Payment Methods Success', props&lt;&#123; paymentMethodList: PaymentMethod[] &#125;&gt;());export const loadPaymentMethodsError = createAction( '[PaymentMethod] Load Payment Methods Error');Para simplificarlo no estoy reportando nada del error específico. La loadPaymentMethodsError servirá para indicar que el proceso ha fallado. sin más.DefiniciónAhora viene lo bueno. La creación de un efecto. Empezamos como siempre usando una función factoría : createEffect(). Sólo que esta vez va asociada a una propiedad pública de un servicio de Angular. Y aquí ya tenemos todos nuestros juguetes disponibles.Por ejemplo la inyección de dependencias; en el constructor constructor(private actions$: Actions) {} solicitamos como argumento un observable de todas las acciones que se hayan despachado en nuestro store. Ese stream servirá para escuchar y filtrar las acciones que nos interesen. Después haremos nuestra operativa con todas las llamadas que hagan falta.Sólo un requisito. Al terminar hemos de retornar un observable con una nueva acción que el sistema encauzará para ser despachada. Esto obliga a conocer bien los operadores RxJs que están en la base do todo este montaje. De ahí el uso concatMap() y por supuesto del creador observable más básico: of().apps\\shop\\src\\app\\payments\\store\\payment-method\\payment-method.effects.ts1234567891011121314151617181920212223242526public loadPaymentMethods$ = createEffect(() =&gt; this.actions$.pipe( ofType(PaymentMethodActions.loadPaymentMethods), concatMap(() =&gt; &#123; try &#123; let storedList = JSON.parse( window.localStorage.getItem(this.storeKey) ); if (!storedList) &#123; storedList = initialState.paymentMethods.list; window.localStorage.setItem( this.storeKey, JSON.stringify(storedList) ); &#125; return of( PaymentMethodActions.loadPaymentMethodsSucess(&#123; paymentMethodList: storedList &#125;) ); &#125; catch (e) &#123; return of(PaymentMethodActions.loadPaymentMethodsError); &#125; &#125;) ));Tómate tu tiempo para entender este efecto, y recuerda que por raro que te parezca al principio, te acabarás acostumbrando muy pronto porque siempre sigue el mismo esquema.Reducer y RegisterPor si te olvidabas, todo este trabajo no altera para nada al estado. Recuerda que sólo las reductoras asociadas a las acciones lo hacen. Así que incrementamos nuestro código con nuevos casos para el reductor.apps\\shop\\src\\app\\payments\\store\\payment-method\\payment-method.reducer.ts12345678910on( PaymentMethodActions.loadPaymentMethodsSucess, (state, &#123; paymentMethodList &#125;) =&gt; &#123; return &#123; ...state, paymentMethods: &#123; ...state.paymentMethods, list: paymentMethodList &#125; &#125;; &#125; ), on(PaymentMethodActions.loadPaymentMethodsError, state =&gt; state),Y para finalizar registramos la clase que contiene al efecto (como un provider especial) en el módulo de efectos.apps\\shop\\src\\app\\payments\\payments.module.ts1EffectsModule.forFeature([PaymentMethodEffects])5.3 Api asyncUna vez familiarizado con la sintaxis de los efectos básicos, es hora de pasar a los que sin duda se utilizan más: los efectos sobre servicios asíncronos. Es decir casi todas las llamadas a un API. Algo muy sencillo podría ser agregar a nuestra tienda un converso de divisas para saber los precios en distintas monedas.123As a: customer, I want: to see the current exchange rate in several currencies so that: I can decideActionsA estas alturas te pido un último esfuerzo para que interpretes el siguiente código:apps\\shop\\src\\app\\rates\\store\\exchange-rate\\exchange-rate.actions.ts12345678910111213export const loadExchangeRates = createAction( '[ExchangeRate] Load ExchangeRates');export const loadExchangeRatesSuccess = createAction( '[ExchangeRate] Load ExchangeRates Success', props&lt;&#123; rates: any &#125;&gt;());export const loadExchangeRatesError = createAction( '[ExchangeRate] Load ExchangeRates Error', props&lt;&#123; rates: any &#125;&gt;());Efectivamente, para cada llamada usaremos tres acciones. El comando que la inicia y los dos eventos que pueden ocurrir success and error.Effectapps\\shop\\src\\app\\rates\\store\\exchange-rate\\exchange-rate.effects.ts12345678910111213141516export class ExchangeRateEffects &#123; public loadExchangeRates$ = createEffect(() =&gt; this.actions$.pipe( ofType(ExchangeRateActions.loadExchangeRates), concatMap(() =&gt; this.http.get&lt;any&gt;('https://api.exchangeratesapi.io/latest').pipe( map(res =&gt; ExchangeRateActions.loadExchangeRatesSuccess(&#123; rates: res.rates &#125;) ), catchError(err =&gt; of(ExchangeRateActions.loadExchangeRatesError(&#123; rates: err &#125;)) ) ))) ); constructor(private actions$: Actions, private http: HttpClient) &#123;&#125;&#125;Paradójicamente un efecto que incluya una llamada http es más sencillo, pues la naturaleza asíncrona de Ajax junto con el uso de Observables en httpClient nos dejan medio trabajo hecho.Lo que realmente hacemos es encauzar el flujo de acciones pipe(concatMap()) hacia un flujo de respuestas http this.http.get(). Pero claro esto es trampa, así que de nuevo encauzamos la respuesta hacia una acción pipe(map(res=&gt; actionSuccess(res))). Cuando la respuesta no llega volvemos a lo que ya sabemos, crear un nuevo observable con of(actionError(err)).Aquí lo dejamos. Soy consciente de que Redux es complejo. Soy consciente de que NgRx añade mucho código de infraestructura. Pero también te animo a revisar este artículo y practicar con un caso sencillo antes de tomar cualquier decisión. Incluir NgRx o no hacerlo tiene un alto impacto en el mantenimiento de tu proyecto. No te tires a de cabeza ni lo rechaces de plano.Descarga y revisa la aplicación de ejemplo. Si la dominas, entonces es que ya tienes los conocimientos para gestionar de manera centralizada, auditable y predecible el estado de tus programas. El patrón Redux lucirá más cuanto más grande y compleja sea tu aplicación.Continúa tu formación avanzada para crear aplicaciones PWA, entre la web y las apps con Angular y verás como aprendes a programar con Angular 8.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Redux","slug":"Redux","permalink":"https://academia-binaria.com/tag/Redux/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"NgRx","slug":"NgRx","permalink":"https://academia-binaria.com/tag/NgRx/"}]},{"title":"Base para una aplicación Angular","slug":"base-aplicacion-angular","date":"2019-09-23T11:57:00.000Z","updated":"2019-09-23T11:26:34.055Z","comments":true,"path":"base-aplicacion-angular/","link":"","permalink":"https://academia-binaria.com/base-aplicacion-angular/","excerpt":"Vamos a crear una base sobre la que programar una aplicación Angular 8 profesional. Usaremos el CLI para generar una estructura sobre la que crecer. Será como una semilla para un desarrollo controlado.La idea de árbol se usa en muchas analogías informáticas. La emplearemos en dos conceptos básicos en Angular: los módulos y los componentes.","text":"Vamos a crear una base sobre la que programar una aplicación Angular 8 profesional. Usaremos el CLI para generar una estructura sobre la que crecer. Será como una semilla para un desarrollo controlado.La idea de árbol se usa en muchas analogías informáticas. La emplearemos en dos conceptos básicos en Angular: los módulos y los componentes.Partimos de la aplicación tal cómo la dejamos en el Hola Mundo en Angular. Al finalizar tendrás un esqueleto del que colgar módulos y componentes funcionales.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-basic/1-base1. MódulosLos módulos son contenedores para almacenar los componentes y servicios de una aplicación. En Angular cada programa se puede ver como un árbol de módulos jerárquico. A partir de un módulo raíz se enlazan otros módulos en un proceso llamado importación.1.1 Anatomía de un móduloAntes de usar cualquier módulo hay que conocerlo. En Angular los módulos de declaran como clases de TypeScript. Estas clases, habitualmente vacías, son decoradas con una función especial. Es la función @NgModule() que recibe un objeto como único argumento. En las propiedades de ese objeto es donde se configura el módulo.Mira el módulo AppModule original que genera el CLI en el fichero app.module.ts.1234567@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125;1.1.1 Importación de otros módulosEl módulo App también se conoce como módulo raíz porque de él surgen las demás ramas que conforman una aplicación. La asignación de los nodos hijos se realiza en la propiedad imports:[], que es un array de punteros a otros módulos.En la situación original el módulo principal depende un módulo custom pre-generado (el AppRoutingModule que usarás más adelante) y de otro del framework para la presentación en el navegador (el BrowserModule).Veremos esto con más profundidad en el punto 4.1.2 Generación de módulosHasta ahora los módulos involucrados son librerías de terceros o que se crearon mágicamente con la aplicación. Es hora de crear tu primer módulo. Para eso usaremos otro comando del cli, el ng generate module. En una ventana del terminal escribe:1ng g m coreEsta es la sintaxis abreviada del comando ng generate el cual dispone de varios planos de construcción o blueprints. El que he usado aquí es el de module para la construcción de módulos.Si no te gusta teclear en la terminal, también puedes lanzar estos comandos desde Angular ConsoleEl resultado es la creación del fichero core/core.module.ts con la declaración y decoración del módulo CoreModule.Este módulo te servirá de contenedor para guardar componentes y otros servicios esenciales para nuestra aplicación. Pero eso lo veremos más adelante.12345@NgModule(&#123; imports: [], declarations: []&#125;)export class CoreModule &#123;&#125;Por ahora hay que asegurar que este módulo será importado por el raíz, el AppModule. Para ello comprobaremos que la línea de importación del módulo principal esté parecida a esto:1234567@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, CoreModule], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125;El módulo raíz, al igual que como verás más tarde con el componente raíz, es un tanto especial. Su nombre oficial es App, aunque todo la documentación se refiere a él como raíz o root.2. ComponentesLos módulos son contenedores. Lo primero que vamos a guardar en ellos serán componentes. Los componentes son los bloques básicos de construcción de las páginas web en Angular 8. Contienen una parte visual en html (la Vista) y una funcional en Typescript (el Controlador).La aplicación original que crea el CLI nos regala un primer componente de ejemplo en el fichero app.component.ts. Según la configuración del CLI este componente puede haber sido creado en un sólo fichero o hasta cuatro: (el controlador, con la vista y los estilos en ficheros propios y fichero extra para pruebas unitarias).2.1 Anatomía de un componenteLos componentes, como el resto de artefactos en Angular, serán clases TypeScript decoradas con funciones específicas. En este caso la función es @Component() que recibe un objeto de definición de componente. Igual que en el caso de los módulos contiene las propiedades en las que configurar el componente.12345678import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styles: []&#125;)export class AppComponent &#123;&#125;Los componentes definen nuevas etiquetas HTML para ser usados dentro de otros componentes. Excepcionalmente en este caso por ser el componente raíz se consume en el página index.html. El nombre de la nueva etiqueta se conoce como selector. En este caso la propiedad selector: &quot;app-root&quot; permite el uso de este componente dentro de otro con esta invocación &lt;app-root&gt;&lt;/app-root&gt;. En este caso el componente raíz.Particularidades del componente raíz. Su nombre oficial es AppComponent, y su selector debería llamarse app-app. Pero su selector real es app-root, formado a partir del prefijo de la aplicación y su supuesto nombre oficioso. Observa el prefijo app que se usará en todos los componentes propios, fue asignado por defecto durante la generación de la aplicación. Puede personalizarse usando el modificador --prefix de ng new y en distintos ficheros de configuración. Volviendo al componente raíz; está destinado a ser usado en la página principal, en el index.html. Eso obliga a registrarlo de una manera especial en el módulo raíz. Hay que incluirlo en el array bootstrap: [AppComponent], es ahí donde se incluyen los componentes con la capacidad de lanzar bootstrap la aplicación.1234567@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, CoreModule], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125;Y en el index.html123&lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt;La plantilla representa la parte visual del componente. De forma simplificada, o cuando tiene poco contenido, puede escribirse directamente en la propiedad template del objeto decorador. Pero es más frecuente encontrar la plantilla en su propio fichero html y referenciarlo como una ruta relativa en la propiedad templateUrl.La propiedad styles y su gemela stylesUrl permiten asignar estilos CSS, SASS o LESS al componente. Estos estilos se incrustan durante la compilación en los nodos del DOM generado. Son exclusivos del componente y facilitan el diseño y maquetación granular de las aplicaciones.Los estilos, ausentes en este ejemplo, podrían incluirse como un array de cadenas, o llevarse a un fichero propio como en el caso de la vista.12345&lt;div style=\"text-align:center\"&gt; &lt;h1&gt;Welcome to &#123;&#123; title &#125;&#125;!&lt;/h1&gt; &lt;img width=\"100\" src=\"./assets/logo.png\" /&gt;&lt;/div&gt;...En la clase del componente nos encontraremos la implementación de su funcionalidad. Normalmente expondrá propiedades y métodos para ser consumidos e invocados de forma declarativa desde la vista.Una aplicación web en Angular se monta como un árbol de componentes. El componente raíz ya viene creado y convenientemente declarado; ahora toca darle contenido mediante una estructura de página y las vistas funcionales.2.2 Generación de componentesPara crear nuevos componentes vamos a usar de nuevo el comando generate del CLI . Pero ahora con los planos para construir un componente. La sintaxis completa del comando ng generate component o abreviadamente ng g c permite crear componentes en diversas formas.Casi todas las páginas tienen una estructura similar que de forma simplista queda en tres componentes. Uno para la barra de navegación, otro para el pie de página y otro intermedio para el contenido principal.Ejecuta en una terminal estos comandos para que generen los componentes y comprueba el resultado en el editor.1234ng g c core/shellng g c core/shell/headerng g c core/shell/mainng g c core/shell/footerFíjate en el componente del fichero shell.component.ts. Su estructura es igual a la del componente raíz. Destaca que el nombre del componente coincide con el nombre del selector: app-shell y ShellComponent. Esto será lo normal a partir de ahora. Sólo el componente raíz tiene la excepción de que su nombre App no coincide con su selector root.12345678910import &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-shell', templateUrl: './shell.component.html', styles: []&#125;)export class ShellComponent implements OnInit &#123; constructor() &#123;&#125; ngOnInit() &#123;&#125;&#125;Y esta es su vista asociada. La cual es de nuevo una composición de otros selectores. Estamos creando un frondoso árbol de componentes.123&lt;app-header&gt;&lt;/app-header&gt;&lt;app-main&gt;&lt;/app-main&gt;&lt;app-footer&gt;&lt;/app-footer&gt;3 Visibilidad entre componentesLa clave del código limpio es exponer funcionalidad de manera expresiva pero ocultar la implementación. Esto es sencillo con los lenguajes de POO, pero en HTML no era nada fácil. Con la programación basada en componentes podemos crear pantallas complejas, reutilizables y que a su vez contengan y oculten la complejidad interna a sus consumidores.3.1 Componentes públicos y privadosLos componentes no deciden por sí mismos su visibilidad. Cuando un componente es generado se declara en un módulo contenedor en su propiedad declares:[]. Eso lo hace visible y utilizable por cualquier otro componente del mismo módulo. Pero si quieres usarlo desde fuera tendrás que exportarlo. Eso se hace en la propiedad exports:[] del módulo en el que se crea.La exportación debe hacerse a mano incluyendo el componente en el array, o indicarse con el flag --export para que lo haga el cli. Esto es lo que se ha hecho en el módulo Core para poder exportar el componente shell.123456@NgModule(&#123; declarations: [ShellComponent, HeaderComponent, MainComponent, FooterComponent], imports: [CommonModule, RouterModule], exports: [ShellComponent]&#125;)export class CoreModule &#123;&#125;Los componentes privados suelen ser sencillos. A veces son creados para ser específicamente consumidos dentro de otros componentes. En esas situaciones interesa que sean privados y que generen poco ruido. Incluso, en casos extremadamente simples, si usamos el modificador --flat ni siquiera generan carpeta propia.Por supuesto que HeaderComponent necesitará la propiedad title y también la moveremos desde app.component.ts. Dejando de esa manera el componente raíz en los huesos.3.2 Importación y exportación entre módulosQue un componente sea público es la primera condición para que se consuma fuera de su módulo. Ahora falta que quién lo quiera usar el selector &lt;app-shell&gt; importe su módulo CoreModule. Esto lo haremos en el AppModule para que lo use el AppComponent.1234567@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, CoreModule], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125;Como regla general, cuando en una plantilla se incruste otro componente, Angular lo buscará dentro del propio módulo en el que pretende usarse. Si no lo encuentra entonces lo buscará entre los componentes exportados por los módulos que hayan sido importados por el actual contenedor.Ahora mismo en AppComponente sólo puedo usar a ShellComponent, que es el único componente accesible. En ShellComponent se pueden usar sus vecinos Header, Main y Footer. Es un práctica recomendada el mantener el AppModule y el AppComponent tan simples como sea posible. Para ello movemos todo lo que podemos al módulo de ayuda CoreModule distribuyendo el contenido de app.component.html en las plantillas de Header, Main y Footer que corresponda.3.2.1 Dos mundos paralelos: imports de Angular e import de TypeScriptSi es la primera vez que ves código TypeScript te llamarán la atención las primeras líneas de cada fichero. En el app.module.ts son algo así:1234import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppRoutingModule &#125; from './app-routing.module';import &#123; AppComponent &#125; from './app.component';Estas sentencias de importación son propias del lenguaje y nada tienen que ver con Angular. En ellas se indica que este fichero importa el contenido de otros ficheros TypeScript. La importación se realiza en base a convenios personalizables. Si empieza con ./ entonces se busca a través de la ruta física relativa al fichero actual. En otro caso se busca en el directorio node_modules y se trata como código de terceros.En general no tendrás que preocuparte de estas importaciones físicas, pues el VSCode y las extensiones esenciales se encargan de hacerlo automáticamente según lo uses en tu código4. Transitividad y Organización4.1 Transitividad en una cadena de módulosUn problema que reforzará tu conocimiento sobre el sistema modular surgirá al mover la etiqueta &lt;router-outlet&gt;&lt;/router-outlet&gt; del app.component.html al componente Main. En su vista main.component.html tendrás algo así.12345678910111213&lt;h2&gt;Here are some links to help you start:&lt;/h2&gt;&lt;ul&gt; &lt;li&gt; &lt;h2&gt;&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://angular.io/tutorial\"&gt;Tour of Heroes&lt;/a&gt;&lt;/h2&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://angular.io/cli\"&gt;CLI Documentation&lt;/a&gt;&lt;/h2&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://blog.angular.io/\"&gt;Angular blog&lt;/a&gt;&lt;/h2&gt; &lt;/li&gt;&lt;/ul&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;Todo son etiquetas html estándar salvo la última &lt;router-outlet&gt;&lt;/router-outlet&gt;. El propósito de este componte lo veremos en la próxima lección dedicada a enrutado. Pero por ahora más que una ayuda es un dolor de cabeza porque es un desconocido para el módulo CoreModule. Resulta que el RouterOutletComponent está declarado en un módulo del framework llamado RouterModule. Dicho módulo fue importado de manera automática durante la generación del código inicial, pero ¿Dónde?.Como digo el tema del enrutado es un capítulo aparte, pero las relaciones de los módulos debes conocerlas cuanto antes. Durante la generación inicial se crearon dos módulos: el AppModule, ya estudiado, y su asistente para enrutado AppRoutingModule. Este último aún no lo hemos visitado. Su contenido es:12345678import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123;&#125;Obviando la por ahora inútil instrucción .forRoutes(routes), llama la atención que este módulo es dependiente del famoso RouterModule, es decir lo importa en su array imports:[]. Pero además va y lo exporta haciendo uso de la interesante propiedad transitiva de los módulos. Cada módulo puede exportar sus propios componentes o los de terceros. Incluso puede exportar todo un módulo al completo. Al hacerlo así, el AppRoutingModule estaba poniendo a disposición del AppModule todo el contenido de RouterModule, incluido el por ahora fastidioso RouterOutletComponent.Pero el módulo Core no importa al AppRouting, así que nada sabe de un selector llamado router-outlet. Para solucionarlo sólo puedes hacer una cosa: importar al RouterModule en el CoreModule, que quedará así:1234567891011121314import &#123; CommonModule &#125; from '@angular/common';import &#123; NgModule &#125; from '@angular/core';import &#123; RouterModule &#125; from '@angular/router';import &#123; FooterComponent &#125; from './shell/footer/footer.component';import &#123; HeaderComponent &#125; from './shell/header/header.component';import &#123; MainComponent &#125; from './shell/main/main.component';import &#123; ShellComponent &#125; from './shell/shell.component';@NgModule(&#123; declarations: [ShellComponent, HeaderComponent, MainComponent, FooterComponent], imports: [CommonModule, RouterModule], exports: [ShellComponent]&#125;)export class CoreModule &#123;&#125;4.2 Organización de la aplicación en módulosTodos los programas tiene partes repetitivas. Los principios de organización y código limpio nos permiten identificarlas y reutilizarlas. Con los componentes ocurre lo mismo. El módulo y los componentes recién creados suelen ser comunes a casi todas las aplicaciones. Estos y otros muchos surgirán de manera natural durante el desarrollo de una aplicación para ser utilizados en múltiples páginas.Son componentes de infraestructura. Conviene guardarlos en una carpeta especial. Aquí la he llamado shared, pero tools, common, o lib suelen ser otros nombres habituales. Para reforzar el uso del CLI escribe el siguiente comando que aprovecharemos en el futuro.12ng g m sharedng g c shared/now --export=true123&lt;time&gt; &#123;&#123; now | date:'long' &#125;&#125;&lt;/time&gt;–12ng g m temporalng g c temporal --export=true123&lt;div&gt; &lt;app-now&gt;&lt;/app-now&gt;&lt;/div&gt;1234&lt;main class=\"container \"&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;* &lt;app-temporal&gt;&lt;/app-temporal&gt;&lt;/main&gt;Por ahora déjalo huérfano, no lo importaremos hasta que tengamos módulos funcionales. Sólo anticiparte que es un módulo dónde se hace mucho uso de la propiedad transitiva del sistema modular de Angular.El caso es distinguir los componentes de infraestructura de los de negocio o funcionalidad. Los módulos core y shared los trataremos como de infraestructura y todos los demás serán de negocio (aún no tenemos). El primero es para meter cosas de uso único esenciales para la aplicación. El segundo para meter bloques reutilizables durante la construcción de la aplicación. Recuerda que sólo son convenios de arquitectura de software; adáptalos a tus necesidades.En esta aplicación hasta ahora no es nada funcional,!y ya tiene seis módulos y siete componentes!. Puede parecer sobre-ingeniería, pero a la larga le verás sentido. Por ahora te permitirá practicar con la creación de módulos y componentes.El bosque de módulos a vista de pájaro1234567891011121314151617AppModule|+--AppRoutingModule| || +--RouterModule|+--BrowserModule|+--CoreModule | +--CommonModule | +--RouterModule | +--TemporalModule | +--SharedModuleEl bosque de componentes a vista de pájaro123456789101112131415AppComponent|+--ShellComponent | +--HeaderComponent | +--MainComponent | | | +--RouterOutletComponent | | | +--TemporalComponent | | | +--NowComponent | +--FooterComponentCon esto tendrás una base para una aplicación Angular 8. Sigue esta serie para añadirle funcionalidad mediante Páginas y rutas Angular SPA mientras aprendes a programar con Angular8. Todos esos detalles se tratan en el curso básico online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"CLI","slug":"CLI","permalink":"https://academia-binaria.com/tag/CLI/"}]},{"title":"Hola Angular CLI","slug":"hola-angular-cli","date":"2019-09-23T10:54:00.000Z","updated":"2019-09-23T11:26:34.055Z","comments":true,"path":"hola-angular-cli/","link":"","permalink":"https://academia-binaria.com/hola-angular-cli/","excerpt":"Angular en su versión 8 es la plataforma perfecta para el desarrollo profesional de aplicaciones modernas. El Angular CLI es la herramienta adecuada para generar aplicaciones Angular. Juntos son imbatibles en cuanto a velocidad en desarrollo y a potencia en ejecución.","text":"Angular en su versión 8 es la plataforma perfecta para el desarrollo profesional de aplicaciones modernas. El Angular CLI es la herramienta adecuada para generar aplicaciones Angular. Juntos son imbatibles en cuanto a velocidad en desarrollo y a potencia en ejecución.El comúnmente conocido como AngularCLI o angular cli o angular-cli o _ CLI a secas_ es la herramienta de línea de comandos estándar para crear, depurar y publicar aplicaciones Angular. En su actual versión 8 es más potente y versátil que nunca y es muy sencillo dominar los aspectos básicos.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-basic/0-hello1. Instalación de Angular CLI 8Angular es una plataforma de desarrollo dogmática y llave en mano. Para empezar, como en casi cualquier desarrollo necesitarás NodeJS y su manejador de de paquetes npm. Tenerlos actualizados es un mandamiento básico para un desarrollador web. Comprueba tu versión con el siguiente comando:1node -vEmpieza con una instalación global que te permita usar la herramienta desde cualquier directorio. Comprueba la versión instalada y accede a la ayuda en línea. La ayuda está disponible tanto de modo general como para cada comando que vayas a usar.Instrucciones para instalar Angular CLI.1234$ npm i -g @angular/cli@latest$ ng version$ ng help$ ng new --help2. Crear y ejecutar una aplicación Angular 7Una vez que hayas instalado el CLI de manera global ya puedes empezar a usarlo en tu directorio de trabajo. El primer comando será ng new que te va a generar toda una aplicación funcional y las configuraciones necesarias para su depuración, pruebas y ejecución.Como novedad, en las últimas versiones, el CLI te preguntará por algunas opciones para crear tu aplicación. Eso es porque no todos los desarrollos son iguales. Se puede configurar el tipo, el estilo y muchas más cosas, tanto de forma interactiva como mediante opciones en línea de comandos.Lo más habitual es usar la configuración que viene por defecto, pero también se pueden crear soluciones a medida. Te muestro unos ejemplos para que pruebes y te familiarices con la herramienta. Para más información mira la documentación del comando ng new.2.1 Normal123ng new normalcd normalnpm start2.2 Minimalista123ng new minimalista -s -S -tcd minimalistanpm start2.3 Profesional123ng new profesional -p acme --routing truecd profesionalnpm start2.4 Empresarial1234ng new empresarial --create-application falsecd empresarialng generate application compras -p acme --routing truenpm startUna vez finalizada la instalación de todas las librerías necesarias puedes bajar a la carpeta recién creada y ejecutar el comando standard de npm para el arranque de cualquier aplicación: npm start. Si todo va bien, en unos segundo podrás visitar http://localhost:4000 para ver en marcha la aplicación. Lo veremos con más detalle en el apartado de configuración.ejemplo: La aplicación que sirve de ejemplo a este tutorial fue creada con este comando:1ng new angular-basic --routing true -s -S3. Estructura de una aplicación AngularUna vez generada y comprobada la ejecución, toca estudiar cómo es la estructura de la aplicación. Para ello revisa carpeta a carpeta. Las malas noticias son que hay una enorme cantidad de ficheros y carpetas, las buenas son que como verás, casi todo es configuración e infraestructura.3.1 Visual Studio CodePara ver y editar los ficheros te vale cualquier editor de código, pero yo uso y te recomiendo VSCode. Es un gran editor, gratuito y multiplataforma. Viene con un terminal integrado y puedes mejorarlo instalando extensiones desde una galería del propio editor.Te recomiendo instalar un paquete de extensiones ya configurado y preparado para el desarrollo de aplicaciones con Angular, se llama Angular Essentials. Con eso y el Material Icon Theme verás Angular en colores.3.2 Carpetas y Ficheros principalesVolviendo a la estructura de ficheros y carpetas te encontrarás con muchos archivos de distintos tipos. Si eres completamente nuevo en Angular, te llamará la atención las extensiones .ts. Son para ficheros TypeScript, una evolución del JavaScript con facilidades para el programador. Por ahora sólo tienes que familiarizarte con estos:angular.json : configuración del propio CLI. La madre de todos los configuradorespackage.json : dependencias de librerías y scriptssrc/ : la carpeta donde están los archivos fuentesindex.html : un fichero HTML índice estándarmain.ts : fichero TypeScript de arranque de la aplicaciónapp/ : la carpeta con el código específico de tu aplicaciónapp.module.ts : la aplicación es un árbol de módulos, y este es su raízapp.component.ts : la página es un árbol de componentes, y este es su raízapp.component.html : el componente tiene una parte visual, esta es su vistaEcha un vistazo a estos ficheros, pronto los modificaremos para sentirnos programadores.4. EdiciónAngular CLI instala y configura un conjunto de herramientas que te harán la vida más fácil. Entre otras, destaca la capacidad de recargar la aplicación en caliente en cuanto guardas tu trabajo como programador. En esta última versión, la 7, se ha mejorado el proceso y es realmente rápido.Para probarlo sólo tienes que dejar arrancada la aplicación con el comando npm start; cambiar un fichero de código y comprobar el resultado en el navegador. Te propongo empezar como en cualquier otro lenguaje; por el famoso hola mundo.4.1 Hola MundoAbre el fichero app.component.ts y busca dentro de él una clase llamada AppComponent. Encontrarás que tiene una propiedad title. Asígnale el saludo de rigor: title = &#39;actibot: hello world ;-)&#39;;. Guarda y comprueba cómo tu navegador se habrá actualizado automáticamente.Toda esta magia depende de una cadena de comandos que lanzan distintas herramientas previamente instaladas y configuradas por el CLI. Entre ellas cabe mencionar a WebPack, un coloso que afortunadamente viene instalado y preparado para funcionar de manera transparente.4.2 npm startEsta es una lista no exhaustiva de lo que sucede.npm startng servewebpack server en http://localhost:4270vigilancia de cambios sobre la carpeta src/live reloadcompilado de la aplicaciónrecarga del navegadorCambia a tu antojo el app.component.ts o su hermano app.component.html y comprueba los cambios de manera inmediata en tu navegador.5. ConfiguraciónEl CLI 7 viene con pilas incluidas, se puede usar desde el primer momento. Sólo quedan pequeñas mejoras que hacer. Por ejemplo ajustar el package.json y agregar librerías de terceros.5.1 Package.jsonEl package.json es el fichero estándar de npm donde se almacenan las dependencias de terceros. Contiene las librerías que necesita la aplicación para ejecutarse, por ejemplo todas las de Angular 7. Y también las herramientas que necesita el programador, por ejemplo el propio AngularCLI;12345678&#123; \"dependencies\": &#123; \"@angular/core\": \"^7.2.0\" &#125;, \"devDependencies\": &#123; \"@angular/cli\": \"7.2.0\" &#125;&#125;Otro uso del package.json es servir de contenedor de scripts para automatizar tareas de operaciones rutinarias. Por ejemplo, el comando estándar npm start ejecutará el contenido asignado en el fichero json, originalmente ng serve. Esto lanza el servidor de pruebas con sus opciones por defecto.Pero el comando ng serve admite muchas configuraciones. Te propongo que uses esta para activar un modo de compilación más rápido y seguro, y para que se abra el navegador de forma automática en cuanto lances el servidor. Y además te recomiendo que uses un puerto específico para cada aplicación.Otras configuraciones en producción123&#123; \"start\": \"ng serve --aot -o --port 4270\"&#125;5.2 Estilos y librerías de tercerosLas librerías que vienen de fábrica tienen todo lo necesario para crear aplicaciones. Pero raro es el caso en que no necesitemos algún que otro producto de terceros. Ya sean utilidades como date-fns, librerías gráficas como chart.js o la aplicación de estilos y componentes visuales de frameworks como Bootstrap o MaterialDesign. Pero todos se instalan de igual forma. Descargándolos con npm y adjuntándolos en el angular.json.En este tutorial te propongo usar una hoja de estilos muy simple que mejora la apariencia de cualquier aplicación sin necesidad de usar clases propias. Se llama MiniCSS y es apropiada para prototipos, pruebas o pequeños proyectos.Se descargan e instalan de manera estándar.1npm install mini.css --savePara que se incluyan en la distribución hay que ir a la configuración del CLI. Entonces se agrega dentro del fichero .angular.json a la colección de styles o de scripts que corresponda.123&#123; \"styles\": [\"src/styles.css\", \"./node_modules/mini.css/dist/mini-default.min.css\"]&#125;Estas colecciones de archivos los usa el cli a través de webpack para incluirlos minificados y concatenados en un fichero bundle sustituyendo a las clásicas etiquetas html.Todo, el html y sus estilos, se construirá en el cliente a partir de instrucciones JavaScript. De esta forma el fichero index.html apenas tendrás que tocarlo, salvo para algunas etiquetas de meta información.123&lt;meta name=\"description\" content=\"A sample project for learning Angular ;-)\" /&gt;&lt;meta name=\"keywords\" content=\"Angular Sample Tutorial Ejemplo\" /&gt;&lt;meta name=\"author\" content=\"Alberto Basalo\" /&gt;Una cosa más, los cambios en los ficheros de configuración no se auto recargan. Tienes que parar la servidor y volver a lanzarlo para apreciar el estilo MiniCSS.5.3 EnvironmentsLa carpeta environments/ contiene dos ficheros, y puede contener más, para cada entorno de distribución necesario. En código siempre importaremos el fichero base, pero durante la compilación el CLI lo sustituirá por el adecuado.1title = environment.appName + 'hello world ;-)';5.4 AssetsLos ficheros de la carpeta assets/ se copian tal cual al despliegue. Es un buen lugar para logos, imágenes y ficheros de datos estáticos.Por ejemplo, en el app.component.html he sustituido la imagen incrustada del Angular con un logo propio.1&lt;img width=\"100\" src=\"./assets/logo.png\" /&gt;6. Angular 7, el CLI 7 y su ecosistemaAlgunos consejos y herramientas útiles que rodean al mundo Angular.Pero si la línea de comandos te suena muy antigua y lo tuyo son las interfaces gráficas, estás de suerte. El reciente proyecto Angular Console te permite generar y ejecutar comandos desde una cómoda interfaz gráfica.Una mejora digna de mención es la capacidad de presupuestar tamaños de los ficheros generados. De esa forma podemos controlar el peso y tiempo de descarga de la aplicación.Para garantizar la limpieza del código conviene usar herramientas como Prettier y configurarlas para su compatibilidad con Angular.Los últimos toques antes de publicar pueden incluir el script de analytics en el index.html y ajustes de retro-compatibilidad en el fichero polyfills.ts. Luego un comando y listo para publicar en github pages.Te recomiendo que te familiarices y uses mucho estos scripts en el package.json para poder lanzarlos más tarde.123456789101112131415&#123; \"scripts\": &#123; \"build:prod\": \"ng build --prod\", \"build:pub\": \"ng build --prod --output-path docs --base-href https://academiabinaria.github.io/angular-basic/\", \"e2e\": \"ng e2e\", \"http-server\": \"http-server ./dist/angular-basic/ -c-1 -p4271 -a localhost -o\", \"lint\": \"ng lint\", \"ng\": \"ng\", \"pub\": \"npm run build:pub &amp;&amp; npm run push\", \"push\": \"git add * &amp;&amp; git commit -m 'pub' &amp;&amp; git push\", \"start:prod\": \"npm run build:prod &amp;&amp; npm run http-server\", \"start\": \"ng serve --aot -o --port 4270\", \"test\": \"ng test\" &#125;&#125;Comprueba las ejecuciones de los distintos scripts. Con npm start no se generan ficheros físicos. Todos es en memoria para mayor velocidad de re-compilación mientras desarrollas. En cambio npm run build:prod creará una carpeta ./dist/angular-basic en la que dejará los archivos necesarios para ejecución. Por último npm run pub los prepara para enviar compilados a la carpeta estándar ./docs listos para publicarse en las github pages.Otros enlaces de interés sobre el ecosistema Angular.Extensiones EsencialesPrettierAngular ConsoleAngular MaterialBootstrapAuguryApollo GraphQLIonicAngular ConsolePara complementar tu conocimiento te recomiendo la documentación de Angular/CLI y este artículo avanzado que trata la configuración del CLI en profundidad Angular CLI under the hood Esto es sólo el principio, Angular CLI 8 puede hacer mucho más por ti; descúbrelo en esta serie tutorial para aprender a programar con Angular 8. En el próximo artículo crearemos una Base para una aplicación Angular. Todos esos detalles se tratan en el curso básico online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"CLI","slug":"CLI","permalink":"https://academia-binaria.com/tag/CLI/"}]},{"title":"Redux, flujo reactivo unidireccional con Angular y RxJs","slug":"flujo-reactivo-unidireccional-con-Angular-y-RxJs","date":"2019-09-17T10:47:58.000Z","updated":"2019-10-09T10:45:38.702Z","comments":true,"path":"flujo-reactivo-unidireccional-con-Angular-y-RxJs/","link":"","permalink":"https://academia-binaria.com/flujo-reactivo-unidireccional-con-Angular-y-RxJs/","excerpt":"Continuando con el tutorial de Angular Avanzado nos centramos ahora en una arquitectura de comunicación de datos conocida como Unidirectional Data Flow o flujo de datos en un mismo sentido; la base del patrón Redux. Esta técnica es una mejora sobre el modelo básico de Angular, el double-binding, el cual facilitaba mucho el desarrollo en pequeños proyectos.Cuando hablamos de mejora debemos ser honestos con los costes y beneficios: aquí vamos a mejorar la eficiencia en ejecución y a facilitar la depuración a costa de una mayor complejidad estructural y sintáctica. Merece la pena cuanto más grande sea el proyecto. Este es un ejemplo simplificado pero realista que implementa Redux. Tómate tu tiempo para estudiarlo con calma.Tomar las decisiones correctas en cuestiones de este calibre puede suponer la diferencia entre el éxito o fracaso de un proyecto. Voy a explicarte las razones para usar este patrón y la manera más sencilla de introducirlo en tus aplicaciones, dejándote en el umbral de soluciones aún más potentes como la gestión de estado centralizada con Redux.","text":"Continuando con el tutorial de Angular Avanzado nos centramos ahora en una arquitectura de comunicación de datos conocida como Unidirectional Data Flow o flujo de datos en un mismo sentido; la base del patrón Redux. Esta técnica es una mejora sobre el modelo básico de Angular, el double-binding, el cual facilitaba mucho el desarrollo en pequeños proyectos.Cuando hablamos de mejora debemos ser honestos con los costes y beneficios: aquí vamos a mejorar la eficiencia en ejecución y a facilitar la depuración a costa de una mayor complejidad estructural y sintáctica. Merece la pena cuanto más grande sea el proyecto. Este es un ejemplo simplificado pero realista que implementa Redux. Tómate tu tiempo para estudiarlo con calma.Tomar las decisiones correctas en cuestiones de este calibre puede suponer la diferencia entre el éxito o fracaso de un proyecto. Voy a explicarte las razones para usar este patrón y la manera más sencilla de introducirlo en tus aplicaciones, dejándote en el umbral de soluciones aún más potentes como la gestión de estado centralizada con Redux.Partiendo de la aplicación tal como quedó en Componentes dinámicos, directivas y pipes con Angular. Al finalizar dotaremos a la aplicación de un almacén de datos Redux que notifica cambios reactivos.Código asociado a este tutorial en GitHub: AcademiaBinaria/angular-bossTabla de Contenido:1. Arquitectura del patrón Redux.2. Implementación de un Store con RxJs.Resumen1. Arquitectura del patrón Redux1234567Como: desarrollador, Quiero: saber qué acciones se pueden hacer para que: pueda controlar la funcionalidadComo: desarrollador, Quiero: saber qué cambios se han realizado para que: pueda depurar y predecir el comportamientoHablar de Unidirectional Data Flow sin presentar Redux es poco menos que imposible. Vamos a ver en qué consiste este patrón tan usado, no sólo en Angular. Lo que aprendas te servirá también para react, vue y otros.Redux se ocupa de la gestión del estado, es decir, del valor de las variables en un determinado momento. Centraliza sus cambios para saber qué ocurrió para llegar a este valor, y qué valor tendrá según lo que ocurra. Desacopla los emisores de acciones de los receptores de información, para ello combina otros dos patrones:Action: Envío de comandos al almacén para actualizar el estadoObservable: Subscripción a cambios en el estado del almacén.Como incorpora cierta complejidad de serie conviene que nos hagamos esta pregunta ¿Cuándo usarlo?. Una pequeña lista de ideas sobre cuándo implementar Redux.Aplicaciones complejas con múltiples componentes.El patrón contenedor / presentadores se hace complejo y tedioso a partir de tres niveles de profundidad del árbol.Los router-outlets inician una jerarquía propia. Comunicar componentes entre árboles no es factible con @Input y @OutputUso de estrategias de detección del cambio OnPush.Consumo de datos mediante pipes async suscritos a observables.Cambios concurrentes por el usuario y los servicios.Peticiones mediante pull a intervalos regularesRecepción de socketsLlamadas en paraleloGestión de datos local con cachésRedux no hace rápido lo simple, sino mantenible lo complejo.1.1 Principios de ReduxTenemos tres principios básicos que cumplir:Single Source Of Truth: Cada pieza de información se almacena en un único lugar, independientemente de dónde sea creada, modificada o requerida.Read Only State: La información será de sólo lectura y sólo podrá modificarse a través de conductos oficiales.Changes By Pure Functions: Los cambios tienen que poder ser replicados, cancelados y auditados; lo mejor, usar una función pura.1.2 Elementos de ReduxLos artificios fundamentales que incorporaremos a nuestro desarrollo van en dos niveles. El primer nivel resuelve los dos primeros principios.Store: El sistema que mantiene el estado. Despacha acciones de mutado sobre el mismo y comunica cambios enviando copias de sólo lectura a los subscriptores.State: Objeto que contiene la única copia válida de la información. Representa el valor del almacén en un momento determinado. Nunca expondremos un puntero a este dato privado.Acceso al estadoSetters : Métodos que asignan y notifican un nuevo cambio. Clonan la información recibida para que el llamante no tenga un puntero al estado.Selectors : Métodos para consulta del estado. Devuelven un observable al que suscribirse para obtener notificaciones de cambio o una instantánea. En cualquier caso siempre emitirá o devolverá un clon del estado.Mutaciones del estadoActions: Objetos identificados por un tipo y cargados con un payload. Transmiten una intención de mutación sobre el estado del store.Reducers : Son funciones puras, que ostentan la exclusividad de poder mutar el estado. Reciben dos argumentos: el estado actual y una acción con su tipo y su carga. Clonan el estado, realizan los cambios oportunos y devuelven el estado mutado.Podemos verlo en un diagrama antes de pasar a verlo en código.2. Implementación de un Store con RxJs123As a: seller, I want: to know how many products are out of stock so that: I can refill themPara que veas que Redux es independiente de Angular, vamos a montarlo en una librería sin dependencias del framework. Sólo TypeScript y RxJs. A día de hoy ambas tecnologías son transversales al ecosistema frontend.1ng g @nrwl/workspace:library rx-store2.1 El Store observable mínimoEmpezaremos por la implementación más inocente de un almacén reactivo. Una clase con tipos genéricos que hace uso de la librería de observables RxJs. De esta, toma el BehaviorSubject que permite notificar cambios y valores iniciales.Aunque para evitar que otra clase consumidora también emita sin control, sólo exponemos su interfaz asObservable(). Relacionado con esto también es obligatorio evitar a toda costa punteros al estado. Para ell siempre trabajamos con clones. Los métodos get() set() usan el spread operator de JS { ...this.state } tanto al recibir como al devolver el valor del estado.libs\\rx-store\\src\\lib\\mini-store.ts1234567891011121314151617181920import &#123; BehaviorSubject, Observable &#125; from 'rxjs';export class MiniStore&lt;T&gt; &#123; private state: T; private subject$ = new BehaviorSubject(this.get()); constructor(initialState: T) &#123; this.set(initialState); &#125; public set(newSate: T) &#123; this.state = &#123; ...newSate &#125;; this.subject$.next(this.get()); &#125; public select$(): Observable&lt;T&gt; &#123; return this.subject$.asObservable(); &#125; private get(): T &#123; return &#123; ...this.state &#125;; &#125;&#125;Puedes ver su uso en los test unitarios que le acompañan en libs\\rx-store\\src\\lib\\rx-store.spec.ts.123456789101112131415161718192021222324import &#123; MiniStore &#125; from './mini-store';describe('GIVEN: a basic mini-store of product stocks', () =&gt; &#123; interface ProductStock &#123; stock: number; &#125; const initial: ProductStock = &#123; stock: 25 &#125;; describe('WHEN: I start one ', () =&gt; &#123; const stockMiniStore = new MiniStore&lt;ProductStock&gt;(initial); it('THEN: it should have the inital value', done =&gt; &#123; stockMiniStore.select$().subscribe(res =&gt; &#123; expect(res).toEqual(initial); done(); &#125;); &#125;); &#125;); describe('WHEN: I start and set a new value ', () =&gt; &#123; const stockMiniStore = new MiniStore&lt;ProductStock&gt;(initial); stockMiniStore.set(&#123; stock: 40 &#125;); it('THEN: it should emit the same value', done =&gt; &#123; stockMiniStore.select$().subscribe(res =&gt; &#123; expect(res).toEqual(&#123; stock: 40 &#125;); done(); &#125;); &#125;); &#125;);&#125;);2.2 El envío de accionesEn una situación más realista y aproximada al patrón Redux no deberíamos asignar el valor de manera directa, pues hay que dejar rastro de cómo se llegó ahí. Necesitamos entonces los conceptos de acciones y función reductora. La idea es que el almacén reciba acciones, invoque al reductor y asigne el valor obtenido. Vamos a verlo.Empezamos por crear otra clase similar libs\\rx-store\\src\\lib\\rx-store.ts y un par de ayudas. Como mínimo el interface que debe cumplir toda Action; es muy sencillo y siempre igual: una cadena para especificar el comando y cualquier cosa como argumento de carga. Aprovechando las potencia del TypeScript también creamos un type para asegurar que la reducerFunction tiene la firma adecuada. La obligamos a recibir como argumentos el estado actual y la acción que se le aplica; teniendo que devolver el nuevo estado.123456789101112131415161718192021222324252627282930313233import &#123; BehaviorSubject, Observable &#125; from 'rxjs';export interface Action &#123; type: string; payload: any;&#125;export type reducerFunction&lt;T&gt; = (state: T, action: Action) =&gt; T;export class RxStore&lt;T&gt; &#123; private state: T; private subject$ = new BehaviorSubject&lt;T&gt;(this.get()); constructor(initialState: T, private reducer: reducerFunction&lt;T&gt;) &#123; this.set(initialState); &#125; public select$(): Observable&lt;T&gt; &#123; return this.subject$.asObservable(); &#125; public dispatch(action: Action) &#123; const curretState = this.get(); const newState = this.reducer(curretState, action); // instrumentation, cache, log... this.set(newState); &#125; private get(): T &#123; return &#123; ...this.state &#125;; &#125; private set(newSate: T) &#123; this.state = &#123; ...newSate &#125;; this.subject$.next(this.get()); &#125;&#125;Como puedes ver, los get() y set() son ahora privados. El mundo exterior nos envía acciones al método public dispatch(action: Action). Ese sería un buen momento para incluir lógica de infraestructura e instrumentación. Hay quien crea un log de lo ocurrido, un histórico de valores… las librerías profesionales nos dan todo eso y mas. Una vez recibida la acción empieza la fiesta de los clones invocando en medio a una función reductora que ahora veremos.2.3 La función reductora de estadoEn el fichero de test libs\\rx-store\\src\\lib\\rx-store.spec.ts tenemos un ejemplo clarificador :1234567891011121314151617const stockReducer: reducerFunction&lt;ProductStock&gt; = function( state: ProductStock, action: Action ): ProductStock &#123; const clonedState = &#123; ...state &#125;; switch (action.type) &#123; case 'set': clonedState.stock = action.payload; break; case 'increment': clonedState.stock += action.payload; break; default: break; &#125; return clonedState; &#125;;Definimos stockReducer como una función pura que cumple con el tipo reducerFunction. Normalmente estas funciones tienen un switch que evalúa el tipo de la acción. En cada caso se asigna un nuevo estado según la mínima lógica oportuna y al finalizar se devuelve el estado mutado.Veamos el resto del test para tener una idea de cómo se utiliza.1234567891011describe('WHEN: I get an increment ', () =&gt; &#123; const stockRxStore = new RxStore&lt;ProductStock&gt;(initial, stockReducer); const incrementAction: Action = &#123; type: 'increment', payload: 5 &#125;; stockRxStore.dispatch(incrementAction); it('THEN: it should raise the stock', done =&gt; &#123; stockRxStore.select$().subscribe(res =&gt; &#123; expect(res).toEqual(&#123; stock: 30 &#125;); done(); &#125;); &#125;);&#125;);De esta forma ya tenemos un sistema sencillo pero del que podríamos decir que cumple con los principios básicos de Redux.ResumenLas aplicaciones reales no son sencillas. Este es un tutorial avanzado que te exige conocimiento previo y dedicación. A cambio espero que te resulte útil y que podáis incorporar las técnicas de detección del cambio y control de estado observable en vuestros proyectos.Con este tutorial continúas tu formación avanzada en Angular; para poder afrontar retos de tamaño industrial usando te recomiendo que uses El patrón Redux con NgRx en Angular. Todos esos detalles se tratan en el curso avanzado online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Observables","slug":"Observables","permalink":"https://academia-binaria.com/tag/Observables/"},{"name":"Redux","slug":"Redux","permalink":"https://academia-binaria.com/tag/Redux/"},{"name":"RxJs","slug":"RxJs","permalink":"https://academia-binaria.com/tag/RxJs/"}]},{"title":"Componentes dinámicos, directivas y pipes con Angular","slug":"componentes-dinamicos-directivas-y-pipes-con-Angular","date":"2019-09-13T12:27:09.000Z","updated":"2019-10-09T10:45:38.700Z","comments":true,"path":"componentes-dinamicos-directivas-y-pipes-con-Angular/","link":"","permalink":"https://academia-binaria.com/componentes-dinamicos-directivas-y-pipes-con-Angular/","excerpt":"El sistema de componentes de Angular te permite reutilizar pequeñas unidades para montar grandes y complejas interfaces. Eso es bueno porque la capa de presentación se come la mayor parte del tiempo de desarrollo. Pero podemos ir más allá.Podemos crear componentes con estructura fija y contenido dinámico. Podemos dar funcionalidad extra mediante directivas y podemos crear pipes para transformar la presentación.Y todo esto de una forma sencilla y familiar usando el CLI. No hay excusa para no reutilizar código en la capa de presentación. Don’t repeat Yourself!.","text":"El sistema de componentes de Angular te permite reutilizar pequeñas unidades para montar grandes y complejas interfaces. Eso es bueno porque la capa de presentación se come la mayor parte del tiempo de desarrollo. Pero podemos ir más allá.Podemos crear componentes con estructura fija y contenido dinámico. Podemos dar funcionalidad extra mediante directivas y podemos crear pipes para transformar la presentación.Y todo esto de una forma sencilla y familiar usando el CLI. No hay excusa para no reutilizar código en la capa de presentación. Don’t repeat Yourself!.Partiendo de la aplicación tal como quedó en Detección del cambio en Angular. Al finalizar tendrás una aplicación que muestra información sobre productos de manera flexible y al gusto del programador.Código asociado a este tutorial en GitHub: AcademiaBinaria/angular-bossTabla de Contenido:1. Plantillas de contenido dinámico.2. Atributos custom con Directivas.3. Funciones de transformación con Pipes.1 Plantillas de contenido dinámico1234567As a: customer, I want: to see a product card with price in euros so that: i can decide to purchase it or notAs a: seller, I want: to see a product card with stock so that: I can ask for more or notEn muchas ocasiones tenemos que presentar la misma información pero con ligeros cambios. Por ejemplo una vista a veces con unos botones a veces con un texto.En otras ocasiones mostramos información muy diferente pero con la misma estructura. Por ejemplo páginas de búsqueda; pueden ser de productos, clientes, tareas… pero siempre con la parte de filtro y la del listado.Algunas veces se puede resolver con un *ngIf. Pero hay ocasiones que donde la técnica del ng-content te puede ser mucho más útil. Como ejemplo voy a crear un componente base para mostrar una ficha de producto. Después usaré esa plantilla para rellenarla según las especificaciones de cada pantalla.1.1 Un componente común1ng g c product-template --project=products --module=products.module.ts --exportLa visión del comprador y del vendedor es parecida. Mantenemos estructura, inyectamos contenido.12345678910111213&lt;article style=\"margin: 5px; padding: 5px; border: 2px; border-style: solid;\"&gt; &lt;header&gt; &lt;h2&gt; &#123;&#123; product.description &#125;&#125; &lt;/h2&gt; &lt;/header&gt; &lt;main&gt; &lt;ng-content select=\"main\"&gt;&lt;/ng-content&gt; &lt;/main&gt; &lt;footer style=\"margin-top: 5px\"&gt; &lt;ng-content select=\".actions\"&gt;&lt;/ng-content&gt; &lt;/footer&gt;&lt;/article&gt;La directiva ngContent permite crear slots para incrustar contenido a voluntad del consumidor. Cada slot se identifica mediante un select=&quot;css-selector&quot;.Los selectores pueden referirse a elementos html, clases css o identificadores. En la práctica es como dejar unos sitios en los que inyectar contenido. Y para referirse a esos sitios les damos un nombre selector.1.2 Implementaciones distintasA partir de aquí podría haber múltiples componentes que usasen la misma plantilla. Voy a mostrar uno de ejemplo.1ng g c catalog/product --project=shopLa etiqueta &lt;main&gt; y el atributo class=&quot;actions&quot; son usados para seleccionar los slots en los que serán inyectados. Por lo demás el componente ab-products-product-template se comporta como cualquier otro pudiendo recibir argumentos…apps\\shop\\src\\app\\catalog\\catalog.component.html1234567891011121314&lt;ab-products-product-template [product]=\"product\"&gt; &lt;main&gt; &lt;div&gt; &#123;&#123; product.brand &#125;&#125; - &#123;&#123; product.category &#125;&#125; &lt;/div&gt; &lt;div&gt; Price: &#123;&#123; product.price &#125;&#125; &lt;/div&gt; &lt;/main&gt; &lt;nav class=\"actions\"&gt; &lt;button (clic)=\"buy.next()\" style=\"background-color:coral; padding: 5px\"&gt;&lt;strong&gt;Buy me!&lt;/strong&gt;&lt;/button&gt; &lt;/nav&gt;&lt;/ab-products-product-template&gt;La idea es que bajo una misma estructura puedas crear distintas implementaciones y así mantener una coherencia visual o simplemente no repetir código.2 Atributos custom con Directivas1234567As a: seller, I want: to see a green mark on products with stock so that: I know I don't do need to refillAs a: seller, I want: to see a red mark on products with out stock so that: I know I need to refill2.1 Generación de directivasPrimero la definición. Si los componentes nos permite crear nuevas etiquetas en html, las directivas nos permiten crear atributos. Se usan para dar funcionalidad extra a los elementos estándar o no de las aplicaciones.La forma de crearlas es mediante el CLI. En este caso con el comando directive.1ng g directive out-of-stock --project=products --exportEL resultado es una clase con su propio decorador @Directive en el que asignamos su selector. Es decir el nombre del atributo que podremos usar. El convenio es utilizar el prefijo y el propio nombre de directiva en camel case.1234567891011121314@Directive(&#123; selector: '[abProductsOutOfStock]'&#125;)export class OutOfStockDirective &#123; private minimalStock = 10; @Input() set abProductsOutOfStock(stock: number) &#123; const color = stock &lt;= this.minimalStock ? 'MistyRose' : 'Aquamarine'; this.el.nativeElement.style.backgroundColor = color; &#125; constructor(private el: ElementRef) &#123;&#125;&#125;En la implementación ya puedes hacer lo que te parezca. Es muy habitual que las directivas se usen para manipular el elemento nativo al que se aplican. Por eso casi siempre solicitarás la inyección de un puntero a dicho elemento: el de la dependencia de tipo ElementRef que viene en el core de Angular.A partir de ahí ya puedes hacer lo necesario manipulando el html tanto en el constructor como en respuesta a cambios o durante la entrada de atributos.2.2 Consumo de directivasUsarlas es todavía más sencillo. Una vez exportadas e importadas como cualquier otro artificio Angular, ya puedes asignarlas como atributo a las etiquetas de tus plantillas.apps\\shop\\src\\app\\catalog\\product\\product.component.html123&lt;div [abProductsOutOfStock]=\"product.stock\"&gt; Stock: &#123;&#123; product.stock &#125;&#125;&lt;/div&gt;Algunas, como este caso, reciben valores. Otras simplemente actúan una vez asignadas. De nuevo la idea es que todas las manipulaciones de bajo nivel se escondan en las directivas y que los controladores de nuestros componentes queden limpios y desacoplados de la capa de presentación.3 Funciones de transformación con Pipes123456As a: customer, I want: to see a product price also in dollars so that: I can compare pricesAs a: customer, I want: to see a product price also in pounds so that: I can compare pricesEn este caso lo que queremos es transformar un dato de nuestro modelo antes de presentarlo en pantalla. Para ello seguro que has usado algún pipe de Angular desde el primer día que empezaste a programar.3.1 Generación de pipesPero ahora vamos a generar nuestros propios pipes. Una vez más usaremos el CLI con su comando específico para este caso:1ng g pipe exRate --project=products --exportAl igual que los componentes y que las directivas, los pipes tienen un nombre como clase y un nombre en su decorador para ser usados desde fuera.1234567891011121314151617@Pipe(&#123; name: 'exRate'&#125;)export class ExRatePipe implements PipeTransform &#123; private readonly euroDollars = 1.13; private readonly ratesApi = 'https://api.exchangeratesapi.io/latest?symbols='; constructor(private httpClient: HttpClient) &#123;&#125; public transform(euros: number, symbol: string): number | Observable&lt;number&gt; &#123; if (!symbol) &#123; return euros * this.euroDollars; &#125; else &#123; return this.getOnlineRates$(symbol).pipe(map(rate =&gt; euros * rate)); &#125; &#125;&#125;La clase tienen que implementar la interfaz PipeTransform que obliga a tener un método público transform(value: any):any. En este método definimos nuestra función de transformación.La única salvedad es incidir en que sea lo más ligera posible pues se ejecuta en cada uso y repintado. Por ejemplo yo aquí necesito un servicio asíncrono, y para no penalizar demasiado el rendimiento, le aplico el operador shareReplay para que actúe como una caché.12345678private getOnlineRates$(symbol: string) &#123; const ratesUrl = this.ratesApi + symbol; return this.httpClient.get&lt;any&gt;(ratesUrl).pipe( shareReplay(1), refCount(), map(resp =&gt; resp.rates[symbol]) );&#125;3.2 Consumo de pipesLa parte del consumo es la más simple. Se trata de invocar a la transformación pasándole los atributos necesarios y volver a transformar o utilizar directamente el resultado.apps\\shop\\src\\app\\catalog\\product\\product.component.html1234&lt;div&gt; $&#123;&#123; product.price | exRate | number:'1.0-0'&#125;&#125; &#123;&#123; product.price | exRate:'GBP' | async | number:'1.0-0'&#125;&#125; £&lt;/div&gt;Y con esto ya tenemos tres nuevas maneras de reutilizar código y dar nuevas capacidades a la parte de presentación. Pero en este tutorial de formación avanzada en Angular volvemos de nuevo a las profundidades del modelo y la gestión de datos empezando con el Flujo reactivo unidireccional con Angular y RxJs. Todos esos detalles se tratan en el curso avanzado online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Template","slug":"Template","permalink":"https://academia-binaria.com/tag/Template/"}]},{"title":"Detección del cambio en Angular","slug":"deteccion-del-cambio-en-Angular","date":"2019-09-11T16:09:27.000Z","updated":"2019-10-09T10:45:38.699Z","comments":true,"path":"deteccion-del-cambio-en-Angular/","link":"","permalink":"https://academia-binaria.com/deteccion-del-cambio-en-Angular/","excerpt":"La forma en que Angular realiza su renderizado y actualiza sus vistas es un factor clave para el rendimiento de las aplicaciones. ¿Cómo funciona la estrategia de detección de cambios de Angular? Pues tiene dos modos: default o automágico y onPush o mindfulness.Es importante tomar consciencia sobre el proceso y las implicaciones. Es costoso realizar la detección más veces de lo necesario y no hacerlo suficientemente implica no ver resultados reales.Afortunadamente el cambio del modo automático al manual no tiene por qué ser traumático. Con un mayor conocimiento del changeDetectionStrategy y un poco de trabajo extra tendrás aplicaciones más eficientes y mantenibles.","text":"La forma en que Angular realiza su renderizado y actualiza sus vistas es un factor clave para el rendimiento de las aplicaciones. ¿Cómo funciona la estrategia de detección de cambios de Angular? Pues tiene dos modos: default o automágico y onPush o mindfulness.Es importante tomar consciencia sobre el proceso y las implicaciones. Es costoso realizar la detección más veces de lo necesario y no hacerlo suficientemente implica no ver resultados reales.Afortunadamente el cambio del modo automático al manual no tiene por qué ser traumático. Con un mayor conocimiento del changeDetectionStrategy y un poco de trabajo extra tendrás aplicaciones más eficientes y mantenibles.Partiendo de la aplicación tal como quedó en Tests unitarios con Jest y e2e con Cypress en Angular. Al finalizar tendrás una aplicación que actualiza la vista sólo cuando es necesario, es decir: cuando los datos han cambiado.Código asociado a este tutorial en GitHub: AcademiaBinaria/angular-bossTabla de Contenido:1. Comunicación de datos entre componentes.2. Change detection strategies3. InmutabilidadDiagramasResumen1 Comunicación de datos entre componentes123456789101112131415As a: customer, I want: to see a shopping cart page so that: i can browse the list of products in my basketAs a: customer, I want: to pick a product so that: I can add units to my basketAs a: customer, I want: to remove a product from my basket so that: I can take less unitsAs a: customer, I want: to see always counters of my basket so that: I can know what I'm buyingSigue la pista al código de ejemplo creado a partir de estos comandos:1ng g m cart --project=shop --module=app.module.ts --routing --route=cartapps\\shop\\src\\app\\app.component.html123&lt;nav&gt; &lt;a [routerLink]=\"['/cart']\"&gt;Basket&lt;/a&gt;&lt;/nav&gt;123ng g c cart/item-picker --project=shopng g c cart/basket-list --project=shopng g s basket --project=shopLa detección de cambios se dispara ante eventos que le ocurren a los componentes. La detección se realiza componente a componente, así que compensa tener muchos componentes pequeños, para que cada uno por si sólo no genere demasiado ruido.1.1 Componentes Contenedores y PresentadoresAl pasar de un único componente a varios mini-componentes, se propone usar el patrón contenedor / presentadores. Se mantiene un componente padre que contiene múltiples componentes presentadores hijos. El contendor es el único con acceso a los servicios de negocio y datos. Los presentadores reciben los datos y emiten eventos. Los presentadores no obtienen ni modifican datos por su cuenta.NomenclaturaContainer: aka Parent, Smart. AppComponent y CartComponentPresenter: aka Child, Dumb. ItemPickerComponent y BasketListComponentEste reparto de responsabilidades es aconsejable independientemente de la estrategia de detección aplicada. Tienes más información el artículo de introducción flujo de datos entre componentes.2 Change detection strategiesCon la aplicación bien estructurada en componentes y con la comunicación estandarizada, habremos reducido el impacto de la detección del cambio y estaremos preparados para optimizarlo. Conozcamos en detalle las estrategias de detección del cambio.El decorador @Component() admite en su configuración la poco conocida propiedad changeDetection. Dicha propiedad puede asignarse manualmente al componente, o indicarle su uso al generador del cli.2.1 Detección automática, defaultPor defecto, Angular tiene que ser conservador y verificar cada posible cambio, esto se denomina comprobación sucia o dirty checking. Se dispara con demasiada frecuencia, al menos en los siguientes casos:Eventos desde el browserTimers, intervals etc..Llamadas httpPromesas y código asíncrono.Por si fuera poco, además de dispararse mucho es muy costoso. Determinar que algo ha cambiado implica comparar dos estados: el actual y el anterior.La comparación es valor a valor, en profundidad, para cada propiedad de cada objeto, para cada objeto de cada array.Con todo, esta estrategia es cómoda para el programador y suficiente para casos básicos. Pero demasiada magia dificulta el control en aplicaciones complejas. Y en pantallas de mucha información e interacción degrada el rendimiento percibido.2.2 Detección manual, onPushComo se puede prever, la detección del cambio manual es lanzada por el programador. No siempre va a ser laborioso, pero será más consciente pues para que ocurra han de darse alguna de estas circunstancias:Explícitamente el programador solicita la detección llamando a `ChangeDetectorRef.detectChanges();Implícitamente al usar el pipe Async en la vista se llama a ese mismo método.Conscientemente el desarrollador obliga a un componente a repintarse si le cambia la referencia a un @Input().En este modo los componentes dejan de evaluar y comparar sus propiedades rutinariamente. Sólo atienden a eventos @Output() o cambios de referencia @Input(). Esto relaja mucho al motor de Angular, que ya no tiene que hacer comparaciones odiosas. Sabrá que algo ha cambiado porque… es otro objeto.3 InmutabilidadComo ya se ha dicho, para que Angular en la estrategia automática decida que algo ha cambiado necesita hacer una comparación por valor. Para evitar ese coste usamos la estrategia manual y el programador tiene que cambiar la referencia de algo cuando quiera que Angular repinte la vista.3.1 Por referencia y por valorNormalmente tendrá que crear un nuevo objeto y reasignarlo en lugar del anterior en un ciclo de clonación, mutación y asignación. Por costoso que parezca siempre compensa si evita muchas e innecesarias comparaciones por valor en estructuras profundas.La estrategia onPush trata a todos los Inputs en inmutables, es decir, algo que no espera que cambie. Similar al paso de parámetros por valor, que si cambia es porque es otro puntero.3.2 El clonadoEl potencialmente pesado trabajo de clonado lo podemos evitar en muchos casos usando alguna de estas técnicas:Tipos primitivos que se pasan por valor en las propiedades @Input()Arrays: muchos métodos como .filter() .slice() .sort() .concat() etc., devuelven nuevas referencias sin modificar el array original.Observables y el pipe Async, pues en este caso se subscribe y lanza implícitamente la detección del cambio. No hay necesidad de clonar todo lo que llega por http.Para los demás casos tenemos operadores TypeScript sencillos y optimizados para obtener nuevas referencias a partir de otros ya existentes.1234567891011121314// js cloning techniquesconst original = &#123; name:'first', value:1 &#125;;const cloned = &#123; ...original &#125;;// &gt; &#123; name:'first', value:1 &#125;const mutated = &#123; ...original, value:2, newProperty: 'added' &#125;;// &gt; &#123; name:'first', value:2, newProperty: 'added' &#125;const list = [ original, cloned, mutated ];// &gt; [ &#123; name:'first', value:1 &#125;, &#123; name:'first', value:1 &#125;, &#123; name:'first', value:2, newProperty: 'added' &#125; ]const clonedList = [ ...list ];// &gt; [ &#123; name:'first', value:1 &#125;, &#123; name:'first', value:1 &#125;, &#123; name:'first', value:2, newProperty: 'added' &#125; ]const mutatedList = [ ...list, &#123; name: 'new item'&#125; ];// &gt; [ &#123; name:'first', value:1 &#125;, &#123; name:'first', value:1 &#125;, &#123; name:'first', value:2, newProperty: 'added' &#125;, &#123; name: 'new item'&#125; ]const newList = list.filter(i =&gt; i.name=='first');// &gt; [ &#123; name:'first', value:1 &#125;, &#123; name:'first', value:1 &#125;, &#123; name:'first', value:2, newProperty: 'added' &#125; ]Ya tienes los conocimientos para acelerar y reducir la incertidumbre sobre el actualización de vistas usando el patrón contenedor / presentador junto con la estrategia de detección de cambios OnPush. Ahora vamos a ver un ejemplo.3.3 Todo reactivo.123Como: desarrollador quiero: que las comunicaciones sean fluidas e independientes del tiempo para que: los cambios en los datos cambien la presentación sin esfuerzoOtro de los pilares de la programación moderna de grandes aplicaciones es la reactividad (nada que ver con Chernóbil). Se trata de que los cambios se comuniquen cuando ocurran, sin necesidad de preguntar por ellos. De esta forma los componentes reaccionarán al cambio en lugar de buscarlo proactivamente mejorando mucho el rendimiento de las aplicaciones.Reducida a lo esencial, la lógica más básica que quiero comunicar es un contador de elementos y la propia cesta. Un mísero número y un array. Pero claro, hacerlo reactivo requiere usar observables, y para eso emplearemos la librería RxJs.DiagramasEl siguiente diagrama nos muestra a vista de pájaro los procesos que sique Angular para la detección del cambio y sus dos estrategias.ResumenOnPush es más ligeroSe lanza menos vecesSólo comprueba referencias, no valoresAsync, CDR y clone detectan los cambiosAsync: para que las respuestas desde observables sean limpiasCDR: cuando el cambio venga de procesos asíncronos pero no observablesClonado: para que se detecten cambios simplemente usando las referenciasLa detección automática es cómoda pero costosa. Por dos razones: se dispara muchas veces y necesita comprobar si hay cambios comparando valor por valor. La detección manual es más eficiente. Se lanza menos veces y además le basta un cambio de referencia para saber que hay novedades. Para poder usarla sin grandes trabajos recomiendo usar el pipe async, siempre con orígenes de datos observables. Para ello necesitamos usar y conocer patrones que hagan uso de la librería observable RxJsPero vale ya de infraestructura, pasemos a algo visual. En este tutorial de formación avanzada en Angular veremos ahora cómo crear componentes dinámicos, directivas y pipes con Angular. Todos esos detalles se tratan en el curso avanzado online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"ChangeDetection","slug":"ChangeDetection","permalink":"https://academia-binaria.com/tag/ChangeDetection/"},{"name":"Observables","slug":"Observables","permalink":"https://academia-binaria.com/tag/Observables/"}]},{"title":"Tests unitarios con Jest y e2e con Cypress en Angular","slug":"tests-unitarios-con-jest-y-e2e-con-cypress-en-Angular","date":"2019-09-05T12:25:12.000Z","updated":"2019-09-23T11:19:50.724Z","comments":true,"path":"tests-unitarios-con-jest-y-e2e-con-cypress-en-Angular/","link":"","permalink":"https://academia-binaria.com/tests-unitarios-con-jest-y-e2e-con-cypress-en-Angular/","excerpt":"Continuamos este tutorial de Angular Avanzado con el tema controvertido del testing. Sí, ya sé que todos deberíamos hacerlo siempre, pero también sé que no es cierto. Así que vamos a ponerle remedio eliminando excusas y facilitando las pruebas automatizadas.Por si hace falta su defensa: Las pruebas automáticas de código son la principal técnica de reducción de bugs y garantizan el buen funcionamiento durante un refactoring. Bueno para el usuario bueno para el programador.Los desarrollos que hoy en día hacemos con Angular suelen ser de tamaño medio o grande y con una esperanza de vida y mantenimiento que se mide en años. Así que cuantas más pruebas tengamos menos miedo tendremos a cambiar el código. Y la necesidad de cambio siempre estará ahí. Veremos como Jest y Cypress nos ayudan muchísimo en la tarea.","text":"Continuamos este tutorial de Angular Avanzado con el tema controvertido del testing. Sí, ya sé que todos deberíamos hacerlo siempre, pero también sé que no es cierto. Así que vamos a ponerle remedio eliminando excusas y facilitando las pruebas automatizadas.Por si hace falta su defensa: Las pruebas automáticas de código son la principal técnica de reducción de bugs y garantizan el buen funcionamiento durante un refactoring. Bueno para el usuario bueno para el programador.Los desarrollos que hoy en día hacemos con Angular suelen ser de tamaño medio o grande y con una esperanza de vida y mantenimiento que se mide en años. Así que cuantas más pruebas tengamos menos miedo tendremos a cambiar el código. Y la necesidad de cambio siempre estará ahí. Veremos como Jest y Cypress nos ayudan muchísimo en la tarea.Partiendo del mono repositorio creado usando las herramientas de Nrwl.io/ aprovecharemos las herramientas que instala y configura dos productos de última generación que facilitan la tarea. Usaremos Jest para los test unitarios y Cypress para los de integración End to End. Vamos a empezar por el final.Código asociado a este tutorial en GitHub: AcademiaBinaria/angular-bossTabla de Contenido:1. Test de Integración con Cypress.2. Test Unitarios con Jest.Resumen1. Test de Integración con Cypress123As a: developer, I want: to test end to end my app so that: I can be sure of the functionsLas pruebas de integración son las que tienen un retorno de inversión más inmediato. Si esta es tu primera aproximación al testing, te recomiendo empezar por aquí. Se trata de definir un escenario y pre programar el comportamiento del usuario. El sistema lo ejecutará y podrás contrastar el resultado con algún valor esperado.Son pruebas de caja negra que interactúan con el sistema en ejecución. Todo ello automatizado y con informes visuales interactivos o en ficheros de texto con el resultado de las pruebas.1.1 CypressCypress es el equivalente a Protractor, el producto propio de Angular. La ventaja principal es que no está atado a ningún framework y por tanto lo que hagas valdrá para probar cualquier web en cualquier tecnología.Con cada aplicación generada se crea una hermana para sus pruebas e2e. Esa aplicación de pruebas está configurada y lista para compilar, servir y probar su aplicación objetivo. Con Nx tenemos todo instalado, configurado y listo para ejecutarse con comandos como los siguientes que yo coloco en el packcage.json:1234&#123; \"e2e:shop\": \"ng e2e shop-e2e --watch\", \"e2e:warehouse\": \"ng e2e warehouse-e2e --watch\"&#125;Luego se pueden lanzar desde la terminal muy cómodamente.12yarn e2e:shopyarn e2e:warehouse1.2 Test e2e1234GIVEN: the shop web app WHEN: user visits home page THEN: should display welcome message THEN: should display welcome message from the APITu trabajo como tester será definir las pruebas en la carpeta /integration. Por ejemplo para empezar nos ofrecen el fichero app-spec.ts en el que yo he especificado el comportamiento deseado por mi página. La sintaxis se entiende por si misma. He seguido el convenio GIVEN, WHEN, THEN para especificar pruebas que podrían considerarse casi de comportamiento o aceptación.apps\\shop-e2e\\src\\integration\\app.spec.ts123456789101112131415import &#123; getGreeting &#125; from '../support/app.po';describe('GIVEN: the shop web app', () =&gt; &#123; beforeEach(() =&gt; cy.visit('/')); context('WHEN: user visits home page', () =&gt; &#123; it('THEN: should display welcome message', () =&gt; &#123; getGreeting().contains('Hello world'); &#125;); // needs the api server to run // yarn start:api it('THEN: should display welcome message from the API', () =&gt; &#123; getGreeting().contains('and Welcome to api!'); &#125;); &#125;);&#125;);La parte más técnica y tediosa es la que accede al DOM y lo mejor es tener eso a parte. En la carpeta /support nos sugieren que creemos utilidades para tratar con el DOM y de esa forma mantener los test lo más cercanos posible a un lenguaje natural de negocio. En este caso uso una aproximación libre al BDD con gherkin para mantener el espíritu de sencillez de un tutorial sobre tecnología Angular, no sobre testing.apps\\shop-e2e\\src\\support\\app.po.ts1export const getGreeting = () =&gt; cy.get('h1');2. Test Unitarios con JestLas pruebas unitarias, muy asociadas al TDD, son las mejores amigas del desarrollador. Pero, también son las más engorrosas para empezar. Así que aquí veremos una introducción sencilla para que nadie deje de hacerlas.2.1 JestJest es un framework de testing para JavaScript muy sencillo y rápido. Puedes usarlo con cualquier otro framework. Para el caso de Angular ya viene preconfigurado si usas las extensiones Nx.Mete los siguientes scripts en el package.json y así tendrás a mano siempre las pruebas. Te recomiendo que desarrolles con el test unitario lanzado; es la manera más rápida de probar el código que estés tocando. Idealmente incluso con el test antes del código.12345&#123; \"test:shop\": \"ng test shop --watch --verbose\", \"test:warehouse\": \"ng test warehouse --watch --verbose\", \"test:api\": \"ng test api --watch --verbose\"&#125;123yarn test:shopyarn test:warehouseyarn test:api2.2 Tests unitarios2.2.1 Componentes12345GIVEN: an AppComponent declared in AppModule WHEN: the AppModule is compiled THEN: should create the component THEN: should have a property title with value 'shop' THEN: should render 'Hello world' in a H1 tagEn este caso queremos probar una librería de componentes. Y empezamos por el componente raíz. Esta es una prueba unitarias pero con un toque de integración parcial pues necesita de otros componentes para ejecutarse. Cuanto más arriba en la jerarquía esté el componente mayor será su necesidad de integrar a otros. Pero no pasa nada, de esta forma te aseguras de que el módulo de la librería se importa y que sus componentes se exportan correctamente.Al grano, vamos a la aplicación shop para comprobar que su componente AppComponent funciona y (de paso) que se renderiza también el componente ab-ui-greetings incrustando los saludos.apps\\shop\\src\\app\\app.component.spec.ts12345678910111213141516171819202122232425262728293031323334import &#123; UiModule &#125; from '@a-boss/ui';import &#123; async, TestBed &#125; from '@angular/core/testing';import &#123; RouterTestingModule &#125; from '@angular/router/testing';import &#123; AppComponent &#125; from './app.component';describe('GIVEN: an AppComponent declared in AppModule', () =&gt; &#123; describe('WHEN: the AppModule is compiled', () =&gt; &#123; beforeEach(async(() =&gt; &#123; TestBed.configureTestingModule(&#123; imports: [RouterTestingModule, UiModule], declarations: [AppComponent] &#125;).compileComponents(); &#125;)); it('THEN: should create the component', () =&gt; &#123; const fixture = TestBed.createComponent(AppComponent); const app = fixture.debugElement.componentInstance; expect(app).toBeTruthy(); &#125;); it(`THEN: should have a property title with value 'shop'`, () =&gt; &#123; const fixture = TestBed.createComponent(AppComponent); const app = fixture.debugElement.componentInstance; expect(app.title).toEqual('shop'); &#125;); it(`THEN: should render 'Hello world' in a H1 tag`, () =&gt; &#123; const fixture = TestBed.createComponent(AppComponent); fixture.detectChanges(); const compiled = fixture.debugElement.nativeElement; expect(compiled.querySelector('h1').textContent).toContain('Hello world'); &#125;); &#125;);&#125;);2.2.2 Services12345GIVEN: a GreetingsService WHEN: the DataModule is compiled THEN: should be created THEN: should return an observable when call 'getGrettings()' THEN: should return 'Welcome to api!' when call 'getGrettings()'La prueba de servicios es más sencilla que la de componentes pues no hay que tratar con la renderización del HTML; sólo funcionalidad en una clase TypeScript. Pero, siempre hay un pero, muchos de estos servicios tratarán con llamadas asíncronas. Afortunadamente está todo pensado y se resuelve con dos conceptos: la función async() y inyección de réplicas (mocks) de las dependencias.libs\\shared\\data\\src\\lib\\greetings\\greetings.service.spec.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445// importar réplicas para testing de las dependencias del servicioimport &#123; HttpClientTestingModule, HttpTestingController&#125; from '@angular/common/http/testing';import &#123; async, TestBed &#125; from '@angular/core/testing';import &#123; Observable &#125; from 'rxjs';import &#123; GreetingsService &#125; from './greetings.service';describe('GIVEN: a GreetingsService', () =&gt; &#123; describe('WHEN: the DataModule is compiled', () =&gt; &#123; beforeEach(() =&gt; &#123; TestBed.configureTestingModule(&#123; imports: [HttpClientTestingModule] &#125;); &#125;); it('THEN: should be created', () =&gt; &#123; const service: GreetingsService = TestBed.get(GreetingsService); expect(service).toBeTruthy(); &#125;); it(`THEN: should return an observable when call 'getGrettings()'`, () =&gt; &#123; const service: GreetingsService = TestBed.get(GreetingsService); const greetings$: Observable&lt;any&gt; = service.getGrettings$(); expect(greetings$).toBeInstanceOf(Observable); &#125;); // Ojo al async para ejectuar las llamadas asíncronas it(`THEN: should return 'Welcome to api!' when call 'getGrettings()'`, async(() =&gt; &#123; const service: GreetingsService = TestBed.get(GreetingsService); service .getGrettings$() .subscribe(result =&gt; expect(result).toEqual(&#123; message: 'Welcome to api!' &#125;) ); // mock del backend para no depender del servidor const httpMock = TestBed.get(HttpTestingController); // esperar a que se llame a esta ruta const req = httpMock.expectOne('http://localhost:3333/api'); req.flush(&#123; message: 'Welcome to api!' &#125;); // responder con esto httpMock.verify(); // comprobar que no hay más llmadas &#125;)); &#125;);&#125;);A partir de aquí es siempre igual. Defines un respuesta esperada, le das una entrada conocida y si algo no cuadra, entonces el código no pasa la prueba y tienes una oportunidad para mejorarlo.En la prueba de servicios es fundamental que uses réplicas de sus dependencias. Es la forma de garantizar que pruebas únicamente el servicio, sin depender de nada. Esto era mucho más complejo con los componentes, pero un mandamiento con los servicios.ResumenEn definitiva, los grandes desarrollos demandados por bancos, multinacionales o administración pública requieren soluciones fiables y mantenibles. Y eso pasa inexcusablemente por hacer testing. Angular facilita las pruebas unitarias y de integración; especialmente con las herramientas Jest y Cypress ya configuradas por NxDevTools.Con este tutorial de formación avanzada en Angular te preparas para poder afrontar retos de tamaño industrial. Continúa aprendiendo a mejorar el rendimiento usando la detección del cambio en Angular. Todos esos detalles se tratan en el curso avanzado online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Nx","slug":"Nx","permalink":"https://academia-binaria.com/tag/Nx/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Test","slug":"Test","permalink":"https://academia-binaria.com/tag/Test/"},{"name":"Jest","slug":"Jest","permalink":"https://academia-binaria.com/tag/Jest/"},{"name":"Cypress","slug":"Cypress","permalink":"https://academia-binaria.com/tag/Cypress/"}]},{"title":"Nx, mono repositorios en Angular","slug":"nx-mono-repositorios-en-Angular","date":"2019-09-03T16:59:27.000Z","updated":"2019-09-23T11:20:34.965Z","comments":true,"path":"nx-mono-repositorios-en-Angular/","link":"","permalink":"https://academia-binaria.com/nx-mono-repositorios-en-Angular/","excerpt":"Empiezo este tutorial de Angular Avanzado con la frase con la que acabé un artículo de opinión sobre arquitectura de software acerca de Angular para grandes aplicaciones.Angular y las decisiones de diseño que le acompañan tienen como objetivo facilitar el desarrollo y mantenimiento a medio y largo plazo de aplicaciones web no triviales.Las empresas de desarrollo y los clientes finales que escogen Angular, suelen ser de tamaño medio o grande. Cuanto mayor sea el problema más destaca este framework. Y tarde o temprano esos grandes proyectos necesitarán compartir o reutilizar código. La herramienta Nx de Nrwl ayuda en esa tarea facilitando la creación de espacios de trabajo multi proyecto: los mono repositorios.","text":"Empiezo este tutorial de Angular Avanzado con la frase con la que acabé un artículo de opinión sobre arquitectura de software acerca de Angular para grandes aplicaciones.Angular y las decisiones de diseño que le acompañan tienen como objetivo facilitar el desarrollo y mantenimiento a medio y largo plazo de aplicaciones web no triviales.Las empresas de desarrollo y los clientes finales que escogen Angular, suelen ser de tamaño medio o grande. Cuanto mayor sea el problema más destaca este framework. Y tarde o temprano esos grandes proyectos necesitarán compartir o reutilizar código. La herramienta Nx de Nrwl ayuda en esa tarea facilitando la creación de espacios de trabajo multi proyecto: los mono repositorios.Partiendo de cero y usando las herramientas de Nrwl.io/ crearemos un blueprint para desarrollar grandes aplicaciones. Al finalizar tendrás, en el mismo repositorio, un par de aplicaciones y varias librerías reutilizables creadas con los Nx power-ups.Código asociado a este tutorial en GitHub: AcademiaBinaria/angular-bossTabla de Contenido:1. Crear el repositorio.2. Generar varias aplicaciones con Angular.3. Tener una biblioteca TypeScript con lógica de dominio.4. Tener una biblioteca Angular con componentes de interfaz.5. Tener una biblioteca Angular con servicios de datos.DiagramasResumen1. Crear el repositorio123Como: arquitecto de softwarequiero: disponer de un espacio de trabajo únicopara: crear aplicaciones y librerías.Lo primero será preparar las herramientas. Nx es un complemento del CLI así que debemos tener este último disponible. Voy a emplear yarn para la instalación de paquetes y la ejecución de comandos. Pero se muestran las instrucciones alternativas con npm. El repositorio siempre lo creo vacío y después agrego las capacidades específicas para Angular.1234567891011# Add latest Angular CLIyarn global add @angular/cli# Sets yarn as default packager for cling config -g cli.packageManager yarn# Creates empty repositoryyarn create nx-workspace angular-blueprint# also with NPM...npm i -g @angular/clinpx create-nx-workspace@latest angular-blueprint2. Generar una SPA con Angular1234567As a: customer, I want: to see a shop so that: I can buy products As a: seller, I want: to see a warehouse so that: I can take controlLos próximos comandos te sonarán a los mismo del angular-cli. Es normal, pues Nx utiliza y mejora las capacidades de la herramienta original. La diferencia está en que la recién creada aplicación, en lugar de nacer en la raíz del workspace, va la carpeta específica /apps.1234567891011# Add Angular capabilitiesyarn add --dev @nrwl/angular# Generate an Angular application with nx power-upsng g @nrwl/schematics:application shop --inlineStyle --routing --directory= -p ab-shop# Start default !!!yarn start# Generate an Angular application with nx power-upsng g @nrwl/schematics:application warehouse --inlineStyle --routing --directory= -p ab-warehouse# Start especific !!!ng serve warehouse --port=4202 -oAmbas aplicaciones comparten la configuración del angular.json y las demás herramientas de ayuda como tslint y prettier. Destaca mucho que también que compartan /node_modules, lo cual se agradece en el tiempo y en el espacio.Con nx puedes crear también aplicaciones de Backend. Por ejemplo un API REST hecha con NestJS. Para acceder a los generadores específico tienes que instalarlos antes. por ejemplo:123yarn add --dev @nrwl/nestng g @nrwl/nest:application aping serve apiAl tener varias aplicaciones es conveniente disponer de scripts específicos para cada una. Por ejemplo yo en el package.json tendía algo así.1234567891011&#123; \"start:shop\": \"ng serve shop --port=4201 -o\", \"build:shop\": \"ng build shop --prod\", \"test:shop\": \"ng test shop\", \"start:warehouse\": \"ng serve warehouse --port=4202 -o\", \"build:warehouse\": \"ng build warehouse --prod\", \"test:warehouse\": \"ng test warehouse\", \"start:api\": \"ng serve api\", \"build:api\": \"ng build api --prod\", \"test:api\": \"ng test api\",&#125;Por supuesto que todos estos comando se pueden lanzar visualmente mediante la extensión Angular Console para VSCode. Te recomiendo además estas otras extensiones:123456789101112&#123; \"recommendations\": [ \"nrwl.angular-console\", \"angular.ng-template\", \"ms-vscode.vscode-typescript-tslint-plugin\", \"esbenp.prettier-vscode\", \"pkief.material-icon-theme\", \"christian-kohler.path-intellisense\", \"ban.spellright\", \"johnpapa.angular-essentials\" ]&#125;3. Tener una biblioteca TypeScript con lógica de dominio.123Como: arquitectoquiero: tener una biblioteca en TypeScript con lógica de dominiode modo que: pueda usarla con varios frameworks o incluso en puro JavaScript.Más temprano que tarde aparecerán funcionalidades comunes a distintas aplicaciones. Validadores genéricos, utilidades o casos concretos de un cliente pero que se usan en todos sus desarrollos. En este ejemplo partimos de la necesidad común de un sistema de saludos (un mensaje, vaya). Y para ello empezamos por definir una interface pública reutilizable.Un poco de arquitectura de software. Todo lo que podamos programar y que no dependa de un framework debemos encapsularlo en librerías independientes. De esa forma puede reutilizarse con otras tecnologías o sobrevivir dignamente a la evolución o desaparición de Angular.Lo primero será crear la librería. Pero esta vez no usaremos los schematics del cli, si no los propios de nrwl. La idea es usarla como la capa de dominio de la arquitectura. En ella pondremos los modelos y servicios de lógica de negocio con las menores dependencias posibles. Repito lo fundamental: minimizar las dependencias. En concreto no dependeremos de Angular, lo cual permitiría usarlo con otros frameworks actuales o futuros.12# Generate a Type Script library with nx power-upsng generate @nrwl/workspace:library domain --directory=sharedPor ahora no te preocupes de la implementación. La muestro para destacar las dos cosas que considero más importantes:No hay ninguna referencia explícita a Angular.Lo que quieras exportar debe indicarse en el fichero index.ts.Por lo demás es puro TypeScript; en una carpeta con intenciones bien claras: models/ creo de forma manual el siguiente fichero:libs\\shared\\domain\\src\\lib\\models\\greetings.interface.ts123export interface Greetings &#123; message: string;&#125;al no disponer del sistema de módulos de angular tengo que exportarlo en el índice de la librería.libs\\shared\\domain\\src\\index.ts1export * from './lib/models/greetings.interface';Para localizarlo, Nx crea un alias en el tsconfig.json, que puedes retocar a voluntad123\"paths\": &#123; \"@a-boss/domain\": [\"libs/shared/domain/src/index.ts\"]&#125;Ya está listo para seer consumido desde distintos proyectos (Lo haré después en el API y ya mismo en la próxima librería de componentes).4. Tener una biblioteca Angular con componentes de interfaz1234567As a: customer, I want: to be greeted so that: I feel at homeAs a: seller, I want: to be greeted so that: I feel at homeSi eres una empresa consultora es posible que te encuentres repitiendo funciones o pantallas una y otra vez para distintos clientes. Por supuesto que una gran empresa seguro que se hacen muchas aplicaciones similares, a las que les vendría de maravilla compartir una biblioteca de componentes.Pues ahora crear librerías es igual de sencillo que crear aplicaciones. Nx las depositará en la carpeta /libs y se ocupará de apuntarlas en el tsconfig.json para que la importación desde el resto del proyecto use alias cortos y evidentes.Crear componentes en un entorno multi proyecto requiere especificar a qué proyecto se asociarán. Para empezar vamos a crear los componentes básicos para esta funcionalidad en una librería compartida de para interfaz de usuario.1234# Generate an Angular library with nx power-upsng g @nrwl/angular:library ui --directory=shared --prefix=ab-ui --simpleModuleName# Generate Greetings Componentng g component greetings --project=shared-ui --module=ui.module.ts --export --inlineStyle --inlineTemplateY le damos contenido al componente. Fíjate en la importación de la interfaz Greetings.libs\\shared\\ui\\src\\lib\\greetings\\greetings.component.ts123456789101112131415161718import &#123; Greetings &#125; from '@a-boss/domain';import &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'ab-ui-greetings', template: ` &lt;p&gt; &#123;&#123; theGreeting.message &#125;&#125; &lt;/p&gt; `, styles: []&#125;)export class GreetingsComponent implements OnInit &#123; public theGreeting: Greetings = &#123; message: 'Hello world' &#125;; constructor() &#123;&#125; ngOnInit() &#123;&#125;&#125;Puedes usarlos como cualquier otro componente y en cualquier aplicación del repositorio. Simplemente importando el módulo en el que se declaran: el UiModule. NX se encarga de referenciar cada proyecto en el fichero tsconfig.json. De esa forma se facilita su importación en cualquier otra aplicación del repositorio.Primero importamos el módulo.apps\\shop\\src\\app\\app.module.ts1234567891011121314151617import &#123; UiModule &#125; from '@a-boss/ui';import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; RouterModule &#125; from '@angular/router';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [AppComponent], imports: [ BrowserModule, RouterModule.forRoot([], &#123; initialNavigation: 'enabled' &#125;), UiModule ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125;Y ya podemos incrustar sus componentes públicos.apps\\shop\\src\\app\\app.component.html12&lt;ab-ui-greetings&gt;&lt;/ab-ui-greetings&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;apps\\shop\\src\\app\\app.component.ts12345678910import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'ab-shop-root', templateUrl: './app.component.html', styles: []&#125;)export class AppComponent &#123; title = 'shop';&#125;5. Tener una biblioteca Angular con servicios de datos1234567As a: customer, I want: to be greeted by the API :-) so that: I know I am not alone.As a: seller, I want: to be greeted by the API :-) so that: I know I am not alone.Además de componentes visuales, podemos tener librerías con servicios de lógica o de acceso a datos. Por ejemplo un servicio para comunicarnos con el API podría ser utilizado en diversos proyectos (aplicaciones o librerías).Con lo ya sabido vamos a crear una librería compartida para acceso a datos.12ng g @nrwl/angular:library data --directory=shared --prefix=ab-data --simpleModuleNameng g service greetings --project=shared-data --no-flatEl servicio realiza la llamada http y devuelve un observable.libs\\shared\\data\\src\\lib\\greetings\\greetings.service.ts1234567891011121314import &#123; Greetings &#125; from '@a-boss/domain';import &#123; HttpClient &#125; from '@angular/common/http';import &#123; Injectable &#125; from '@angular/core';import &#123; Observable &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root'&#125;)export class GreetingsService &#123; private apiUrl = 'http://localhost:3333/api'; constructor(private httpClient: HttpClient) &#123;&#125; public getGrettings$(): Observable&lt;Greetings&gt; &#123; return this.httpClient.get&lt;Greetings&gt;(this.apiUrl); &#125;&#125;Para consumir el servicio no hay que hacer nada más. Pero, para importarlo en TypeScript, necesitmaos que nos lo exporten adecuadamente.libs\\shared\\data\\src\\index.ts12export * from './lib/data.module';export * from './lib/greetings/greetings.service';tsconfig.json123\"paths\": &#123; \"@a-boss/domain\": [\"libs/shared/domain/src/index.ts\"]&#125;Y ahora consumirlo ya no es un problema. Por ejemplo directamente en el componente.libs\\shared\\ui\\src\\lib\\greetings\\greetings.component.ts12345678910111213141516171819202122import &#123; GreetingsService &#125; from '@a-boss/data';import &#123; Greetings &#125; from '@a-boss/domain';import &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'ab-ui-greetings', template: ` &lt;p&gt; &#123;&#123; theGreeting.message &#125;&#125; &lt;/p&gt; `, styles: []&#125;)export class GreetingsComponent implements OnInit &#123; public theGreeting: Greetings = &#123; message: 'Hello world' &#125;; constructor(private greetingsService: GreetingsService) &#123;&#125; public ngOnInit() &#123; this.greetingsService.getGrettings$().subscribe(this.appendApiMessage); &#125; private appendApiMessage = (apiGreetings: Greetings) =&gt; (this.theGreeting.message += ' and ' + apiGreetings.message);&#125;Ya que estamos accediendo al API, podemos aprovechar para adecuar sus tipos a la interfaz declarada en el dominio. Fíjate lo familiar que resulta este código NodeJS gracias al framework nest.apps\\api\\src\\app\\app.controller.ts12345678910111213import &#123; Greetings &#125; from '@a-boss/domain';import &#123; Controller, Get &#125; from '@nestjs/common';import &#123; AppService &#125; from './app.service';@Controller()export class AppController &#123; constructor(private readonly appService: AppService) &#123;&#125; @Get() getData(): Greetings &#123; return this.appService.getData(); &#125;&#125;ResumenEn definitiva, los grandes desarrollos demandados por bancos, multinacionales o administración pública requieren soluciones avanzadas. Angular es una plataforma ideal para esos grandes proyectos, pero requiere conocimiento y bases sólidas para sacarle partido.Con este tutorial empiezas tu formación avanzada en Angular para poder afrontar retos de tamaño industrial. Continúa aprendiendo a crear y ejecutar pruebas automatizadas creando tests unitarios con Jest y e2e con Cypress en Angular. Todos esos detalles se tratan en el curso avanzado online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Nx","slug":"Nx","permalink":"https://academia-binaria.com/tag/Nx/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"}]},{"title":"Material Design y CLI de Angular","slug":"Material-Design-y-CLI-de-Angular","date":"2019-03-14T17:59:27.000Z","updated":"2019-10-09T10:45:38.705Z","comments":true,"path":"Material-Design-y-CLI-de-Angular/","link":"","permalink":"https://academia-binaria.com/Material-Design-y-CLI-de-Angular/","excerpt":"El ecosistema de Angular está repleto de librerías para desarrolladores profesionales. Algunas hacen uso de los schematics, y entre ellas destaca Angular Material. Esta implementación de la casa de la guía de diseño Material Design de Google usa las capacidades de estas plantillas del CLI que permiten agregar librerías y generar código.Un programador Angular debe dominar el CLI y debe conocer los beneficios que aporta un repositorio de multi-proyecto. Hay escenarios complejos muy adecuaos para estos mono-repos. Pero con el CLI es muy sencillo crear y usar nuevas aplicaciones dentro de un repositorio.","text":"El ecosistema de Angular está repleto de librerías para desarrolladores profesionales. Algunas hacen uso de los schematics, y entre ellas destaca Angular Material. Esta implementación de la casa de la guía de diseño Material Design de Google usa las capacidades de estas plantillas del CLI que permiten agregar librerías y generar código.Un programador Angular debe dominar el CLI y debe conocer los beneficios que aporta un repositorio de multi-proyecto. Hay escenarios complejos muy adecuaos para estos mono-repos. Pero con el CLI es muy sencillo crear y usar nuevas aplicaciones dentro de un repositorio.Partiendo de la aplicación tal como quedó en Formularios reactivos con Angular. Al finalizar tendrás, en el mismo repositorio, una nueva aplicación con la apariencia y usabilidad de Material design.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-basic/projects/schemat/Tienes una versión desplegada operativa para probar Schemat1. Repositorio multi-proyectoEl primer comando que se usa al empezar con angular es ng new mi-aplicacion. Desde ese momento tu mundo es la carpeta /src en la que se genera el código y en la que vas a desarrollar.Pero con el tiempo, ciertos proyectos crecen y hay que dividirlos. O quizás surjan aplicaciones hermanas. Angular CLI permite disponer de más de un proyecto compartiendo repositorio y configuración.1.1 Carpetas src y projectsDado un repositorio inicial, para agregar una nueva aplicación usaremos el viejo comando generate. Por ejemplo voy a crear una aplicación en la que usar las capacidades de los schematics y de material; la llamaré schemat1ng g application schemat --routingEsta aplicación comparte la configuración básica de angular.json y las dependencias y scripts de package.json. Su código específico va en la carpeta projects destinada a los nuevos proyectos generados tras haber creado el repo inicial.1.2 Compilación multi - proyectoA partir de ahora cada comando del CLI debería ir asociado a un proyecto concreto. Digo debería porque an angular.json puedes establecer un proyecto por defecto, que si no dices lo contrario será el inicial.Pero, es buena práctica crear scripts específicos en el package.json para iniciar y compilar cada proyecto.12&quot;start:schemat&quot;: &quot;ng serve schemat --aot -o --port 4271&quot;,&quot;build:prod:schemat&quot;: &quot;ng build schemat --prod&quot;,2. Instalación y configuración de MaterialPor muchas funcionalidades que aporte un framework como Angular, siempre necesitaremos echar mano de alguna librería de terceros. Normalmente eso implica instalarla con npm, importar sus módulos en Angular y en ocasiones alguna configuración extra.Pero algunos proyectos ha adoptado la librería schematics para facilitar la adopción de sus librerías. Es el caso de Angular Material.2.1 Agregar dependencias con schematicsPara agregar Material un proyecto basta con usar el comando add del CLI.1ng add @angular/material --project=schematEsto instalará y anotará la dependencia de @angular/material y otros paquetes necesarios. Pero además los registrará en AppModule y lo configurará.2.2 Estilos, iconos y temas básicosEn el index.html se insertarán los enlaces a las hojas de estilos con fuentes e iconos. En el styles.css podremos importar el tema de Material que nos guste.1@import '~@angular/material/prebuilt-themes/indigo-pink.css';3. Componentes básicosAngular Material es mucho más que un css. El proyecto te ofrece más de una docena de componentes visuales para crear páginas web de aspecto y comportamiento profesional.Por si fuera poco, ofrece sus propias plantillas de schematics, de forma que podemos crear pantallas con el CLI y luego trabajar sobre ellas.3.1 Navegación y layoutPara empezar vamos a crear el armazón de la aplicación, con su menú y su espacio para cargar contenido. Después pondremos la primera piedra con un dashboard en la raíz de la web.3.1.1 NavegaciónAl control que hará de shell le llaman nav por sus capacidades de navegación. Lo usaremos para generar un componente. La novedad será que la plantilla a partir de la cual se crea no viene por defecto y tenemos que especificarla con más detalle.1ng g @angular/material:nav shell --project=schematEL resultado es un componente normal, muy adecuado para sustituir todo lo pre-generado por el cli enapp.component.html1&lt;app-shell&gt;&lt;/app-shell&gt;3.1.2 DashboardPara la ruta raíz elegí un cuadro de mando. De nuevo es una generación a partir de una plantilla específica. En este caso le he llamado Home.1ng g @angular/material:dashboard home --project=schematAsociamos el componente a la ruta en app-routing123456const routes: Routes = [ &#123; path: '', component: HomeComponent &#125;];Y le buscamos un lugar tanto al enlace como al RouterOutlet en el previamente generado shell.component.html.123&lt;a mat-list-item [routerLink]=\"['/']\"&gt;Home&lt;/a&gt;&lt;!-- Add Content Here --&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;3.2 Componentes básicosPor supuesto que una librería de esta envergadura tienen soluciones para todo tipo de situaciones visuales. Para las más comunes incluso ofrecen una plantilla en sus schematics que permite generar prototipos funcionales de formularios, tablas y hasta árboles.3.2.1 FormulariosPuedes generar un formulario para crear contactos y después modificarlo o usarlo como guía para crear cualquier otro.1ng g @angular/material:address-form contact --project=schemat3.2.2 TablasTambién nos muestran cómo hacer listados, con datos de ejemplo incluidos.1ng g @angular/material:table elements --project=schematEl ejemplo permite además ver los datos en páginas y configurar su comportamiento.123456&lt;mat-paginator #paginator [length]=\"dataSource.data.length\" [pageIndex]=\"0\" [pageSize]=\"5\" [pageSizeOptions]=\"[5, 10, 15, 20]\"&gt;&lt;/mat-paginator&gt;3.2.3 ÁrbolesTermino con un ejemplo de algo reciente, el árbol. Este componente se resistió pero por petición popular acabaron integrándolo y ahora puedes mostrar datos jerárquicos como más les gusta a los usuarios: en forma de árboles.1ng g @angular/material:tree source --project=schematPor supuesto que hay más opciones, todas bien explicadas en la documentación de Angular Material. Es una solución muy recomendable para aplicaciones de gestión, o simplemente para que se vean muy bien en Android y recuerden al look and feel de todo lo que hace Google.Con este conocimiento finalizas tu introducción a Angular. En el tutorial avanzado aprenderás más cosas para programar con Angular 8.Todos esos detalles se tratan en el curso básico online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"},{"name":"material","slug":"material","permalink":"https://academia-binaria.com/tag/material/"}]},{"title":"Formularios reactivos con Angular","slug":"formularios-reactivos-con-Angular","date":"2019-03-12T09:59:27.000Z","updated":"2019-10-09T10:45:38.705Z","comments":true,"path":"formularios-reactivos-con-Angular/","link":"","permalink":"https://academia-binaria.com/formularios-reactivos-con-Angular/","excerpt":"El doble enlace automático entre elementos html y propiedades de objetos fue el primer gran éxito de Angular. Ese doble-binding facilita mucho el desarrollo de formularios. Pero esa magia tienen un coste en escalabilidad; impacta en el tiempo de ejecución y además dificulta la validación y el mantenimiento de formularios complejos.La solución en Angular 8 pasa por desacoplar el modelo y la vista, introduciendo una capa que gestione ese doble enlace. Los servicios y directivas del módulo ReactiveFormsModule que viene en la librería @angular/forms permiten programar formularios reactivos conducidos por el código.","text":"El doble enlace automático entre elementos html y propiedades de objetos fue el primer gran éxito de Angular. Ese doble-binding facilita mucho el desarrollo de formularios. Pero esa magia tienen un coste en escalabilidad; impacta en el tiempo de ejecución y además dificulta la validación y el mantenimiento de formularios complejos.La solución en Angular 8 pasa por desacoplar el modelo y la vista, introduciendo una capa que gestione ese doble enlace. Los servicios y directivas del módulo ReactiveFormsModule que viene en la librería @angular/forms permiten programar formularios reactivos conducidos por el código.Partiendo de la aplicación tal como quedó en Vigilancia y seguridad en Angular. Al finalizar tendrás una aplicación con formularios model driven fáciles de mantener y validar.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-basic/8-reactiveTienes una versión desplegada operativa para probar Angular Basic1 Desacople entre vista y modeloLa directiva [(ngModel)]=&quot;model.property&quot; con su popular banana in a box establece el doble enlace entre el elemento de la vista al que se le aplica y una propiedad del modelo. Los cambios en la vista son trasladados automáticamente al modelo, y al revés; cualquier cambio en el modelo se refleja inmediatamente en la vista.Se pueden establecer validaciones y configurar los eventos que disparan las actualizaciones; pero todo ello usando más y más atributos y directivas en la plantilla. Son los formularios template driven que degeneran en un html farragoso y difícil de mantener.Vamos a crear un formulario de registro de usuarios usando los formularios model driven. Para ello voy a crear el módulo security con el componente register y los engancharé a la ruta security/register.El módulo de seguridad y su configuración lazy en el raíz:12ng g m security --routing trueng g c security/register1234&#123; path: 'security', loadChildren: () =&gt; import('./8-reactive/security/security.module').then(m =&gt; m.SecurityModule)&#125;,El componente de registro y su ruta asignada:12345678910const routes: Routes = [ &#123; path: 'register', component: RegisterComponent &#125;, &#123; path: '**', redirectTo: 'register' &#125;];1&lt;a routerLink=\"security/register\" class=\"button\"&gt;Register&lt;/a&gt;1.1 Form BuilderEntra en acción el FormBuilder, un servicio del que han de depender los componentes que quieran desacoplar el modelo de la vista. Se usa para construir un formulario creando un FormGroup, (un grupo de controles) que realiza un seguimiento del valor y estado de cambio y validez de los datos.Para poder usarlo tenemos que importar el módulo de Angular en el que viene declarado, el ReactiveFormModule.12345678910import &#123; ReactiveFormsModule &#125; from '@angular/forms';@NgModule(&#123; declarations: [RegisterComponent], imports: [ CommonModule, SecurityRoutingModule, ReactiveFormsModule ]&#125;)export class SecurityModule &#123; &#125;Veamos un ejemplo mínimo de su declaración en register.component.ts.123456789101112export class RegisterComponent implements OnInit &#123; public formGroup: FormGroup; constructor( private formBuilder: FormBuilder ) &#123; &#125; public ngOnInit() &#123; this.buildForm(); &#125; private buildForm()&#123; this.formGroup = this.formBuilder.group(&#123;&#125;); &#125;&#125;1.2 Form controlEl formulario se define como un grupo de controles. Cada control tendrá un nombre y una configuración. Esa definición permite establecer un valor inicial al control.1234567891011private buildForm() &#123; const dateLength = 10; const today = new Date().toISOString().substring(0, dateLength); const name = 'JOHN DOE'; this.formGroup = this.formBuilder.group(&#123; registeredOn: today, name: name.toLowerCase(), email: 'john@angular.io', password: '' &#125;);&#125;Como ves, es fácil asignar valores por defecto. Incluso es un buen momento para modificar o transformar datos previos para ajustarlos a cómo los verá el usuario; sin necesidad de cambiar los datos de base.1.3 Form viewMientras tanto en la vista html… Este trabajo previo y extra que tienes que hacer en el controlador se recompensa con una mayor limpieza en la vista. Lo único necesario será asignar por nombre el elemento html con el control typescript que lo gestionará.Para ello usaremos dos directivas que vienen dentro del módulo reactivo son [formGroup]=&quot;objetoFormulario&quot; para el formulario en su conjunto, y formControlName=&quot;nombreDelControl&quot; para cada control.123456789101112131415161718&lt;form [formGroup]=\"formGroup\"&gt; &lt;label for=\"registeredOn\"&gt;Registered On&lt;/label&gt; &lt;input name=\"registeredOn\" formControlName=\"registeredOn\" type=\"date\" /&gt; &lt;label for=\"name\"&gt;Name&lt;/label&gt; &lt;input name=\"name\" formControlName=\"name\" type=\"text\" /&gt; &lt;label for=\"email\"&gt;E-mail&lt;/label&gt; &lt;input name=\"email\" formControlName=\"email\" type=\"email\" /&gt; &lt;label for=\"password\"&gt;Password&lt;/label&gt; &lt;input name=\"password\" formControlName=\"password\" type=\"password\" /&gt;&lt;/form&gt;2 Validación y estadosLa validación es una pieza clave de la entrada de datos en cualquier aplicación. Es el primer frente de defensa ante errores de usuarios; ya sean involuntarios o deliberados.Dichas validaciones se solían realizar agregando atributos html tales como el archiconocido required. Pero todo eso ahora se traslada a la configuración de cada control, donde podrás establecer una o varias reglas de validación sin mancharte con html.2.1 Validadores predefinidos y personalizadosDe nuevo tienes distintas sobrecargas que te permiten resolver limpiamente casos sencillos de una sola validación, o usar baterías de reglas que vienen predefinidas como funciones en el objeto Validators del framework.12345678910111213141516private buildForm() &#123; const dateLength = 10; const today = new Date().toISOString().substring(0, dateLength); const name = 'JOHN DOE'; const minPassLength = 4; this.formGroup = this.formBuilder.group(&#123; registeredOn: today, name: [name.toLowerCase(), Validators.required], email: ['john@angular.io', [ Validators.required, Validators.email ]], password: ['', [ Validators.required, Validators.minLength(minPassLength) ]] &#125;);&#125;A estas validaciones integradas se puede añadir otras creadas por el programador. Incluso con ejecución asíncrona para validaciones realizadas en el servidor.Por ejemplo podemos agregar una validación específica a las contraseñas12345password: ['', [ Validators.required, Validators.minLength(minPassLength), this.validatePassword]]Lo único que se necesita es una función que recibe como argumento el control a validar. El resultado debe ser un null si todo va bien. Y cualquier otra cosa en caso de fallo. Te muestro una propuesta para que puedas crear tus propios validadores.1234567891011private validatePassword(control: AbstractControl) &#123; const password = control.value; let error = null; if (!password.includes('$')) &#123; error = &#123; ...error, dollar: 'needs a dollar symbol' &#125;; &#125; if (!parseFloat(password[0])) &#123; error = &#123; ...error, number: 'must start with a number' &#125;; &#125; return error;&#125;2.2 Estados de cambio y validaciónUna vez establecidas las reglas, es hora de aplicarlas y avisar al usuario en caso de que se incumplan. Los formularios y controles reactivos están gestionados por máquinas de estados que determinan en todo momento la situación de cada control y del formulario en si mismo.2.2.1 Estados de validaciónAl establecer una o más reglas para uno o más controles activamos el sistema de chequeo y control del estado de cada control y del formulario en su conjunto.La máquina de estados de validación contempla los siguientes estados mutuamente excluyentes:VALID: el control ha pasado todos los chequeosINVALID: el control ha fallado al menos en una regla.PENDING: el control está en medio de un proceso de validaciónDISABLED: el control está desactivado y exento de validaciónCuando un control incumple con alguna regla de validación, estas se reflejan en su propiedad errors que será un objeto con una propiedad por cada regla insatisfecha y un valor o mensaje de ayuda guardado en dicha propiedad.2.2.2 Estados de modificaciónLos controles, y el formulario, se someten a otra máquina de estados que monitoriza el valor del control y sus cambios.La máquina de estados de cambio contempla entre otros los siguientes:PRINSTINE: el valor del control no ha sido cambiado por el usuarioDIRTY: el usuario ha modificado el valor del control.TOUCHED: el usuario ha tocado el control lanzando un evento blur al salir.UNTOUCHED: el usuario no ha tocado y salido del control lanzando ningún evento blur.Como en el caso de los estados de validación, el formulario también se somete a estos estados en función de cómo estén sus controles.Veamos su aplicación primero en el caso general del formulario. Uno de los usos más inmediatos es deshabilitar el botón de envío cuando la validación de algún control falla.12&lt;button (click)=\"register()\" [disabled]=\"formGroup.invalid\"&gt;Register me!&lt;/button&gt;Por cierto, este sistema de gestión de los controles del formulario oculta la parte más valiosa (el valor que se pretende almacenar) en la propiedad value del formulario. Contendrá un objeto con las mismas propiedades usadas durante la definición del formulario, cada una con el valor actual del control asociado.1234public register() &#123; const user = this.formGroup.value; console.log(user);&#125;La validación particular para cada control permite informar al usuario del fallo concreto. Es una buena práctica de usabilidad el esperar a que edite un control antes de mostrarle el fallo. Y también es muy habitual usar la misma estrategia para cada control.Lo que no queremos es llevar de vuelta la lógica a la vista; así que lo recomendado es crear una función auxiliar para mostrar los errores de validación.12345678public getError(controlName: string): string &#123; let error = ''; const control = this.formGroup.get(controlName); if (control.touched &amp;&amp; control.errors != null) &#123; error = JSON.stringify(control.errors); &#125; return error;&#125;En la vista colocaremos adecuadamente los mensajes para facilitarle la corrección al usuario.123&lt;span&gt;&#123;&#123; getError('name')&#125;&#125;&lt;/span&gt;&lt;span&gt;&#123;&#123; getError('email')&#125;&#125;&lt;/span&gt;&lt;span&gt;&#123;&#123; getError('password')&#125;&#125;&lt;/span&gt;Ya tenemos formularios reactivos conducidos por los datos que te permitirán construir pantallas complejas manteniendo el control en el modelo y dejando la vista despejada. Como resumen podemos decir que vamos a programar más en TypeScript que en Html. La ventaja del desacople es que podremos controlar lo que enviamos y recibimos de la vista. Así se pueden aplicar formatos, validaciones y transformaciones entre lo que presentamos y lo que enviamos hacia los servicios.3. Un gestor de credencialesVamos a provechar el conocimiento sobre Interceptores y Observables para montar un pequeño sistema de gestión de credenciales. La idea es detectar respuestas a llamadas no autenticadas y redirigir al usuario a nuestra pantalla de registro.Si el usuario se registra correctamente recibiremos un token que lo identifica. Lo que haremos será guardarlo y usarlo en el resto de las llamadas.3.1 Detección y redirección de intrusosEmpezaré por crea un servicio para el interceptor de fallos de seguridad y un componente que invocará deliberadamente a un API protegida.12ng g s security/auth-interceptorng g c security/secretAl componente secret le asignaremos la ruta security/secret1&lt;a routerLink=\"security/register\" class=\"button\"&gt;Register&lt;/a&gt;1234567891011121314const routes: Routes = [ &#123; path: 'register', component: RegisterComponent &#125;, &#123; path: 'secret', component: SecretComponent &#125;, &#123; path: '**', redirectTo: 'secret' &#125;];En cuanto al interceptor, haremos como ya hemos visto en el tema 7-watch. Lo primero será proveerlo invirtiendo el control que nos cede el HttpClient.123456789101112@NgModule(&#123; declarations: [RegisterComponent, SecretComponent], imports: [CommonModule, SecurityRoutingModule, ReactiveFormsModule, HttpClientModule], providers: [ &#123; provide: HTTP_INTERCEPTORS, useClass: AuthInterceptorService, multi: true &#125; ]&#125;)export class SecurityModule &#123;&#125;Luego codificaré la implementación de la interfaz HttpInterceptor. En este caso me interesan las respuestas con error 401. Emplearé el Router de Angular para obligar al usuario a visitar la página de registro cuando esto ocurra.12345678910111213141516export class AuthInterceptorService implements HttpInterceptor &#123; constructor(private router: Router) &#123;&#125; public intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; return next.handle(req).pipe(catchError(this.handleError.bind(this))); &#125; private handleError(err) &#123; const unauthorized_code = 401; if (err instanceof HttpErrorResponse) &#123; if (err.status === unauthorized_code) &#123; this.router.navigate(['security/register']); &#125; &#125; return throwError(err); &#125;&#125;3.2 Almacenamiento y uso del tokenAntes de nada volveremos al tema de los observables y su uso como intermediarios entre objetos desacoplados. Para ello crearé un servicio para almacenar y distribuir el token de identificación de usuarios.1ng g s security/token_store123456789101112export class TokenStoreService &#123; private token = ''; private token$ = new BehaviorSubject&lt;string&gt;(''); constructor() &#123;&#125; public select$ = () =&gt; this.token$.asObservable(); public dispatch(token) &#123; this.token = token; this.token$.next(this.token); &#125;&#125;De vuelta en el componente RegisterComponent. Tenemos que enviar las credenciales al API para su aceptación. Si todo va bien, nos devolverán un token que identifica al usuario. Es momento de usar al TokenStore para transmitir la noticia por toda la aplicación.123456public register() &#123; const url = 'https://api-base.herokuapp.com/api/pub/credentials/registration'; const user = this.formGroup.value; this.httpClient.post&lt;any&gt;(url, user) .subscribe(res =&gt; this.tokenStore.dispatch(res.token));&#125;Por último volvemos al AuthInterceptorService en el que nos suscribiremos a los cambios acerca del token.12345private token = '';constructor(private router: Router, private tokenStore: TokenStoreService) &#123; this.tokenStore.select$() .subscribe(token =&gt; (this.token = token));&#125;Y lo usaremos en las cabeceras de todas las llamadas.123456public intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; const authHeader = &#123; Authorization: 'bearer ' + this.token &#125;; const authReq = req.clone(&#123; setHeaders: authHeader &#125;); return next.handle(authReq) .pipe(catchError(this.handleError.bind(this)));&#125;Ya sabes lo básico de Angular; pero puedes usar mucho más conociendo su ecosistema. Sigue esta serie para agregar librerías y usar los esquemas de Material Design y CLI de Angular mientras aprendes a programar con Angular. Todos esos detalles se tratan en el curso básico online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"reactiveForms","slug":"reactiveForms","permalink":"https://academia-binaria.com/tag/reactiveForms/"}]},{"title":"Vigilancia y seguridad en Angular","slug":"vigilancia-y-seguridad-en-Angular","date":"2019-03-06T17:49:27.000Z","updated":"2019-10-09T10:45:38.705Z","comments":true,"path":"vigilancia-y-seguridad-en-Angular/","link":"","permalink":"https://academia-binaria.com/vigilancia-y-seguridad-en-Angular/","excerpt":"La vigilancia de los datos y la información en tiempo real al usuario son dos pilares del desarrollo con Angular en el lado del navegador. La seguridad de los datos realmente es una responsabilidad compartida entre el servidor y el cliente.Veremos ambos aspectos del desarrollo, pues están muy relacionados con la programación asíncrona y el dominio de los observables. Sentaremos las bases para unas comunicaciones seguras y fluidas en Angular.","text":"La vigilancia de los datos y la información en tiempo real al usuario son dos pilares del desarrollo con Angular en el lado del navegador. La seguridad de los datos realmente es una responsabilidad compartida entre el servidor y el cliente.Veremos ambos aspectos del desarrollo, pues están muy relacionados con la programación asíncrona y el dominio de los observables. Sentaremos las bases para unas comunicaciones seguras y fluidas en Angular.Partiendo de la aplicación tal como quedó en Comunicaciones http en Angular. Al finalizar tendrás una aplicación que comunica a los usuarios cualquier información relevante y que gestiona de forma centralizada las respuestas de un servicio REST.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-basic/7-watchTienes una versión desplegada operativa para probar Angular Basic1. Observables para monitorizar datosHemos visto varias técnicas para comunicar información dentro de una aplicación Angular. Empezamos por conocer el flujo entre componentes de una misma rama del DOM. También enviamos datos en los parámetros de una ruta. Y obviamente podemos usar un servicio común para guardar información compartida. Pero en este caso, ¿Cuándo se actualiza? ¿Cómo saber si ha cambiado?. Lo resolveremos con Observables.Para ilustrar este tema vamos a crear un sencillo sistema de notificaciones que informe al usuario. Empezaremos creando un módulo para los propósitos de este laboratorio.123ng g m notifications --routing trueng g c notifications/senderng g c notifications/receiverLo apuntamos al enrutador global app-routing.module.ts y asignamos las rutas locales1234&#123; path: 'notifications', loadChildren: () =&gt; import('./7-watch/notifications/notifications.module').then(m =&gt; m.NotificationsModule)&#125;,1234567891011121314const routes: Routes = [ &#123; path: 'sender', component: SenderComponent &#125;, &#123; path: 'receiver', component: ReceiverComponent &#125;, &#123; path: '**', redirectTo: 'sender' &#125;];Por último un enlace en el menú principal header.component.html y ya estamos listos para enviar y recibir desde dos componente desacoplados.1&lt;a routerLink=\"notifications\" class=\"button\"&gt;Notifications&lt;/a&gt;Pero antes un poco más de observables.1.1 Productores de observablesLa librería RxJS es enorme y Angular hace un uso extenso de ella. En este tutorial se ha visto desde el punto de vista del consumidor. Es decir, nos hemos suscrito a fuentes observables. Para avanzar tendremos que poder emitir, o mejor dicho producir, información.Of y fromLos constructores más sencillos de la librería son funciones que emiten valores estáticos o secuencias a intervalos regulares. Para familiarizarte con ellos te propongo que juegues con código como este:123456value$ = of(new Date().getMilliseconds());value$.subscribe(r=&gt; console.log(r));stream$ = from([1, 'two', '***']);stream$.subscribe(r=&gt; console.log(r));list$ = of(['N', 'S', 'E', 'W']);list$.subscribe(r=&gt; console.log(r));Subject y BehaviorSubjectLos anteriores constructores se basan en datos estáticos. Resuelvan algunas situaciones, pero necesitamos algo que emita cambios dinámicos. Y eso se realiza con los Subjects, una especie de emisores temáticos a los que suscribirse.Hay varios tipos pero para empezar nos vamos a fijar en dos: el Subject() y el BehaviorSubject(initialData). La diferencia es que el primero sólo emite las cosas según ocurren. Si alguien se suscribe tarde no conocerá el pasado. Esto suele generar problemas de sincronización. El Behavior en cambio notifica el último valor conocido a cualquiera que se suscriba. De esa forma no importa si te suscribes antes o después de la obtención de un dato.Juega con el siguiente ejemplo:123456789101112131415const data = &#123;name:'', value:0&#125;;const need_sync$ = new Subject&lt;any&gt;();// on timeneed_sync.subscribe(r=&gt; console.log(r));need_sync.next(data);// too lateneed_sync.subscribe(r=&gt; console.log(r));const no_hurry$ = new BehaviorSubject&lt;any&gt;(this.data);// its okno_hurry.subscribe(r=&gt; console.log(r));no_hurry.next(data);// its also okno_hurry.subscribe(r=&gt; console.log(r));1.2 Un Store de notificacionesUsaremos el BehaviorSubject como notificador principal entre componentes de Angular. Por ejemplo podemos montar un sistema de notificaciones sencillo. Empecemos por crear un servicio:1ng g s notifications/notificationsStorePara adaptarnos a la nomenclatura usada por patrones de gestión de estado más avanzados como es Redux, usaré el siguiente convenio: Store como almacén, select$() como publicador de cambios observable y dispatch como encargado de procesar una acción de cambio de estado.1234567891011121314export class NotificationsStoreService &#123; private notifications = []; private notifications$ = new BehaviorSubject&lt;any[]&gt;([]); constructor() &#123;&#125; public select = () =&gt; [...this.notifications]; public select$ = () =&gt; this.notifications$.asObservable(); public dispatch(notification) &#123; this.notifications.push(&#123; ...notification &#125;); this.notifications$.next(this.select()); &#125;&#125;Este servicio es la implementación más sencilla posible de un gestor de estados. Cabe destacar que :Mantienen el estado privado para evitar manipulacionesRecibe de forma controlada las acciones de cambioEmite clones del estadoExpone observables para que se suscriban los interesados.1.3 Desacoplados pero conectadosUna vez que hemos centralizado el control de cambios de una parte de la aplicación, es hora de que lo usen los componentes o servicios involucrados. Solo necesitan recibir la instancia vía dependencia. No hay más acoplamiento entre emisores y receptores.EmisiónVeamos un ejemplo, un tanto forzado, consistente en dos componentes que se comunican sin conocerse. Esta es la vista con un formulario para enviar mensajes1234567891011121314&lt;h2&gt; Notes sender&lt;/h2&gt;&lt;form&gt; &lt;fieldset&gt; &lt;section&gt; &lt;label for=\"note\"&gt;Note&lt;/label&gt; &lt;input name=\"note\" [(ngModel)]=\"notification.note\" /&gt; &lt;/section&gt; &lt;/fieldset&gt; &lt;button (click)=\"send()\"&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;a [routerLink]=\"['../receiver']\"&gt;Go to receiver&lt;/a&gt;La parte interesante está en el controlador. Dependencia y uso del servicio del almacén de notificaciones1234567891011export class SenderComponent implements OnInit &#123; public notification = &#123;note:''&#125;; constructor(private notificationsStore: NotificationsStoreService) &#123;&#125; ngOnInit() &#123;&#125; public send() &#123; this.notificationsStore.dispatch(this.notification.note); &#125;&#125;RecepciónLa recepción es igual de sencilla. En la vista pondremos un listado de notificaciones que se alimenta de un array emitido por un observable.1234567&lt;h2&gt; Notes receiver&lt;/h2&gt;&lt;ul&gt; &lt;li *ngFor=\"let notification of notifications$ | async\"&gt;&#123;&#123; notification | json &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;a [routerLink]=\"['../sender']\"&gt;Go to sender&lt;/a&gt;Y en el controlador reclamamos la misma dependencia para el uso del servicio del almacén de notificaciones.123456789export class ReceiverComponent implements OnInit &#123; public notifications$; constructor(private notificationsStore: NotificationsStoreService) &#123;&#125; ngOnInit() &#123; this.notifications$ = this.notificationsStore.select$(); &#125;&#125;Es importante recalcar que no importa el orden de suscripción. Estos dos componentes podrían vivir en módulos distintos, verse en la misma página o inicializarse en cualquier orden… El receptor se entera siempre de todos los cambios; y además recibe el último estado conocido nada más suscribirse.2. Interceptores para gestionar erroresHemos conocido a los interceptores y vemos su potencial para manipular las respuestas de una API. Quizá uno de los usos más frecuentes se el de centralizar la gestión de errores. Veamos como hacerlo usando el conocimiento de los observables.Para empezar hay que generar un servicio…1ng g s notifications/errorInterceptorluego hay que hacerle cumplir la interfaz HttpInterceptor…12345678export class ErrorInterceptorService implements HttpInterceptor &#123; constructor() &#123;&#125; public intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) : Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; return next.handle(req); &#125;&#125;y para finalizar lo proveemos hacia el HttpClient invirtiendo el control.1234567891011121314151617@NgModule(&#123; declarations: [SenderComponent, ReceiverComponent], imports: [ CommonModule, NotificationsRoutingModule, HttpClientModule, FormsModule ], providers: [ &#123; provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptorService, multi: true &#125; ]&#125;)export class NotificationsModule &#123;&#125;2.1 El operador catchErrorVolvemos a los observables y los operadores canalizables en .pipe(). Durante su ejecución un stream de observables puede emitir valores correctos, una señal de finalización… y cómo no, errores. El método .subscribe(ok, err, end) y operadores como .map(ok, err, end) admiten hasta tres callbacks que se llamarán según los tipos de sucesos descritos. Pero para tratar el caso concreto de los errores vamos a ver el operador catchError().Por ejemplo durante la intercepción de respuestas podemos realizar una función específica al recibir un código de error. Dadas estas tres alternativas, escogeremos según la intención o la tecnología que más nos guste.12345678public intercept(req, next) &#123; // implementación con .tap() return next.handle(req).pipe(tap(null, err=&gt;console.log(err))); // implementación con catchError retornando nulo return next.handle(req).pipe(catchError(err =&gt; of(null))); // implementación con catchError re-lanzando el error return next.handle(req).pipe(catchError(err =&gt; throwError(err)));&#125;2.2 Gestión centralizada de erroresQuizás una de las más usadas sea auditar el error y reenviarlo al llamante original por si quiere hacer algo más con el mismo.1234567891011121314151617public intercept(req, next) &#123; return next.handle(req).pipe(catchError(this.handleError));&#125;private handleError(err) &#123; const unauthorized_code = 401; let userMessage = 'Fatal error'; if (err instanceof HttpErrorResponse) &#123; if (err.status === unauthorized_code) &#123; userMessage = 'Authorization needed'; &#125; else &#123; userMessage = 'Comunications error'; &#125; &#125; console.log(userMessage); return throwError(err);&#125;Pero aún mejor que solo escribir en el log, sería avisar al usuario; ¿pero dónde y cómo?3. Un notificador de problemasLa idea es usar el NotificationsStoreService desde el interceptor para… en fin, notificar que ha habido un error.3.1 Emisión mediante el Store1234567891011121314// dependencia en el constructorconstructor(private notificationsStore: NotificationsStoreService) &#123;&#125;public intercept(req, next) &#123; // Ojo al .bind(this), necesario para no perder el contexto return next.handle(req).pipe(catchError(this.handleError.bind(this)));&#125;private handleError(err) &#123; let userMessage = 'Fatal error'; // emisión de la notificación this.notificationsStoreService.dispatch(&#123; note: userMessage &#125;); return throwError(err);&#125;3.2 Recepción desacoplada del interceptorY ahora ya sólo queda suscribirse a los eventos y mostrarlos al usuario. Por ejemplo, desde el ReceiverComponent, podemos lanzar llamadas que sabemos que darán problemas y esperar pacientemente el fallo para mostrarlo al usuario.1&lt;button (click)=\"forceError()\"&gt;Force http Error&lt;/button&gt;123456public forceError() &#123; const privateUrl = 'https://api-base.herokuapp.com/api/priv/secrets'; this.httpClient.get(privateUrl).subscribe(); const notFoundUrl = 'https://api-base.herokuapp.com/api/pub/items/9'; this.httpClient.get(notFoundUrl).subscribe();&#125;Tenemos ahora a nuestro usuario puntualmente informado de todo lo que sucede. Hemos utilizado patrones de arquitectura de software como el observable y la inversión del control. El resultado es una serie de componentes y servicios poco acoplados que intercambian información en tiempo real.Pero hay temas más avanzados con los que continuar. Sigue esta serie para introducir más temas de seguridad y crear tus formularios reactivos con Angular mientras aprendes a programar con Angular. Todos esos detalles se tratan en el curso básico online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Observables","slug":"Observables","permalink":"https://academia-binaria.com/tag/Observables/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"http","slug":"http","permalink":"https://academia-binaria.com/tag/http/"}]},{"title":"Comunicaciones http en Angular","slug":"comunicaciones-http-en-Angular","date":"2019-02-28T13:06:00.000Z","updated":"2019-10-09T10:45:38.704Z","comments":true,"path":"comunicaciones-http-en-Angular/","link":"","permalink":"https://academia-binaria.com/comunicaciones-http-en-Angular/","excerpt":"Las comunicaciones http son una pieza fundamental del desarrollo web, y en Angular siempre han sido potentes y fáciles. ¿Siempre?, bueno cuando apareció Angular 2 echábamos en falta algunas cosillas… y además la librería RxJS y sus streams son intimidantes para los novatos.Pero en la versión Angular 8 consumir un servicio REST puede ser cosa de niños si aprendes a jugar con los observables y los servicios de la librería @angular/common/http. Conseguirás realizar comunicaciones http asíncronas en Angular.","text":"Las comunicaciones http son una pieza fundamental del desarrollo web, y en Angular siempre han sido potentes y fáciles. ¿Siempre?, bueno cuando apareció Angular 2 echábamos en falta algunas cosillas… y además la librería RxJS y sus streams son intimidantes para los novatos.Pero en la versión Angular 8 consumir un servicio REST puede ser cosa de niños si aprendes a jugar con los observables y los servicios de la librería @angular/common/http. Conseguirás realizar comunicaciones http asíncronas en Angular.Partiendo de la aplicación tal como quedó en Servicios inyectables en Angular. Al finalizar tendrás una aplicación que almacena y recupera los datos consumiendo un servicio REST usando las tecnologías de Angular Http.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-basic/6-httpTienes una versión desplegada operativa para probar Angular Basic1. El servicio HttpClientComo demostración vamos a consumir un API pública con datos de cotización de monedas. Crearé un módulo y un componente en el que visualizar las divisas y después las transformaremos para guardarlas en un servicio propio.12ng g m 6-http/rates --routing trueng g c 6-http/rates/rates1.1 Importación y declaración de serviciosLa librería @angular/common/http trae el módulo HttpClientModule con el servicio inyectable HttpClient. Lo primero es importar dicho módulo.1234567import &#123; HttpClientModule &#125; from '@angular/common/http';@NgModule(&#123; declarations: [RatesComponent], imports: [HttpClientModule]&#125;)export class RatesModule &#123; &#125;En tu componente tienes que reclamar la dependencia al servicio para poder usarla. Atención a la importación pues hay más clases con el nombre HttpClient. Debe quedar algo así:12345678910111213import &#123; HttpClient &#125; from '@angular/common/http';import &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-rates', templateUrl: './rates.component.html', styles: []&#125;)export class RatesComponent implements OnInit &#123; constructor(private httpClient: HttpClient) &#123;&#125; ngOnInit() &#123;&#125;&#125;A partir de este momento sólo queda invocar los métodos REST en la propiedad this.http.1.2 Obtención de datosPara cada verbo http tenemos su método en el servicio HttpClient. Su primer parámetro será la url a la que invocar. Empecemos por el get que automáticamente solicita y devuelve objetos JSON desde un API. Por ejemplo para obtener las últimas cotizaciones de las principales divisas lo haremos así:12345678910111213141516171819export class RatesComponent implements OnInit &#123; private urlapi = 'https://api.exchangeratesapi.io/latest'; public currentEuroRates: any = null; constructor(private httpClient: HttpClient) &#123;&#125; ngOnInit() &#123; this.getCurrentEuroRates(); &#125; private getCurrentEuroRates() &#123; const currencies = 'USD,GBP,CHF,JPY'; const url = `$&#123;this.urlapi&#125;?symbols=$&#123;currencies&#125;`; this.httpClient .get(url) .subscribe(apiData =&gt; (this.currentEuroRates = apiData)); &#125;&#125;El método get retorna un objeto observable. Los observables http han de consumirse mediante el método subscribe para que realmente se lancen. Dicho método subscribe admite hasta tres callbacks: susbcribe(data, err, end) para que se ejecuten en respuesta a eventos. En este ejemplo solo hemos usado el primero.La presentación en la vista sólo tiene que acceder a la propiedad dónde se hayan cargado las respuestas tratadas en el callback de la suscripción.123&lt;h2&gt; Currency Rates. &lt;/h2&gt;&lt;h3&gt; From Euro to the world &lt;/h3&gt;&lt;pre&gt;&#123;&#123; currentEuroRates | json &#125;&#125;&lt;/pre&gt;1.3 Envío de datosSupongamos que, una vez recibidas las cotizaciones, pretendemos transformarlas y almacenarlas en otro servicio. Por ejemplo un objeto para cada día y moneda. El envío en este caso será con el método post al que se le pasará la ruta del end point y el objeto payload que se enviará al servidor.Vamos a agregar una propiedad y un par de métodos al rates-component.ts. La idea es obtener un array de cotizaciones aa partir del objeto previo, y guardarla una por una.123456789101112131415161718192021export class RatesComponent implements OnInit &#123; private ratesByDateApi = 'https://api-base.herokuapp.com/api/pub/rates'; public postRatesByDate() &#123; const ratesByDate: RateByDate[] = this.transformExchangeRates(); ratesByDate.forEach(rate =&gt; this.httpClient.post&lt;RateByDate&gt;(this.ratesByDateApi, rate).subscribe() ); &#125; private transformExchangeRates(): RateByDate[] &#123; const currentDate = this.currentEuroRates.date; const currentRates = this.currentEuroRates.rates; const ratesByDate = Object.keys(currentRates).map((keyRate: string) =&gt; (&#123; date: currentDate, currency: keyRate, euros: currentRates[keyRate] &#125;)); return ratesByDate; &#125;&#125;Atención a los métodos subscribe(). Aunque vayan vacíos son imprescindibles para que se ejecute la llamada.En la vista no hay gran cosa que hacer, salvo agregarle un botón para iniciar el proceso:1&lt;input value=\"Save Rates\" type=\"button\" (click)=\"postRatesByDate()\" /&gt;1.4 Actualización de datosUn par de ejemplo más para acabar de entender la mecánica básica de HttpClient. Podemos fijar el tipo de datos esperado en cualquier llamada. De hecho es recomendable que tengas un interfaz para cada respuesta esperada.En este tutorial no se ha hecho y no quedamos con el any, pero al menos distinguimos entre objetos y arrays. Esto es lo que añado al RatesComponent para que muestre los datos guardados en mi API.1234567891011export class RatesComponent implements OnInit &#123; private ratesByDateApi = 'https://api-base.herokuapp.com/api/pub/rates'; public ratesByDate: RateByDate[] = null; public getRatesByDate() &#123; this.httpClient .get&lt;RateByDate[]&gt;(this.ratesByDateApi) .subscribe(apiResult =&gt; (this.ratesByDate = apiResult)); &#125;&#125;Y en la vista, un nuevo botón y una nueva expresión.12&lt;input value=\"Refresh\" type=\"button\" (click)=\"getRatesByDate()\" /&gt;&lt;pre&gt;&#123;&#123; myRates | json &#125;&#125;&lt;/pre&gt;Por último, en plan repaso, un ejemplo de método para borrar.123public deleteRatesByDate() &#123; this.httpClient.delete(this.ratesByDateApi).subscribe();&#125;Y su botón en en la vista.1&lt;input value=\"Delete Rates\" type=\"button\" (click)=\"deleteRatesByDate()\" /&gt;Y hasta aquí lo básico de comunicaciones http. ¿Fácil verdad?. Pero la vida real raramente es tan sencilla. Si quieres enfrentarte a algo más duro debes prepararte y dominar los observables RxJS.Lo que viene a partir de ahora requerirá tiempo y concentración. Si continúas adelante esto ya no será your grandpa´s http anymore.2 ObservablesLas comunicaciones entre navegadores y servidores son varios órdenes de magnitud más lentas que las operaciones en memoria. Por tanto deben realizarse de manera asíncrona para garantizar una buena experiencia al usuario.Esta experiencia no siempre fue tan buena para el programador. Sobre todo con las primeras comunicaciones AJAX basadas en el paso de funciones callback. La aparición de las promises mejoró la claridad del código, y ahora con los Observables tenemos además una gran potencia para manipular la información asíncrona.El patrón Observable fue implementado por Microsoft en la librería Reactive Extensions más conocida como RxJs. El equipo de Angular decidió utilizarla para el desarrollo de las comunicaciones asíncronas. Esta extensa librería puede resultar intimidante en un primer vistazo. Pero con muy poco conocimiento puedes programar casi todas las funcionalidades que se te ocurran.Lo primero es importar el código, de forma similar a cualquier otra clase o función. Por ejemplo para empezar basta con import { Observable } from &quot;rxjs/Observable&quot;;. Tendremos la clase usada por angular para observar el respuesta http.Pero esta es una clase genérica donde sus instancias admiten la manipulación interna de tipos más o menos concretos. Por eso ves en el ejemplo que algunas funciones retornan el tipo esperado : Observable&lt;MyClass&gt;, o si no saben que tipo esperar se conforman con : Observable&lt;any&gt;.En cualquier caso, toda operación asíncrona retornará una instancia observable a la cual habrá que subscribirse para recibir los datos o los errores, cuando termine.Aunque a veces no se verá el subscribe…2.1 AsyncPara probar otras formas de presentar datos recibidos desde un API, voy a crear un nuevo componente. El ObseratesComponent, mezcla de observables y rates.1ng g c 6-http/rates/obseratesY en su vista HTML usaré una función propia de Angular llamada async. Dicha función actúa como un pipe en una expresión. Igual que el | json. Pero a su izquierda espera que le den algo a lo que suscribirse; espera un observable.123&lt;h2&gt; Currency Observable Rates. &lt;/h2&gt;&lt;h3&gt; From Euro to the $ world &lt;/h3&gt;&lt;pre&gt;&#123;&#123; currentEuroRates$ | async | json &#125;&#125;&lt;/pre&gt;&#125;En este caso uso la propiedad currentEuroRates$ finalizada en $ por convenio. Esa propiedad se rellena en el controlador con el método get, no con los datos futuros, si no con el propio observable.123456789101112131415private ratesApi = 'https://api.exchangeratesapi.io/latest';public currentEuroRates$: Observable&lt;any&gt; = null;constructor(private httpClient: HttpClient) &#123;&#125;ngOnInit() &#123; this.getCurrentEuroRates();&#125;private getCurrentEuroRates() &#123; const currencies = 'USD,GBP,CHF,JPY'; const url = `$&#123;this.ratesApi&#125;?symbols=$&#123;currencies&#125;`; this.currentEuroRates$ = this.httpClient.get(url);&#125;Al utilizar el pipe async ya no es necesaria la suscripción en código. La propia función del framework se ocupa de ello. Por tanto la llamada se realiza igualmente aunque no veamos la suscripción.Esta es la manera recomendada de consumir datos desde un API. Definir la llamada en el controlador y pasarle el observable a la vista para que lo muestre cuando obtenga los datos.2.2 PipeTuberías en RxJS .pipe()Los datos devueltos raramente vienen en el formato preciso para usar en la vista. Con frecuencia hay que transformarlos al vuelo en cuanto se reciben. Recordemos que HttpClient no devuelve los datos tal cual sino un stream de estados de dichos datos. La manipulación será sobre el stream no directamente sobre los datos; y, claro, para manipular un torrente hay que encauzarlo en tuberías.Aquí es donde aparece el método .pipe(operator1, operator2...) aplicado a un observable. Suele hacerse en lugar, o antes, del .susbcribe(okCallback, errCallback). Este método canaliza una serie de operadores predefinidos que manipulan el chorro de estados observados.El operador más utilizado es map(sourceStream =&gt; targetStream). Este operador recibe una función callBack que será invocada ante cada dato recibido. Esa función tienen que retornar un valor para sustituir al actual y así transformar el contenido del chorro.12345678910111213141516public myRates$: Observable&lt;MyRate[]&gt; = null;private getCurrentEuroRates() &#123; const url = `$&#123;this.ratesApi&#125;?symbols=USD,GBP,CHF,JPY`; this.currentEuroRates$ = this.httpClient.get&lt;ExchangeRates&gt;(url); this.ratesByDate$ = this.currentEuroRates$.pipe(map(this.transformData));&#125;private transformData(exchangeRates: ExchangeRates): RateByDate[] &#123; const currentDate = exchangeRates.date; const currentRates = exchangeRates.rates; const ratesByDate = Object.keys(currentRates).map((keyRate: string) =&gt; (&#123; date: currentDate, currency: keyRate, euros: currentRates[keyRate] &#125;)); return ratesByDate;&#125;En este ejemplo partimos de nuevo de un objeto recibido y lo queremos ver como un array de objetos. Para ello lo transformamos usado el operador map. Este operador ha de importarse de rxjs/operators y aplicarse a un observable dentro de su método .pipe(). Es el más sencillo y uno de los más utilizados: recibe y emite datos dentro de un stream de eventos observables. Nada que ver, salvo el nombre, con la sencilla función array.map(callback), que recibe y devuelve datos estáticos.1&lt;pre&gt;&#123;&#123; ratesByDate$ | async | json &#125;&#125;&lt;/pre&gt;Por lo demás el consumo se hace igual… pero… tendremos que ver más operadores para solucionar algunos inconvenientes.2.3 OperatorsEl código anterior funciona, pero resulta que al haber dos funciones async suscritas provoca que la llamada original se realice dos veces. esto es así porque el segundo observable ratesByDate$ es una canalización del primero currentEuroRates$.Estos y oros problemas se solucionan usando operadores. Vamos a conocer un par de ellos más y veremos como pipe(op1, op2, opn) los ejecuta a todos en orden.El operador share() permite compartir el resultado de una primera llamada con subsiguientes suscriptores. Evitando de ese modo la repetición de costosas peticiones http.1234567891011private getCurrentEuroRates() &#123;const url = `$&#123;this.ratesApi&#125;?symbols=USD,GBP,CHF,JPY`; this.currentEuroRates$ = this.httpClient.get(url) .pipe(share()); this.ratesByDate$ = this.currentEuroRates$ .pipe( tap(d=&gt;console.log(d)), map(this.transformData), tap(t=&gt;console.log(t)) );&#125;El operador tap(callback) es similar en nombre al map(). Pero la gran diferencia es que está pensado para no manipular los datos que recibe. Los usa y puede causar otros efectos colaterales, pero nunca modifica el propio stream. Es muy utilizado para inspeccionar o auditar el flujo de otros operadores.Reconozco que en un primer vistazo este código pueda resultar complejo. Tómate tu tiempo. Fíjate en los datos de entrada y salida de cada función. Esto es solo el principio del trabajo con la librería RxJS y la manipulación de streams de eventos observables.3. InterceptoresLos interceptores tienen un nombre intimidante pero un propósito sencillo y muy útil: interceptar todas las comunicaciones http y ejecutar código personalizado para cada uno. Por ejemplo un gestor centralizado de errores http o el control de los tokens de seguridad de la aplicación.Pero antes de eso habrá que aprender unos conceptos básicos. Vamos a ver un ejemplo sencillo que audite todas las llamadas http. Todo empieza con un servicio:1ng g s rates/AuditInterceptor3.1 La interfaz HttpInterceptorAl servicio genérico recién creado hay que hacerle cumplir una interfaz HttpInterceptor que viene con HttpClientModule. Esta interfaz solo necesita un método, el intercept(req, next) pero sus tipos e implementación mínima la hacen complicada de entender a la primera.12345678910111213141516import &#123; HttpEvent, HttpHandler, HttpInterceptor, HttpRequest &#125; from '@angular/common/http';import &#123; Injectable &#125; from '@angular/core';import &#123; Observable &#125; from 'rxjs';@Injectable(&#123; providedIn: 'root'&#125;)export class AuditInterceptorService implements HttpInterceptor &#123; public intercept( req: HttpRequest&lt;any&gt;, next: HttpHandler ) : Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; return next.handle(req); &#125; constructor() &#123; &#125;&#125;Todo este código para nada. Porque eso es lo que hace, nada. Eso sí, tampoco rompe ni bloquea nada. Vayamos por partes, primero los parámetros, luego el tipo de la respuesta y por último la implementaciónreq: HttpRequest&lt;any&gt; puntero a la petición en cursonext: HttpHandler puntero a la siguiente función que maneje la petición: Observable&lt;HttpEvent&lt;any&gt;&gt; retornamos un stream de eventos http para cada peticiónreturn next.handle(req); que el siguiente procese la petición, sin hacerle nada en absolutoPara entenderlo mejor puede ser útil la siguiente analogía. Cuando usas httpClient.get() es como si pides algo a Amazon y te suscribes, es decir esperas el paquete. Pasado el tiempo el paquete llegará o no llegará, pero ya no lo gestionas tú. Con los interceptores es como si espiases cada proceso de tu pedido: stock, picking, packaging, shipping… Cada pedido es tratado en una sucesión de eventos. Con un interceptor observas !todos los eventos de todos los pedidos!3.2 Inversión del control vía tokenTenemos un servicio que cumple una interfaz compleja. Pero dicho servicio debe ser proveído en algún módulo antes de ser reclamado como dependencias por alguien. Pero ¿por quién?Técnicamente lo necesita el propio HttpClient del framework. Pero, obviamente, no pueden reclamar por tipo una clase que acabo de inventarme yo. Adelante con la inversión del control.Realmente HttpClient depende de algo que por convenio llaman token de tipo HTTP_INTERCEPTORS. Nuestro trabajo consiste en que cuando reclame su dependencia, le demos la nuestra. El típico gato por liebre. Así en nuestro módulo pondremos la siguiente configuración.1234567providers: [ &#123; provide: HTTP_INTERCEPTORS, useClass: AuditInterceptorService, multi: true &#125;]El parámetro multi:true en este caso le indica que puede haber más de un interceptor. Concretamente debe añadirlo a la lista y admitir más. Hecho esto, sobraría el providedIn: &#39;root&#39; autogenerado en el decorador del servicio.3.3 Un auditor de llamadasPues ya estamos listos para aportar algo de funcionalidad. Nuestro objetivo es escribir en el log un texto para cada llamada terminada y el tiempo que le tomó. La idea es aprovechar que todo es un stream observable y canalizarlo en una tubería con una serie de operadores.123456789101112131415161718export class AuditInterceptorService implements HttpInterceptor &#123; constructor() &#123;&#125; public intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler)&#123; const started = Date.now(); return next.handle(req).pipe( filter((event: HttpEvent&lt;any&gt;) =&gt; event instanceof HttpResponse), tap((resp: HttpResponse&lt;any&gt;) =&gt; this.auditEvent(resp, started)) ); &#125; private auditEvent(resp: HttpResponse&lt;any&gt;, started: number) &#123; const elapsedMs = Date.now() - started; const eventMessage = resp.statusText + ' on ' + resp.url; const message = eventMessage + ' in ' + elapsedMs + 'ms'; console.log(message); &#125;&#125;El operador filter(any=&gt;bool) se usa para descartar eventos que no cumplan unos criterios. En mi caso sólo me interesan los eventos de recepción de la petición, y no necesito los intermedios. Uso de nuevo el tap(callback) para hacer cosas con los datos sin modificarlos en absoluto. En este caso los envío al método auditEvent para que lo saque por consola. Listo: un auditor para todas las llamadas.Ya tenemos el programa comunicado por http con un servidor; aunque por ahora de forma anónima y sin ninguna seguridad. Con el conocimiento actual de los observables, del httpClient y de los interceptores ya estamos cerca de resolverlo. Sigue esta serie para añadirle vigilancia y seguridad en Angular mientras aprendes a programar con Angular. Todos esos detalles se tratan en el curso básico online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Observables","slug":"Observables","permalink":"https://academia-binaria.com/tag/Observables/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"http","slug":"http","permalink":"https://academia-binaria.com/tag/http/"},{"name":"RxJS","slug":"RxJS","permalink":"https://academia-binaria.com/tag/RxJS/"}]},{"title":"Servicios inyectables en Angular","slug":"servicios-inyectables-en-Angular","date":"2019-02-15T08:54:58.000Z","updated":"2019-10-09T10:45:38.705Z","comments":true,"path":"servicios-inyectables-en-Angular/","link":"","permalink":"https://academia-binaria.com/servicios-inyectables-en-Angular/","excerpt":"La presentación, la lógica y el manejo de datos son tres capas de abstracción que usamos los programadores para mantener organizado nuestro código. En Angular, la presentación es cosa de los componentes. La lógica y los datos tienen su lugar en servicios compartidos.Para que los componentes consuman los servicios de forma controlada tenemos proveedores inyectables en la librería @angular/core con los que realizar la inyección de dependencias.","text":"La presentación, la lógica y el manejo de datos son tres capas de abstracción que usamos los programadores para mantener organizado nuestro código. En Angular, la presentación es cosa de los componentes. La lógica y los datos tienen su lugar en servicios compartidos.Para que los componentes consuman los servicios de forma controlada tenemos proveedores inyectables en la librería @angular/core con los que realizar la inyección de dependencias.Partiendo de la aplicación tal como quedó en Flujo de datos entre componentes Angular. Al finalizar tendrás una aplicación que comunica componentes entre páginas, reparte responsabilidades y gestiona claramente sus dependencias.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-basic/5-injectTienes una versión desplegada operativa para probar Angular Basic1. Inyección de dependenciasComo casi todo en Angular, los servicios son clases TypeScript. Su propósito es contener lógica de negocio, clases para acceso a datos o utilidades de infraestructura. Estas clases son perfectamente instanciables desde cualquier otro fichero que las importe. Pero Angular nos sugiere y facilita que usemos su sistema de inyección de dependencias.Este sistema se basa en convenios y configuraciones que controlan la instancia concreta que será inyectada al objeto dependiente. Ahora verás cómo funciona la Dependency Injection en Angular.Como demostración vamos a trabajar con un par de utilidades para conversión de unidades. Crearé un módulo y un componente en el que visualizarlo.12ng g m 5-inject/converter --routing trueng g c 5-inject/converter/converter1.1 Generación de serviciosLa particularidad de las clases de servicios está en su decorador: @Injectable(). Esta función viene en el @angular/core e indica que esta clase puede ser inyectada dinámicamente a quien la demande. Aunque es muy sencillo crearlos a mano, el CLI nos ofrece su comando especializado para crear servicios. Estos son ejemplos de instrucciones para crear un service.1ng g s 5-inject/converter/calculatorEl resultado es el fichero calculator.service.ts con su decorador que toma una class normal y produce algo injectable. Veamos una implementación mínima:12345678910import &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root',&#125;)export class CalculatorService &#123; constructor() &#123;&#125; public fromKilometersToMiles = kilometers =&gt; kilometers * 0.62137;&#125;Ahora tienes centralizado en este servicio la lógica de datos que tenemos hasta el momento. Los demás componentes la podrán utilizar.1.2 Consumo de dependenciasDeclarar y decorar la clase no es suficiente para poder reclamarla. Necesitas registrarla como un proveedor en algún módulo. Desde Angular 6 los servicios se auto-proveen en el módulo raíz mediante la configuración providedIn: &#39;root&#39; de su decorador.Esto es útil y cómodo en una gran cantidad de casos. El módulo raíz es visible para toda la aplicación de forma que cualquier componente puede reclamar un servicio suyo sin problema. Excepto que el problema sea el tamaño. El módulo raíz se carga al arrancar y todas sus referencias van el bundle principal. Si queremos repartir el peso debemos llevar ciertos servicios al módulo funcional que los necesite.Vamos a consumir este servicio en el converter.component.ts. Al consumo de los servicios inyectables se le conoce como dependencia. Cada componente o servicio puede declarar en su constructor sus dependencias hacia servicios inyectables. El convenio exige que se especifique el tipo esperado1234567891011121314export class ConverterComponent implements OnInit &#123; public kilometers = 0; public miles: number; constructor(private calculatorService: CalculatorService) &#123;&#125; public ngOnInit() &#123; this.convert(); &#125; public convert() &#123; this.miles = this.calculatorService.fromKilometersToMiles(this.kilometers); &#125;&#125;Agregar el modificador de alcance private o public en la declaración de argumentos hace que TypeScript genere una propiedad inicializada con el valor recibido. Es azúcar sintáctico para no tener que declarar la propiedad y asignarle el valor del argumento manualmente. En resumen, los constructores en TypeScrip admiten argumentos que transforman en propiedades. Mantenemos privado el converterService para evitar su uso desde la vista.1234567891011121314&lt;h2&gt;Distance Converter.&lt;/h2&gt;&lt;h3&gt;From Europe to USA&lt;/h3&gt;&lt;form&gt; &lt;fieldset&gt; &lt;section&gt; &lt;label for=\"kilometers\"&gt;Kilometers&lt;/label&gt; &lt;input name=\"kilometers\" type=\"number\" [(ngModel)]=\"kilometers\" placeholder=\"0\" /&gt; &lt;/section&gt; &lt;/fieldset&gt; &lt;input value=\"Convert\" type=\"button\" (click)=\"convert()\" /&gt;&lt;/form&gt;&lt;section&gt; &lt;h4&gt;&#123;&#123; miles | number:'1.2-2' &#125;&#125; miles&lt;/h4&gt;&lt;/section&gt;2. Inversión del controlUn concepto íntimamente relacionado con la inyección de dependencias es el de Inversion of Control. El componente dependiente expresa sus necesidades, pero es el framework el que en última instancia decide lo que recibirá. Vemos entonces que el invocado cede el control al invocador.Cuando proveemos un servicio en Angular, el comportamiento por defecto es el de proveer un singleton pero hay más opciones. Si se usa el objeto provider con useClass , useValue y useFactory podemos controlar el proceso de inyección.Se crea un singleton por cada módulo en el que se provea un servicio. Normalmente si el servicio es para un sólo módulo funcional se provee en este y nada más. Si va a ser compartido gana la opción de auto proveerlo en el raíz, garantizando así su disponibilidad en cualquier otro módulo de la aplicación.En un módulo cualquiera, siempre podríamos agregar un servicio a su array de providers.12345@NgModule(&#123; declarations: [...], imports: [...], providers: [ CalculatorService ]&#125;)Pero siempre será una instancia única por módulo. Si un singleton no es lo adecuado, entonces puedes proveer el mismo servicio en distintos módulos. De esa forma se creará una instancia distinta para cada uno. Si se provee la misma clase en dos o más módulos se genera una instancia en cada uno de ellos. Los componentes recibirán la instancia del módulo jerárquicamente más cercano.Incluso es posible usar el array providers:[] en la decoración de un componente o de otro servicio. Haciendo así aún más granular la elección de instancia.Veamos un ejemplo extendiendo el problema del conversor de unidades de forma que se pueda escoger una estrategia de conversión en base a una cultura concreta. Para empezar necesitamos una interfaz, un servicio base que la implemente y un componente que lo consuma.123ng g interface 5-inject/converter/i-culture-converterng g service 5-inject/converter/culture-converterng g component 5-inject/converter/culture-converter123456export interface ICultureConverter &#123; sourceCulture: string; targetCulture: string; convertDistance: (source: number) =&gt; number; convertTemperature: (source: number) =&gt; number;&#125;12345678export abstract class CultureConverterService implements ICultureConverter &#123; sourceCulture: string; targetCulture: string; convertDistance: (source: number) =&gt; number; convertTemperature: (source: number) =&gt; number; constructor() &#123;&#125;&#125;1234567891011121314151617export class CultureConverterComponent implements OnInit &#123; public source: string; public target: string; public sourceUnits = 0; public targetUnits: number; constructor(private cultureConverterService:CultureConverterService)&#123; &#125; public ngOnInit() &#123; this.source = this.cultureConverterService.sourceCulture; this.target = this.cultureConverterService.targetCulture; this.convert(); &#125; public convert() &#123; this.targetUnits = this.cultureConverterService.convertDistance(this.sourceUnits); &#125;&#125;1234567891011121314&lt;h2&gt;Culture Converter.&lt;/h2&gt;&lt;h3&gt;From &#123;&#123; source &#125;&#125; to &#123;&#123; target &#125;&#125;&lt;/h3&gt;&lt;form&gt; &lt;fieldset&gt; &lt;section&gt; &lt;label for=\"sourceUnits\"&gt;Distance&lt;/label&gt; &lt;input name=\"sourceUnits\" type=\"number\" [(ngModel)]=\"sourceUnits\" placeholder=\"0\" /&gt; &lt;/section&gt; &lt;/fieldset&gt; &lt;input value=\"Convert\" type=\"button\" (click)=\"convert()\" /&gt;&lt;/form&gt;&lt;section&gt; &lt;h4&gt;Distance &#123;&#123; targetUnits | number:'1.2-2' &#125;&#125;&lt;/h4&gt;&lt;/section&gt;2.2 ImplementacionesEl CultureConverterComponent depende de CultureConverterService el cual implementa de forma abstracta la interfaz CultureConverter. Pero eso no es para nada funcional. Vamos a crear dos implementaciones específicas para Europa y USA. Estas clases concretas se apoyarán en el anteriormente creado CalculatorService que necesita algo más de código.12345678export class CalculatorService &#123; constructor() &#123;&#125; public fromKilometersToMiles = kilometers =&gt; kilometers * 0.62137; public fromMilesToKilometers = miles =&gt; miles * 1.609; public fromCelsiusToFarenheit = celsius =&gt; celsius * (9 / 5) + 32; public fromFarenheitToCelsius = farenheit =&gt; (farenheit - 32) * (5 / 9);&#125;Y aquí están las dos servicios concretos.12345678910@Injectable()export class EuropeConverterService implements ICultureConverter &#123; sourceCulture = 'USA'; targetCulture = 'Europe'; constructor(private converterService: CalculatorService) &#123;&#125; public convertDistance = this.converterService.fromMilesToKilometers; public convertTemperature = this.converterService.fromFahrenheitToCelsius;&#125;12345678910@Injectable()export class UsaConverterService implements ICultureConverter &#123; sourceCulture = 'Europe'; targetCulture = 'USA'; constructor(private converterService: CalculatorService) &#123;&#125; public convertDistance = this.converterService.fromKilometersToMiles; public convertTemperature = this.converterService.fromCelsiusToFahrenheit;&#125;2.3 Provisión manualPor ejemplo si queremos utilizar la implementación concreta de USA lo indicamos en el módulo que lo consuma.12345678&#123; providers: [ &#123; provide: CultureConverterService, useClass: UsaConverterService, &#125;, ];&#125;El componente reclama una instancia de CultureConverterService y le damos otra con la misma interfaz. De esta forma podríamos tener módulos distintos, cada uno con su propia estrategia de conversión.2.4 FactoríaUna situación muy común es poder elegir dinámicamente la implementación concreta. Para ello necesitamos una función factoría que con alguna lógica escoja la estrategia concreta.12345678910111213141516const cultureFactory = (converterService: ConverterService) =&gt; &#123; if (environment.unitsCulture === 'metric') &#123; return new EuropeConverterService(converterService); &#125; else &#123; return new UsaConverterService(converterService); &#125;&#125;;&#123; providers: [ &#123; provide: CultureConverterService, useFactory: cultureFactory, deps: [CalculatorService], &#125;, ];&#125;De esta forma la aplicación se comportará distinto en función de una variable de entorno.Ya tenemos la aplicación mucho mejor estructurada, pero el almacén de datos es mejorable. Se mantienen los datos hard-coded, muy incómodo para actualizar; y en memoria, poco fiable y volátil. Lo más habitual es guardar y recuperar la información en un servidor http. Sigue esta serie para añadir Comunicaciones HTTP en Angular mientras aprendes a programar con Angular. Todos esos detalles se tratan en el curso básico online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Servicios","slug":"Servicios","permalink":"https://academia-binaria.com/tag/Servicios/"},{"name":"DI","slug":"DI","permalink":"https://academia-binaria.com/tag/DI/"}]},{"title":"Flujo de datos entre componentes Angular","slug":"flujo-de-datos-entre-componentes-angular","date":"2019-02-12T15:10:44.000Z","updated":"2019-10-09T10:45:38.703Z","comments":true,"path":"flujo-de-datos-entre-componentes-angular/","link":"","permalink":"https://academia-binaria.com/flujo-de-datos-entre-componentes-angular/","excerpt":"Los desarrollos profesionales son complicados pero con Angular tenemos soluciones de comunicación simples para pantallas complejas. Mediante el desarrollo de componentes atómicos y reutilizables Angular 8 favorece la implementación de buenas prácticas.Crear y comunicar muchos componentes puede llevarnos a código difícil de seguir. La librería @angular/forms ofrece tuberías de comunicación para mantener el flujo de datos bajo control.","text":"Los desarrollos profesionales son complicados pero con Angular tenemos soluciones de comunicación simples para pantallas complejas. Mediante el desarrollo de componentes atómicos y reutilizables Angular 8 favorece la implementación de buenas prácticas.Crear y comunicar muchos componentes puede llevarnos a código difícil de seguir. La librería @angular/forms ofrece tuberías de comunicación para mantener el flujo de datos bajo control.Partiendo de la aplicación tal como quedó en Formularios, tablas y modelos de datos en Angular. Al finalizar tendrás una aplicación que reparte la responsabilidad de recoger y presentar datos en componentes.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-basic/4-flowTienes una versión desplegada operativa para probar Angular Basic1. Comunicación entre componentesLas aplicaciones web en las que destaca Angular suelen ser complejas y con mucha variedad funcional en diversas páginas. A menudo esas páginas están repletas de formularios, informes y botones. La solución viene de mano del viejo principio divide y vencerás: La componentización1.1. Necesidad de comunicaciónEl framework permite y recomienda repartir el trabajo en múltiples componentes de responsabilidad única. También es práctica común el crear páginas específicas para situaciones concretas aunque relacionadas. Por supuesto que estructuras como el menú de navegación o secciones de estado general necesitan conocer datos provenientes de las páginas. Nada está completamente asilado. Esto nos enfrenta la problema de comunicar componentes.1.2. EscenariosLas situaciones que te encontrarás caerán en alguna de estas tres categorías para las que hay soluciones específicas.Comunicar componentes acopladosSolemos empezar creando un componente por página. Pero es normal que esa página se complique y la solución a la complejidad es la división en componentes y reparto de responsabilidades. Dado que están en una misma página existe cierto acoplamiento entre ellos y eso nos facilitará la comunicación.Comunicar componentes en páginas distintasCuando los componentes se carga en rutas distintas ya no hay forma de comunicarlos directamente. Pero lo resolveremos fácilmente usando las capacidades del router.Comunicar componentes entre estructuras dinámicasLa situación más compleja se da cuando queremos comunicar componentes o servicios desacoplados pero sin cambio de página. En este caso hará falta un mediador observable.2. El patrón Contendor / PresentadoresEn arquitectura de software cuando encontramos una solución a un problema recurrente le ponemos un nombre y tratamos de utilizarlo siempre que podemos. Obviamente es una elección del programador y siempre tiene un coste que debe valorar. En este caso la ventaja es clara: reparto de responsabilidades.2.1 El patrónEn este caso el patrón contenedor/presentadores estipula que haya un único componente responsable de obtener, mutar y guardar el estado. Será el componente contenedor. Los presentadores serán responsables de.. ejem, presentar la información y los elementos de interacción con el usuario. Las ventajas derivadas son: mayor facilidad para el testeo y mayores posibilidades de reutilización de presentadores.A este patrón a veces se le conoce como parent/children por la jerarquía html que genera.Veamos una implementación sencilla. Haremos una interfaz mínima para simular el manejo de un coche. Habrá pedales de aceleración y freno, y un cuadro dónde se refleje la velocidad. Para todo ello vamos a usa el Angular CLI y crear un módulo y sus componentes base.1234ng g m 4-flow/carng g c 4-flow/car/carng g c 4-flow/car/car/displayng g c 4-flow/car/car/pedalsAgregamos una ruta en el enrutador con su enlace en el menú.1234&#123; path: 'car', loadChildren: () =&gt; import('./4-flow/car/car.module').then(m =&gt; m.CarModule)&#125;123&lt;a routerLink=\"car\" class=\"button\"&gt; &lt;span&gt; 4 - Car&lt;/span&gt;&lt;/a&gt;2.2 El contenedorEn el componente contenedor tendremos una vista muy sencilla y un controlador más complejo. La vista será la composición de los componentes presentadores, pero el controlador tendrá que obtener datos, aplicarles lógica de negocio y guardarlos cuando corresponda.No es habitual asignarle un sufijo al nombre del componente para indicar que es el contenedor. Suele ser suficiente el verlo en la raíz de la jerarquía de carpetas.12345678910&lt;app-display [model]=\"car.name\" [currentSpeed]=\"car.currentSpeed\" [topSpeed]=\"car.maxSpeed\" [units]=\"'Km/h'\"&gt;&lt;/app-display&gt;&lt;app-pedals (brake)=\"onBrake($event)\" [disableBrake]=\"disableBrake\" (throttle)=\"onThrottle($event)\" [disableThrottle]=\"disableThrottle\"&gt;&lt;/app-pedals&gt;Vemos que usa los componentes presentadores Display y Pedals enviándoles información y suscribiéndose a sus eventos. Concretaremos esta funcionalidad más adelante.12345678910111213141516171819202122232425262728293031public car: CarModel;public disableBrake: boolean;public disableThrottle: boolean;constructor() &#123;&#125;public ngOnInit() &#123; this.car = &#123; name: 'Roadster', maxSpeed: 120, currentSpeed: 0 &#125;; this.checkLimits();&#125;private checkLimits() &#123; this.disableBrake = false; this.disableThrottle = false; if (this.car.currentSpeed &lt;= 0) &#123; this.car.currentSpeed = 0; this.disableBrake = true; &#125; else if (this.car.currentSpeed &gt;= this.car.maxSpeed) &#123; this.car.currentSpeed = this.car.maxSpeed; this.disableThrottle = true; &#125;&#125;public onBrake(drive: number) &#123; this.car.currentSpeed -= this.getDelta(drive); this.checkLimits();&#125;public onThrottle(drive: number) &#123; this.car.currentSpeed += this.getDelta(drive); this.checkLimits();&#125;private getDelta = (drive: number) =&gt; drive + (this.car.maxSpeed - this.car.currentSpeed) / 10;Lo dicho, la clase controladora del componente contenedor retiene el grueso de la funcionalidad. En este caso inicializar una instancia de un coche y mantener sus velocidad en los límites lógicos respondiendo a las acciones del usuario conductor.2.3 Envío hacia el presentador con @Input()Esta comunicación hacia abajo envía la información desde el contenedor hacia el presentador. Es similar a como una plantilla recibe la información desde el controlador.@Input()Para que una vista muestre datos tiene que usar directivas como asociada a una propiedad pública de la clase componente. Se supone que dicha clase es la responsable de su valor. Pero también puede recibirlo desde el exterior. La novedad es hacer que lo reciba vía html.1234567891011&lt;h2&gt; &#123;&#123; model &#125;&#125; &lt;/h2&gt;&lt;h3&gt; Top speed: &#123;&#123; topSpeed | number:'1.0-0' &#125;&#125;&lt;/h3&gt;&lt;div class=\"card\"&gt; &lt;div class=\"section\"&gt; &#123;&#123; currentSpeed | number:'1.2-2' &#125;&#125; &#123;&#123; units &#125;&#125; &lt;/div&gt; &lt;progress [value]=\"currentSpeed\" [ngClass]=\"getSpeedClass()\" [max]=\"topSpeed\"&gt; &lt;/progress&gt;&lt;/div&gt;Empieza por decorar con @Input() la propiedad que quieres usar desde fuera. Por ejemplo un código como este del archivo display.component.ts.1234567891011export class DisplayComponent implements OnInit &#123; @Input() public model: string; @Input() public currentSpeed: number; @Input() public topSpeed: number; @Input() public units: string; constructor() &#123;&#125; ngOnInit() &#123;&#125; public getSpeedClass = () =&gt; this.currentSpeed &lt; this.getThreshold() ? 'primary' : 'secondary'; private getThreshold = () =&gt; this.topSpeed * 0.8;&#125;Ahora puedes enviarle datos a este componente desde el html de su consumidor. Por ejemplo desde car.component.html le puedo enviar una variable o cualquier expresión evaluable. Recordemos como usa [propiedad]=&quot;expresion&quot; en el elemento presentador.12345&lt;app-display [model]=\"car.name\" [currentSpeed]=\"car.currentSpeed\" [topSpeed]=\"car.maxSpeed\" [units]=\"'Km/h'\"&gt;&lt;/app-display&gt;En la clase controladora del presentador quedan responsabilidades reducidas a temas específicos como determinar las clases css apropiadas o transformar los datos para su presentación.Estoy usando al componente de nivel inferior como un presentador; mientras que el contenedor superior actúa como controlador. Este mismo patrón puede y debe repetirse hasta descomponer las vistas en estructuras simples que nos eviten repeticiones absurdas en código.De esta forma es fácil crear componentes reutilizables; y queda muy limpio el envío de datos hacia abajo. Pero, ¿y hacia arriba?.2.4. Respuesta del presentador con @Output()Los componentes de nivel inferior no sólo se dedican a presentar datos, también presentan controles. Con ellos el usuario podrá crear, modificar o eliminar los datos que quiera. Aunque no directamente; para hacerlo comunican el cambio requerido al contenedor de nivel superior.@Output()Por ejemplo, el componente PedalsComponent permite acelerar y frenar. Bueno, realmente permite que el usuario diga que lo quiere hacer; los cambios se harán más arriba. Veamos lo básico del pedals.component.html antes de nada:12345678910111213&lt;h3&gt; Pedals: &lt;/h3&gt;&lt;form&gt; &lt;input value=\"brake\" class=\"secondary\" type=\"button\" [disabled]=\"disableBrake\" (click)=\"brake.emit(1)\"/&gt; &lt;input value=\"throttle\" class=\"tertiary\" type=\"button\" [disabled]=\"disableThrottle\" (click)=\"throttle.emit(1)\"/&gt;&lt;/form&gt;Claramente son un par de botones que con el evento (click) responden a acciones del usuario. En este caso se manifiesta una intención de acelerar o frenar el coche. Pero el método del controlador no actúa directamente sobre los datos.Si lo hiciera sería más difícil gestionar los cambios e imposibilitaría el uso de inmutables o técnicas más avanzadas de programación que se verán más adelante…En su lugar, lo que hace es emitir un evento confiando que alguien lo reciba y actúe en consecuencia. Por ejemplo la emisión de la instrucción de frenado se realiza mediante la propiedad brake decorada con @Output() public brake new EventEmitter&lt;number&gt;();. Dicha propiedad será una instancia de un emisor de eventos que mediante el método .next() que emite la señal hacia arriba.12345678export class PedalsComponent implements OnInit &#123; @Input() public disableBrake: boolean; @Input() public disableThrottle: boolean; @Output() public brake = new EventEmitter&lt;number&gt;(); @Output() public throttle = new EventEmitter&lt;number&gt;(); constructor() &#123;&#125; ngOnInit() &#123;&#125;&#125;Mientras tanto, en el contenedor la vista se subscribe al evento (brake) como si este fuese un evento nativo y llama a los métodos que manipulan los datos de verdad.12345&lt;app-pedals (brake)=\"onBrake($event)\" [disableBrake]=\"disableBrake\" (throttle)=\"onThrottle($event)\" [disableThrottle]=\"disableThrottle\"&gt;&lt;/app-pedals&gt;Las propiedades output también pueden enviar argumentos que serán recibidos mediante el identificador $event propio del framework. Se declaran especificando el tipo del argumento en el genérico del constructor de EventEmitter&lt;any&gt;.En el controlador ya podemos operar con los datos. El método onBrake(drive: number) accede y modifica el valor de la velocidad y lo notifica automáticamente hacia abajo.De esta manera se cierra el círculo. Los componentes de bajo nivel pueden recibir datos para ser presentados o emitir eventos para modificarlos. El componente de nivel superior es el único responsable de obtener y actuar sobre los datos.3. Comunicaciones entre páginas o estructuras3.1 Comunicación entre distintas páginasEn las aplicaciones hay comunicaciones de estado más allá de la página actual. La comunicación entre páginas es responsabilidad del @angular/router. Una vez activada una ruta, el sistema carga un componente en el &lt;router-outlet&gt; correspondiente. No hay forma de comunicarse hacia (arriba) o [abajo] con algo desconocido. De una página a otra tampoco es problema pues la comunicación va mediante los parámetros de la url.Ya hemos usado esta comunicación anteriormente en el tema 2-spa el componente AuthorComponent es capaz de recibir por parámetros una identificación de un autor. Esa información es el resultado de una acción del usuario en la pantalla /about/authors programada en el componente AuthorsComponent. Por tanto es una comunicación entre componentes, en la que ambos son controladores hermanos.Desde luego habrá que mejorar el acceso y control de los datos que por ahora es muy rudimentario. Lo haremos en próximos pasos. Primero mediante Servicios inyectables en Angular y después usando Comunicaciones HTTP en Angular2.2 Comunicación entre estructuras desacopladasEstando en la misma ruta, no siempre se podrán conocer los componentes, y por tanto no se podrán usar sus [propiedades] y (eventos)2.2.1 El layout principal y los componentes por ruta páginas.Una situación habitual es comunicar la vista de negocio activa con elementos generales de la página. Por ejemplo podrías querer mostrar la velocidad máxima alcanzada en la barra del menú o un un mensaje emergente cada vez que se alcance la velocidad límite. En este caso, el &lt;router-outlet&gt; es una barrera que impide usar el patrón contenedor-presentador pues no se puede predecir el contenido dinámico que carga el RouterOutlet.2.2.2 Múltiples niveles de presentadores.Cuando las pantallas se hacen realmente complejas empiezan a surgir árboles de componentes de muchos niveles de profundidad. En estas situaciones mantener un único controlador a nivel raíz es poco práctico. Enviar hacia abajo las [propiedades] es tedioso, pero peor aún es hacer burbujear los (eventos) por varias capas de presentadores.La solución en ambos casos pasa por permitir que algunos componentes presentadores tengan su propio control de datos. Este tipo de comunicaciones técnicamente se resuelve mediante Observables y merece un capítulo especial que se verá más adelante en esta serie. Incluso en situaciones complejas habrá que optar por patrones avanzados de gestión de estado como pueda ser Redux.Por ahora tienes una aplicación en Angular que comunica datos y cambios entre componentes de una misma página. Sigue el tutorial para añadirle Servicios inyectables en Angular mientras aprendes a programar con Angular 8. Todos esos detalles se tratan en el curso básico online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Components","slug":"Components","permalink":"https://academia-binaria.com/tag/Components/"}]},{"title":"Formularios, tablas y modelos de datos en Angular","slug":"formularios-tablas-y-modelos-de-datos-en-angular","date":"2019-01-31T18:17:37.000Z","updated":"2019-10-09T10:45:38.703Z","comments":true,"path":"formularios-tablas-y-modelos-de-datos-en-angular/","link":"","permalink":"https://academia-binaria.com/formularios-tablas-y-modelos-de-datos-en-angular/","excerpt":"Las aplicaciones Angular 8 son excelentes para el tratamiento de datos en el navegador. Su razón de ser fue la recogida de información mediante formularios y la presentación de páginas dinámicas de forma sencilla.Vamos a ver cómo la librería @angular/forms enlaza las vistas, los controladores y los modelos; y cómo se hace la presentación de datos en listas y tablas.","text":"Las aplicaciones Angular 8 son excelentes para el tratamiento de datos en el navegador. Su razón de ser fue la recogida de información mediante formularios y la presentación de páginas dinámicas de forma sencilla.Vamos a ver cómo la librería @angular/forms enlaza las vistas, los controladores y los modelos; y cómo se hace la presentación de datos en listas y tablas.Partiendo de la aplicación tal como quedó en Páginas y rutas Angular SPA, al finalizar tendrás una aplicación que recoge y presenta datos.Código asociado a este artículo en GitHub: [AcademiaBinaria/angular-basic/3-data]https://github.com/AcademiaBinaria/angular-basic/tree/master/src/app/3-data/contacts)1. Binding1.0 BaseLos formularios son el punto de entrada de información a nuestros sistemas. Llevan con nosotros desde el inicio de la propia informática y se han comido una buena parte del tiempo de programación. En Angular han prestado una especial atención a ellos facilitando su desarrollo, desde pantallas simples hasta complejos procesos.Para empezar crearemos un proceso sencillo. algo que permita mantener una lista de contactos empresariales. Con lo aprendido en el tema de Páginas y rutas Angular SPA creamos un par de ficheros.12ng g m contacts --routing trueng g c contacts/contactsY asignamos sus rutas delegadas en app-routing y en contacts-routing:12345678910// app-routing&#123; path: 'contacts', loadChildren: () =&gt; import('./3-data/contacts/contacts.module').then(m =&gt; m.ContactsModule)&#125;,// contacts-routing&#123; path: '', component: ContactsComponent&#125;Y finalizamos con un enlace en el HeaderComponent123&lt;a routerLink=\"contacts\" class=\"button\"&gt; &lt;span&gt; Contacts&lt;/span&gt;&lt;/a&gt;La clave para entender cómo funciona Angular está en el concepto de enlace entre elementos html de las vistas y propiedades de modelos de datos, el llamado binding.Para realizar el binding usaremos directivas en ambos sentidos.1.1 Enlace del modelo hacia la vistaVamos a crear un pequeño modelo de datos. Para empezar agregamos algunas propiedades. En contacts.component.ts:12345public header = 'Contacts';public description = 'Manage your contact list';public numContacts = 0;public counterClass = 'tag secondary';public formHidden = false;En contacts.component.html mostramos cabeceras con estilo1234567&lt;h2&gt;&#123;&#123; header &#125;&#125;&lt;/h2&gt;&lt;p&gt;&#123;&#123; description | uppercase &#125;&#125;&lt;/p&gt;&lt;p&gt; You have &lt;mark [class]=\"counterClass\"&gt;&#123;&#123; numContacts &#125;&#125;&lt;/mark&gt; contacts right now.&lt;/p&gt;La interpolación entre { { } }En el fichero contacts.component.ts tienes en su vista html encontrarás elementos ajenos al lenguaje. Son las directivas. La primera que encuentras es . Esas dobles llaves encierran expresiones que se evaluarán en tiempo de ejecución. La llamamos directiva de interpolación y es la manera más cómoda y usual de mostrar contenido dinámico en Angular.La expresión interna hace referencia a variables que se obtienen de las propiedades de la clase controladora del componente. En este caso ContactsComponent y header, con su valor Contacts en ejecución. Este enlace mantiene la vista permanentemente actualizada a través de un potente sistema de detección del cambio.Las tuberías |Si queremos que la presentación del dato sea distinta a su valor real, podemos usar funciones de transformación especiales. Se llaman tuberías o pipes y se indican mediante el carácter |.El framework nos provee de casos básicos como uppercase, lowercase, date, number.... También dispones de un mecanismo para crear tus propios pipes.Los atributos evaluados []En Html disponemos de atributos para asignar valores a propiedades de los elementos. Esos atributos reciben los valores como constantes. Pero, si se encierran entre corchetes se convierten en un evaluador de expresiones y puede recibir una variable o cualquier otra expresión.Como por ejemplo usando una clase css cuyo valor cambia en tiempo de ejecución. O para deshabilitar un elemento dinámicamente.1.2 Enlace de la vista hacia el modeloEn contacts.component.html también actuamos sobre la vista, para manipular el modelo… y de vuelta a la vista. Por ejemplo con mecanismo simple de ocultación de un elemento.12345&lt;input value=\"Show Form\" type=\"button\" (click)=\"formHidden = false\" /&gt;&lt;input value=\"Hide Form\" type=\"button\" (click)=\"formHidden = true\" /&gt;&lt;form [ngClass]=\"&#123; 'hidden' : formHidden &#125;\"&gt; &lt;fieldset&gt;&lt;legend&gt;Contact Form&lt;/legend&gt;&lt;/fieldset&gt;&lt;/form&gt;Las clases CSS como atributos especialesPara el caso concreto de determinar las clases CSS aplicables a un elemento de manera dinámica, usaremos la directiva ngClass. La cual recibe un objeto cuyas propiedades son nombres de clases CSS y sus valores son expresiones booleanas. Si se cumplen se aplica la clase y si no, se quita la clase.1[ngClass]=\"&#123; 'hidden' : formHidden &#125;\"En este caso se oculta el elemento dependiendo del valor de la expresión formHidden. Pero ¿Cómo se manipula esa variable?Los eventos ()Cualquier evento asociado a un elemento puede ejecutar una instrucción sin más que incluirlo entre paréntesis. Idealmente dicha instrucción debe llamar a un método o función de la clase controladora. Aunque si es trivial puedes dejarla en el Html.1(click)=\"formHidden = true\"2. Doble BindingLa comunicación del modelo hacia la vista es sólo el principio. En Angular también podrás comunicar la vista hacia el modelo, permitiéndole al usuario modificar los datos a través de formularios. Es lo que se conoce como double binding.2.1 El doble enlace al modelo [(ngModel)]La directiva [(ngModel)] se compone de un atributo custom ngModel y lo rodea de los símbolos [()]. Esta técnica es conocida como banana in a box porque su sintaxis requiere un () dentro de un [] y une las capacidades de las expresiones y los eventos facilitando la comunicación bidireccional.1[(ngModel)]=\"model.property\"Usa la comunicación en ambos sentidos(banana) : de la vista al modelo[box] : del modelo a la vistaAtención: La directiva ngModel viene dentro del módulo FormsModule que hay que importar explícitamente.Por ejemplo [(ngModel)]=&quot;contact.name&quot; enlaza doblemente la propiedad del modelo contact.name con el elemento &lt;input&gt; de la vista. Cada tecleo del usuario se registra en la variable. Y el valor de la variable se muestra en el &lt;input&gt;.Dada un modelo como este en contacts.component.ts:1public contact = &#123; name: '' &#125;;Podemos enlazarlos en la plantilla1234&lt;section&gt; &lt;label for=\"name\"&gt;Name&lt;/label&gt; &lt;input name=\"name\" type=\"text\" [(ngModel)]=\"contact.name\" placeholder=\"Contact name\" /&gt;&lt;/section&gt;Es muy útil mantener en desarrollo un espía visual de lo que está pasando con los datos. Algunas extensiones como Augury aportan muchas más prestaciones, pero al empezar el pipe json te ayudará mucho.1&lt;pre&gt;&#123;&#123; contact | json &#125;&#125;&lt;/pre&gt;La directiva ngModel es mucho más potente de lo visto aquí. Entre otras cosas permite decidir el criterio de actualización (a cada cambio o al salir del control). También se verá más adelante el asunto de la validación, que requiere un trato especial. Cuando empiezas con Angular Forms, un input y su ngModel asociado serán tus mejores amigos.2.2 FormHay más usos de las directivas en los formularios. Por ejemplo, dado el siguiente modelo:1public contact = &#123; name: '', isVIP: false, gender: '' &#125;;Le vendría muy bien un check box.CheckBox1234&lt;section&gt; &lt;label for=\"isVIP\"&gt;Is V.I.P.&lt;/label&gt; &lt;input name=\"isVIP\" type=\"checkbox\" [(ngModel)]=\"contact.isVIP\" /&gt;&lt;/section&gt;Y un para de radio buttons.Radio Buttons1234567&lt;section&gt; &lt;label for=\"gender\"&gt;Gender&lt;/label&gt; &lt;input name=\"gender\" value=\"male\" type=\"radio\" [(ngModel)]=\"contact.gender\" /&gt; &lt;i&gt;Male&lt;/i&gt; &lt;input name=\"gender\" value=\"female\" type=\"radio\" [(ngModel)]=\"contact.gender\" /&gt; &lt;i&gt;Female&lt;/i&gt;&lt;/section&gt;3 EstructurasLos anteriores modificadores actúan a nivel de contenido del HTML. Veremos ahora una para de directivas que afectan directamente a la estructura del árbol DOM. Son las llamadas directivas estructurales que comienzan por el signo *3.1 Repetitivas *ngForUna situación que nos encontramos una y otra vez es la de las repeticiones. Listas de datos, tablas o grupos de opciones son ejemplos claros. Hay una directiva en Angular para esa situación, la *ngFor=&quot;let iterador of array&quot;. La directiva *ngFor forma parte del grupo de directivas estructurales, porque modifica la estructura del DOM, en este caso insertando múltiples nodos hijos a un elemento dado.Puedes ver un ejemplo del uso la directiva *ngFor en el componente ContactsComponent. Se emplea para recorrer un array de tipos de estado laboral. Es el caso de uso más repetido de las repeticiones; mostrar listas de datos.Dado el siguiente modelo:1234567public workStatuses = [ &#123; id: 0, description: 'unknow' &#125;, &#123; id: 1, description: 'student' &#125;, &#123; id: 2, description: 'unemployed' &#125;, &#123; id: 3, description: 'employed' &#125;];public contact = &#123; name: '', isVIP: false, gender: '', workStatus: 0 &#125;;Montamos las opciones de un select html recorriendo el array y usando el iterador wkSt para acceder a sus datos.12345678&lt;section&gt; &lt;label for=\"workStatus\"&gt;Work Status&lt;/label&gt; &lt;select name=\"workStatus\" [(ngModel)]=\"contact.workStatus\"&gt; &lt;option *ngFor=\"let wkSt of workStatuses\" [value]=\"wkSt.id\"&gt; &lt;span&gt;&#123;&#123; wkSt.description &#125;&#125;&lt;/span&gt; &lt;/option&gt; &lt;/select&gt;&lt;/section&gt;3.2 Condicionales *ngIfLa directiva estructural más utilizada es la *ngIf, la cual consigue que un elemento se incluya o se elimine en el DOM en función de los datos del modelo.En el ejemplo puedes ver que la uso para mostrar el campo empresa cuando el contacto está trabajando. En otro aparecerá el campo de estudios.Dado el siguiente modelo:12345678public contact = &#123; name: '', isVIP: false, gender: '', workStatus: '0', company: '', education: ''&#125;;12345678910&lt;section *ngIf=\"contact.workStatus=='3'; else education\"&gt; &lt;label for=\"company\"&gt;Company Name&lt;/label&gt; &lt;input name=\"company\" type=\"text\" [(ngModel)]=\"contact.company\" /&gt;&lt;/section&gt;&lt;ng-template #education&gt; &lt;section&gt; &lt;label for=\"education\"&gt;Education&lt;/label&gt; &lt;input name=\"education\" type=\"text\" [(ngModel)]=\"contact.education\"/&gt; &lt;/section&gt;&lt;/ng-template&gt;if condition else templateIdentificadores con hashtagEn el código anterior apreciarás que aparece un elemento &lt;ng-template&gt; no estándar con el atributo llamado #education precedido por un #. La directiva # genera un identificador único para el elemento al que se le aplica y permite referirse a él en otros lugares del código.Ese truco permite que *ngIf muestre otro elemento cuando la condición principal falle. El otro elemento tiene que ser el componente especial &lt;ng-template&gt; que se usa para envolver una rama opcional del DOM. Para localizarlo se usa el identificador #.4 Modelo y controladorLos componentes los hemos definido como bloques de construcción de páginas. Mediante una vista y un controlador resuelven un problema de interacción o presentación de modelos. En los puntos anteriores te presenté la vista. Toca ahora estudiar el modelo y el controlador.4.1 El modelo y su interInterfaces y modelosSin ir muy lejos en las capacidades que tendría un modelo de datos clásico, vamos al menos a beneficiarnos del TypeScript para definir la estructura de datos. Esto facilitará la programación mediante el autocompletado del editor y reducirá los errores de tecleo mediante la comprobación estática de tipos.Para ello necesito una interfaz sencilla. Esto es puro TypeScript, no es ningún artificio registrable en Angular. Esos sí, en algún sitio tienen que estar. Yo suelo usar una ruta como contacts/models, pero es algo completamente arbitrario.12345678910111213export interface Option &#123; id: number; description: string;&#125;export interface Contact &#123; name: string; isVIP: boolean; gender: string; workStatus: number | string; company: string; education: string;&#125;Te recomiendo que no uses clases para definir modelos a menos que necesites agregarle funcionalidad imprescindible. Las interfaces, ayudan al control de tipos en tiempo de desarrollo, igual que las clases, pero sin generar nada de código en tiempo de ejecución, al contrario que las clases. Ojo al uso de tipos compuestos como number | stringSe usan para tipificar las propiedades que conforman nuestro modelo para la vista.123456789101112131415public workStatuses: Option[] = [ &#123; id: 0, description: 'unknow' &#125;, &#123; id: 1, description: 'student' &#125;, &#123; id: 2, description: 'unemployed' &#125;, &#123; id: 3, description: 'employed' &#125; ];public contact: Contact = &#123; name: '', isVIP: false, gender: '', workStatus: 0, company: '', education: '' &#125;;public contacts: Contact[] = [];4.2 ViewModel en el controladorLa parte de lógica del componente va en la clase que se usa para su definición. Como ya has visto podemos usar su constructor para reclamar dependencias y usar los interfaces para responder a eventos de su ciclo de vida. Repasemos el ContactsComponent viéndolo como la clase que es: no solo propiedades, también métodos12345678public saveContact() &#123; this.contacts.push(&#123; ...this.contact &#125;); this.updateCounter();&#125;private updateCounter() &#123; this.numContacts = this.contacts.length; this.counterClass = this.numContacts === 0 ? 'tag secondary' : 'tag primary';&#125;Ahora se trata de invocar el método desde la vista. Es muy buena práctica llevar la lógica al controlador y no escribirla en la vista.1&lt;input value=\"Save\" type=\"submit\" (click)=\"saveContact()\" /&gt;Podemos decir que las propiedades públicas de la clase actuarán como binding de datos con la vista. Mientras que los métodos públicos serán invocados desde los eventos de la misma vista.OnInitLos componentes son clases con un ciclo de vida al que puedes enganchar tu código en algunos pasos. Por ejemplo al iniciarse el componente.El CLI hace que las clase del componente implemente la interfaz OnInit y eso permite al framework invocar al método ngOnInit en cuanto el componente esté listo para su uso. Que no suele ser justo durante la construcción, si no un poco después. Te recomiendo que lleves toda la lógica de inicialización a dicho método.123456789101112131415161718192021public workStatuses: Option[];public contact: Contact;public contacts: Contact[];constructor() &#123;&#125;public ngOnInit() &#123; this.workStatuses = [ &#123; id: 0, description: 'unknow' &#125;, &#123; id: 1, description: 'student' &#125;, &#123; id: 2, description: 'unemployed' &#125;, &#123; id: 3, description: 'employed' &#125; ]; this.contact = &#123; name: '', isVIP: false, gender: '', workStatus: 0, company: '', education: '' &#125;; this.contacts = [];&#125;Un listado de repasoPara mostrar lo que ahora estamos guardando en una lista, nada más sencillo que usar de nuevo a *nFor y a *ngIf para tratar listas vacías.1234567&lt;ul *ngIf=\"contacts.length&gt;0; else empty\"&gt; &lt;li *ngFor=\"let contact of contacts\"&gt; &lt;span&gt;&#123;&#123; contact.name &#125;&#125;&lt;/span&gt; &lt;input value=\"Delete\" type=\"button\" (click)=\"deleteContact(contact)\" /&gt; &lt;/li&gt;&lt;/ul&gt;&lt;ng-template #empty&gt; &lt;i&gt;No data yet&lt;/i&gt; &lt;/ng-template&gt;Y ya puestos incluso puedes animarte a borrar contactos. Es fácil, los métodos pueden recibir argumentos. Y la vista los puede enviar.1234public deleteContact(contact: Contact) &#123; this.contacts = this.contacts.filter(c =&gt; c.name !== contact.name); this.updateCounter();&#125;Mira el código completo de la clase ContactsComponenten el fichero contacts.component.ts para tener una visión completa del componente. Como ves, las propiedades header, numContacas, formHidden, contacts ... se corresponden con las utilizadas en las directivas de enlace en la vista. Los métodos saveContact(), deleteContact() son invocados desde eventos de elementos del html.Juntos, la vista y su clase controladora, resuelven un problema de interacción con el usuario creando un componente. Todas las páginas que diseñes serán variaciones y composiciones de estos componentes.Y esto es sólo el comienzo. La idea de componente será fundamental en la web del mañana para la creación de páginas mediante web components. Pero eso ya se verá más adelante…Ahora tienes una aplicación en Angular 8 que recoge y muestra datos. Sigue esta serie para añadirle Flujo de datos entre componentes Angular mientras aprendes a programar con Angular8. Todos esos detalles se tratan en el curso básico online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Forms","slug":"Forms","permalink":"https://academia-binaria.com/tag/Forms/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"}]},{"title":"Páginas y rutas Angular SPA","slug":"paginas-y-rutas-angular-spa","date":"2019-01-21T12:41:14.000Z","updated":"2019-10-09T10:45:38.706Z","comments":true,"path":"paginas-y-rutas-angular-spa/","link":"","permalink":"https://academia-binaria.com/paginas-y-rutas-angular-spa/","excerpt":"Las aplicaciones Angular 8 son conjuntos de páginas enrutadas en el propio navegador. Son las conocidas SPA, Single Page Applications. Estas apps liberan al servidor de una parte del trabajo, reducen la cantidad de llamadas y mejoran la percepción de velocidad del usuario.En este tutorial aprenderás a crear una Angular SPA fácilmente usando @angular/router, el enrutador de Angular.","text":"Las aplicaciones Angular 8 son conjuntos de páginas enrutadas en el propio navegador. Son las conocidas SPA, Single Page Applications. Estas apps liberan al servidor de una parte del trabajo, reducen la cantidad de llamadas y mejoran la percepción de velocidad del usuario.En este tutorial aprenderás a crear una Angular SPA fácilmente usando @angular/router, el enrutador de Angular.Partiendo de la aplicación tal como quedó en Base para una aplicación Angular. Seguimos usando el concepto de árbol, ahora como analogía de las rutas y las vistas asociadas. Al finalizar tendrás una angular SPA con vistas asociadas a sus rutas.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-basic/2-spa1. RutasAl crear la aplicación hice uso del flag routing true en el comando de generación del CLI. Esto causó la aparición de no uno, sino dos módulos gemelos en la raíz de la aplicación. Has estudiado el AppModule verdadero módulo raíz, y ahora verás en profundidad a su gemelo: el módulo de enrutado AppRoutingModule y el uso que hace del RouterModule.1.1 RouterModuleEl Angular Router necesita ser importado y configurado. El módulo AppRoutingModule cumple dos funciones. Por un lado importa al RouterModule de Angular, el cual contiene toda la lógica necesaria para enrutar en el navegador. Por otro lado, permite la definición de rutas en el array Routes[].1234567891011121314151617181920import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [ &#123; path: 'heroes', component: HeroesComponent &#125;, &#123; path: 'not-found', component: NotFoundComponent &#125;, &#123; path: '**', redirectTo: 'not-found' &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123;&#125;El array de rutas recibe objetos ruta con propiedades de configuración.La primera es path: en la que se especifica la dirección que resuelve, en este caso la ruta vacía o raíz del árbol de rutas. Las otras son opcionales y las veremos poco a poco.1.1.1 ComponentVamos a crear un componente donde guardar el contenido que el CLI nos regala de inicio. Los enlaces a las páginas oficiales de Angular y al ejemplo del Tour Of Heroes. Para ello crearé el componente HeroesComponent.1ng g c heroesLo hago en la carpeta raíz; algo poco aconsejado si queremos tener una estructura escalable. Pero es un buen anti-ejemplo ;-) Su contenido es una copia de la página original creada por Angular.123456789101112131415161718&lt;h2&gt;Initial Links to start: &lt;/h2&gt;&lt;ul&gt; &lt;li&gt; &lt;h2&gt;&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://angular.io/tutorial\"&gt;Tour of Heroes&lt;/a&gt;&lt;/h2&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://angular.io/cli\"&gt;CLI Documentation&lt;/a&gt;&lt;/h2&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://blog.angular.io/\"&gt;Angular blog&lt;/a&gt;&lt;/h2&gt; &lt;/li&gt;&lt;/ul&gt;Ahora debo decidir qué ruta asociarle… por ejemplo /heroes. Eso es lo que se ve en el inicio de la configuración de rutas. Para no perderme lo ideal es tener un nuevo enlace de navegación en el HeaderComponent123456&lt;header class=\"sticky\"&gt; &lt;a routerLink=\"/\" class=\"logo\"&gt; &lt;span class=\"icon-home\"&gt;&lt;/span&gt; &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;a routerLink=\"heroes\" routerLinkActive=\"router-link-active\" class=\"button\"&gt; &lt;span&gt; Heroes&lt;/span&gt; &lt;/a&gt;&lt;/header&gt;Vayamos casi al final y de paso hagamos algo útil para no volver a perdernos sin remedio. Un detector de rutas no contempladas, y una ruta a dónde redirigir a los usuarios perdidos. Para ello estudiaremos la propiedad component que es fundamental pues indica el componente que se debe mostrar cuando esta ruta se active.Así es cómo funciona el enrutado. Un camino y un componente asociado. La tabla de enrutado se procesa de arriba a abajo y cuando un camino coincide con la ruta actual, se para y se carga el componente.Vamos a crear un componente con la intención de mostrarlo sólo cuando las demás ruta fallen. Se llamará not found Lo creo asociado al CoreModule lo cual ayuda a organizar los elementos de la aplicación.1ng g c core/not-foundYa podemos asociar dicho componente al camino not-found. Pero esto es poca cosa. Hay mucho más.1.1.2 RedirectToLa configuración de rutas no sólo permite asignar componentes a las direcciones. También se pueden hacer redirecciones de unas direcciones a otras. Y por supuesto puede haber rutas no contempladas o errores por parte del usuario, los infames 404 Not Found.En este caso cuando se escriba la ruta /not-foud se mostrará un componente, el NotFoundComponent, cuyo contenido indicará al usuario que se ha perdido. Claro que nadie va voluntariamente a esa ruta. Mediante el path: &#39;**&#39; le indico que ante cualquier ruta no contemplada anteriormente se ejecute el comando redirectTo: &#39;not-found&#39;, el cual nos lleva a una ruta conocida con un mensaje bien conocido. Page Not Found.Pero ¿Cómo es eso de que se mostrará?, ¿Dónde se cargará?. Presentamos a &lt;router-outlet&gt;.1.2 Router OutletLa idea general de una SPA es tener una única página que cargue dinámicamente otras vistas. Normalmente la página contenedora mantiene el menú de navegación, el pie de página y otras áreas comunes. Y deja un espacio para la carga dinámica. Para ello necesitamos saber qué componente cargar y dónde mostrarlo. De esto último se ocupa el router outlet mediante la etiqueta &lt;router-outlet&gt;&lt;/router-outlet&gt;.En el main.component.ts había un contenido hard-coded. Para hacer que el contenido sea dinámico se sustituye por el elemento de Angular &lt;router-outlet&gt;&lt;/router-outlet&gt;. Este elemento del framework inyectará dinámicamente el componente que le corresponda según la ruta activa. El MainComponent queda así:1234&lt;main class=\"container\"&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;!-- Dynamic content here! --&gt;&lt;/main&gt;1.3 Router LinkLos enlaces web tradicionalmente se han resuelto con elementos &lt;a href=&quot;&quot;&gt;&lt;/a&gt; dónde en su atributo href se asociaba la dirección a la cuál navegar ante el click del usuario. En Angular los enlaces se declaran con un atributo especial llamado routerLink. Este atributo se compila dando lugar al href oportuno en tiempo de ejecución.En el fichero not-found.component.ts pon algo así:123&lt;h1&gt;Not Found&lt;/h1&gt;&lt;h2&gt;404&lt;/h2&gt;&lt;a routerLink=\"/\"&gt;Go home&lt;/a&gt;Por ahora la funcionalidad de routerLink no mejora en nada a href. Pero lo hará. Mientras tanto familiarízate con su sintaxis y… asegúrate de importar RouterModule en los módulos en los que lo vayas a usar.Salgamos de este bucle creando más rutas y más componentes. Pero esta vez con un nueva técnica.2 Lazy LoadingLa web clásica funcionaba con un navegador pidiendo una ruta al servidor. El servidor buscaba o montaba un documento html y se lo devolvía al navegador para que lo renderizase. Una nueva ruta significaba repetir todo ese viaje. Hasta que aparecieron las Single Page Applications. En este caso el código cliente es el responsable del contenido asociado a cada ruta. Y eso es mucha responsabilidad.Las webs SPA se crearon por una razón que casi acaba con ellas: la velocidad. Al realizar el enrutado en el cliente y querer evitar todos los viajes posibles hasta el servidor, se cargó a la única página web con todo el peso de la aplicación. Lo cual la hizo terriblemente lenta en la primera visita de cada usuario.El impacto de la primera visita en una aplicación de intranet no suele ser un problema grave. Pero en internet esa visita puede ser la primera y si tarda mucho, también será la última. La solución viene de mano del concepto de lazy loading o carga perezosa. Consiste en diferir la carga de la lógica asociada a una dirección hasta el momento en que sea activada dicha ruta. De esa forma, una página no visitada es una página que no pesa. Y la carga inicial se hace mucho más liviana.En Angular el lazy loading es tan sencillo que ya se recomienda implementarlo por defecto. Para hacerlo conoceremos más comandos del Router y algunas herramientas de compilación usadas por el Angular CLI.2.1 Webpack y los bundles por rutaHay que saber que el Angular CLI usa internamente la herramienta de empaquetado webpack. La cual recorre el código TypeScript buscando imports y empaquetando su contenido en sacos o bundles. Luego introduce las referencias a esos bundles en la sección se scripts del index.html, haciendo que se descarguen todos nada más arrancar la aplicación. Esto puede ser muy pesado en aplicaciones grandes. Así que hay que buscar una manera de diferir esa descarga, repartiendo el bundle principal en otros más pequeños que se cargará bajo demanda.Objetivo: adelgazar el peso del bundle principal, el main.js.Para conseguirlo hay que configurar las rutas de forma que no sea necesario importar los componentes a mostrar. Tal como se ha hecho con el NotFoundComponent, de hacerlo así con todos, webpack empaquetaría esos componentes como algo necesario… y por tanto serían enviados al navegador en el bundle principal sin que sea seguro su uso. Ese no es el camino, es una excepción para componentes poco pesados y muy utilizados.La solución que ofrecen el cli y webpack consiste en delegar la asignación del componente a otro módulo, pero sin importarlo hasta que su ruta principal se active.He creado unas vistas para ser usadas en las direcciones / y /about. Los componentes asociados se llaman HomeComponent u AboutComponent. Se han declarado pero no exportado en sus respectivos módulos HomeModule y AboutModule. No es necesario exportarlos porque no serán reclamados directamente por nuestro código.1234ng g m home --routing trueng g c home/homeng g m about --routing trueng g c about/aboutEstos módulos no deben ser importados por el AppModule; no queremos saber de su existencia. Para ello emplearemos una función que importe el módulo desde su ruta relativa, sin incluirlo en la sección de imports que procesa webpack. Vamos a agregarlo al app-routing.module.ts que quedará así.123456789101112131415161718192021222324import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [ &#123; path: '', loadChildren: () =&gt; import('./home/home.module').then(m =&gt; m.HomeModule) &#125;, &#123; path: 'about', loadChildren: () =&gt; import('./about/about.module').then(m =&gt; m.AboutModule) &#125;, &#123; path: 'not-found', component: NotFoundComponent &#125;, &#123; path: '**', redirectTo: 'not-found' &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123;&#125;Ojo, esta es una novedad de Angular 8. Fíjate que la dirección del fichero es una cadena de texto asignada a una función dentro del objeto route, en la propiedad loadChildren:&quot;&quot;.No se está produciendo ninguna importación en TypeScript como ocurre con el componente NotFoundComponent. Con esta información webpack va a generar un bundle específico para cada módulo. Si durante la ejecución se activa la ruta / (muy probable porque es la ruta raíz) o la ruta /about entonces se descarga ese paquete concreto y se ejecuta su contenido. Mientras tanto, se queda almacenado en el servidor.Esto hace que la aplicación de Angular pese menos y responda antes, mejorando el tiempo de pintado inicial. La combinación de estas y otras técnicas que veremos en este tutorial sacarán el mejor rendimiento posible a tu aplicación Angular.2.2 El enrutador delegadoYa sabemos que hasta que no se active la ruta / o la /about no hay que hacer nada. Pero si se activa, entonces se descarga un bundle que contiene un módulo y los componentes necesarios. Sólo falta escoger dentro de ese módulo el componente que se asignará a la ruta.Para eso al crear los módulos Home y About use el flag routing true. Esto hace que se genere un segundo módulo de enrutado. El HomeRoutingModule y el AboutRoutingModule son prácticamente idénticos al enrutador raíz.Digamos que son enrutadores subordinados al primero. Sólo se llega aquí si en la ruta principal se ha navegado a una dirección concreta. Se hace notar esa distinción durante el proceso de importación del módulo de Angular RouterModule. En el caso principal se pone imports: [RouterModule.forRoot(routes)] y en todos los demás imports: [RouterModule.forChild(routes)].A nivel subordinado, la dirección path: &quot;&quot; se agrega al path: &quot;&quot; de su enrutador padre. Cuidado, es un error común repetir el path a nivel hijo. En este caso incluso parece redundante. Pero con about no quedan dudas. En el root lleva path: &quot;about&quot; y en el child solamente path: &quot;&quot;.La ventaja real de este segundo enrutador es que irá empaquetado en el mismo bundle que el módulo de negocio y sus componentes. Descargando ese peso en el momento que se necesite. Aquí sí que asignaremos un componente concreto: el HomeComponent o el AboutComponent. Por ejemplo el fichero home-routing.module.ts quedará más o menos así:123456789101112import &#123; HomeComponent &#125; from './home/home.component';const routes: Routes = [ &#123; path: '', component: HomeComponent &#125;];@NgModule(&#123; imports: [RouterModule.forChild(routes)], exports: [RouterModule]&#125;)export class HomeRoutingModule &#123;&#125;2.3 NavegaciónAhora que ya tenemos un par de rutas reales, es buen momento para crear un mini menú de navegación. Vayamos al core/shell/header.component.html y pongamos algo así:123456&lt;header class=\"sticky\"&gt; &lt;a routerLink=\"/\" class=\"logo\"&gt; &lt;span class=\"icon-home\"&gt;&lt;/span&gt; &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;a routerLink=\"about\" routerLinkActive=\"router-link-active\" class=\"button\"&gt; &lt;img width=\"32\" style=\"vertical-align: -0.5em\" src=\"./assets/logo.png\" /&gt; &lt;span&gt; About us&lt;/span&gt; &lt;/a&gt;&lt;/header&gt;3 Rutas anidadasCuando las interfaces se complican, es habitual que las aplicaciones dispongan de menús de navegación a distintos niveles. Dentro de una misma página podemos querer ver distinto contenido y además reflejarlo en la URL. Para resolver esta situación en Angular disponemos de la técnica de las nested routes.De una manera un tanto forzada la he incluido en la página /about. La cual disponen de su propio menú de navegación, y lo que es más importante, su propio &lt;router-outlet&gt;&lt;/router-outlet&gt;.Para empezar veamos como queda el html del about.component.ts. Vamos a dotarlo de dos rutas nuevas /about/links y /about/info. Cada una mostrará contenido en un componente adecuadamente insertado en el &lt;router-outlet&gt;&lt;/router-outlet&gt; local.3.1 ChildrenPara repasar conceptos de generación de componentes12ng g c about/about/linksng g c about/about/infoPara que funcione empezamos por crear los dos componentes LinksComponent e InfoComponent de forma rutinaria. Y los asignamos en el about-routing.module.ts como subordinados a la ruta principal con el comando children:[]. Los caminos se van agregando sobre la ruta principal activa, la /about. Esto es así tanto el routerLink como el path de los children.12345678910111213141516const routes: Routes = [ &#123; path: '', component: AboutComponent, children: [ &#123; path: 'links', component: LinksComponent &#125;, &#123; path: 'info', component: InfoComponent &#125; ] &#125;];3.2 RouterOutlet anidadoLos componentes de las rutas children se inyectarán en el &lt;router-outlet&gt; del componente contenedor AboutComponent. Es como si todo volviese a empezar desde aquí.12345&lt;header class=\"sticky\"&gt; &lt;a routerLink=\"links\" class=\"button\"&gt; &lt;span&gt; Tutorial Links&lt;/span&gt; &lt;/a&gt; &lt;a routerLink=\"info\" class=\"button\"&gt; &lt;span&gt; More Info&lt;/span&gt; &lt;/a&gt;&lt;/header&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;Con estos conceptos y la combinación de children, loadChild, component, redirectTo … asociadas a path podrás configurar tu aplicación y responder a cualquier URL desde la misma y única página index.html.4 ParámetrosLas rutas vistas hasta ahora se consideran estáticas pues se han definido usando constantes. Es muy habitual tener páginas con la misma estructura pero distintos contenidos. Un blog con sus posts, una tienda con sus productos, o un proyecto con sus tareas… hay miles de ejemplos así.4.1 Variables en la rutaEse tipo de direcciones se consideran paramétricas, tienen unos segmentos estáticos y otros dinámicos. Estos últimos se definen con parámetros, algo así como variables dentro de la cadena de la ruta. Su sintaxis obliga a precederlas de dos puntos. Por ejemplo countries/:country/cities/:city resolvería rutas como countries/usa/cities/new-york o countries/italy/cities/roma. Rellenando los parámetros :country y :city con los valores necesarios.Esta aplicación no tiene un propósito de negocio concreto. Iremos creando rutas según sea necesario por motivos pedagógicos. Empezaremos con unas páginas destinadas a mostrar los autores del proyecto.Vamos a crear rutas como /authors/albertobasalo o /authors/johndoe. Para ello necesitamos el segmento principal /authors y una par de componentes.Vamos a agregar los componentes necesarios como hasta ahora.12ng g c about/about/authorsng g c about/about/authors/authorEn las rutas del about-routing.module.ts agregamos un nuevos children paths1234567891011121314151617&#123; path: '', component: AboutComponent, children: [ &#123; path: 'links', component: LinksComponent &#125;, &#123; path: 'info', component: InfoComponent &#125;, &#123; path: 'authors', component: AuthorsComponent &#125;, &#123; path: 'authors/:id', component: AuthorComponent &#125; ]&#125;Esta configuración resuelve las rutas about/links, about/info, about/authors y about/authors/cualquier-otra-cosa. Y las carga con el componente adecuado. Lo novedoso en el camino :id. El prefijo dos puntos indica que es un parámetro. Algo así como una variable en el segundo segmento que se almacenará y será recogido con el arbitrario nombre id.Para mostrar el uso de los nuevos enlaces he agregado el authors/ al AboutComponent y he creado un listado en el AuthorsComponent. Familiarízate con las rutas relativas para componer la ruta completa.12&lt;a routerLink=\"albertobasalo\" class=\"button\"&gt; &lt;span&gt; Alberto Basalo&lt;/span&gt; &lt;/a&gt;&lt;a routerLink=\"johndoe\" class=\"button\"&gt; &lt;span&gt; John Doe&lt;/span&gt; &lt;/a&gt;Aún más interesante es el componente que muestra cada autor de la lista, el AuthorComponent. En este caso fíjate cómo accede a la ruta, cómo obtiene el valor del parámetro y cómo lo usa para mostrarlo en la web.4.2 ActivatedRouteEl framework Angular trae muchas librerías para facilitar la vida al programador. Sólo hay que saber dónde están y cómo pedirlas. Para ello volvemos a la tecnología escogida, TypeScript, que permite las importaciones y la inyección de dependencias. Hay un tema dedicado a conocer en profundidad los servicios inyectables en Angular. Por ahora una breve introducción.Contenido del fichero author.component.ts relacionado con la obtención del parámetro de la ruta activa:12345678910import &#123; Component, OnInit &#125; from '@angular/core';import &#123; ActivatedRoute &#125; from '@angular/router';export class AuthorComponent implements OnInit &#123; public authorId = ''; constructor(activateRoute: ActivatedRoute) &#123; this.authorId = activateRoute.snapshot.params['id']; &#125; ngOnInit() &#123;&#125;&#125;La instrucción import { ActivatedRoute } from &quot;@angular/router&quot;; pone a disposición del programador el código donde está definida la clase ActivatedRoute. Pero no se instancia directamente; en su lugar, se usa como un argumento del constructor de la clase del componente. Ese constructor es invocado por Angular, y dinámicamente el propio framework sabe cómo rellenar los argumentos que se pidan en los constructores. Es decir, sabe cómo inyectar instancias en las que dependencias declaradas.Una vez que han inyectan las dependencias en el constructor ya están listas para ser usadas. En concreto activateRoute da acceso a métodos y propiedades para trabajar con la ruta activa y poder leer sus parámetros.Obtenidos los datos desde la URL, ya se muestran en la vista de forma ya conocida. Fichero /about/authors/author/author.component.html12&lt;h2&gt;Author profile&lt;/h2&gt;&lt;h3&gt;&#123;&#123; authorId &#125;&#125;&lt;/h3&gt;Con esto tendrás una aplicación SPA en Angular. Sigue esta serie para añadirle Formularios, tablas y modelos de datos en Angular mientras aprendes a programar con Angular8.Todos esos detalles se tratan en el curso básico online que imparto con TrainingIT o a medida para tu empresa.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular8","slug":"Angular8","permalink":"https://academia-binaria.com/tag/Angular8/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"SPA","slug":"SPA","permalink":"https://academia-binaria.com/tag/SPA/"},{"name":"Routing","slug":"Routing","permalink":"https://academia-binaria.com/tag/Routing/"}]},{"title":"TypeScript, programa en el front igual que en el back","slug":"typescript-programa-en-el-front-igual-que-en-el-back","date":"2017-03-14T18:02:11.000Z","updated":"2017-03-14T18:10:13.000Z","comments":true,"path":"typescript-programa-en-el-front-igual-que-en-el-back/","link":"","permalink":"https://academia-binaria.com/typescript-programa-en-el-front-igual-que-en-el-back/","excerpt":"Hasta hace bien poco había dos mundos en la programación casi enfrentados: el desarrollo back end y el front end. El primero era el de los programadores de verdad, con lenguajes serios y patrones de diseño. El último era el universo de los diseñadores, con lenguajes de segundo nivel y micro scripts o código espagueti descontrolado.","text":"Hasta hace bien poco había dos mundos en la programación casi enfrentados: el desarrollo back end y el front end. El primero era el de los programadores de verdad, con lenguajes serios y patrones de diseño. El último era el universo de los diseñadores, con lenguajes de segundo nivel y micro scripts o código espagueti descontrolado.Pero la llegada de los frameworks MVC en el cliente, llevó grandes cantidades de código al navegador y el desarrollo front end ya nunca sería lo mismo. Primero se portaron los patrones, después las buenas prácticas, más tarde las herramientas y así hasta haber eliminado las fronteras entre back y front.Pero quedaba algo pendiente, el leguaje. En el lado del servidor había multitud de opciones, siendo Java y C# las más aceptadas por la empresa, administración y banca. Pero al otro lado del cable seguía, con algunos retoques, el viejo JavaScript.Y entonces eclosionó TypeScript. Un proyecto maduro creado por el equipo de desarrollo de Microsoft y que lleva a JavaScript al siguiente nivel. Con tipos estáticos (de ahí su nombre) propicia que las herramientas de desarrollo mejoren la productividad y experiencia de los programadores. Y como consecuencia suaviza la rampa de entrada al front para los desarrolladores back.Ya no queda excusas para programar en el cliente igual de bien que en el servidor. Prueba el TypeScript si dominas y te gusta la POO, serás un full stack cuestión de horas.","categories":[],"tags":[{"name":"Opinión","slug":"Opinion","permalink":"https://academia-binaria.com/tag/Opinion/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://academia-binaria.com/tag/TypeScript/"}]},{"title":"Node 6.0.0 actualización con nvm","slug":"node-6-0-0-actualizacion-con-nvm","date":"2016-05-05T07:39:40.000Z","updated":"2016-05-05T08:02:26.000Z","comments":true,"path":"node-6-0-0-actualizacion-con-nvm/","link":"","permalink":"https://academia-binaria.com/node-6-0-0-actualizacion-con-nvm/","excerpt":"","text":"Acabamos de recibir la buena noticia de la versión 6 de NodeJS. En este caso con mejoras de rendimiento e incorporación de sintaxis de ES6. ¿Cómo obtener esta nueva versión?. Y sobretodo, ¿cómo manejar la convivencia de distintas versiones? La ayuda se llama nvmEstos son los pasos que has de seguir para instalar la herramienta.Se recomienda desinstalar las versiones de node y npm instaladas previamente. No es obligatorio.LINUX &amp; OS X1- Comprobamos que tenemos instaladas las dependencias1.1 - Dependencias Linux12sudo apt-get updatesudo apt-get install build-essential1.2 -Dependencias OSX (herramientas de linea de comandos para XCode)1xcode-select --install2- Descargamos y ejecutamos el script de instalación1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash3- Comprobamos que está instalado NVM1command -v nvmdebe devolver nvm4- Instalamos la versión de Node que deseamos1nvm install 6.0.05- Elegimos la versión de Node instalada que deseamos usar1nvm use 6.0.0WINDOWSPara Windows no existe una versión nativa de nvm, pero si hay dos opciones para gestionar las versiones de node instaladas.1- nvm-windowshttps://github.com/coreybutler/nvm-windowsEs un wrapper de npm para windows, el instalador se encuentra en la URL (https://github.com/coreybutler/nvm/releases).Los comandos para instalar y la versión de Node son los mismos que en Linux y OSX.2- nodistEs un gestor de versiones parecido a NVM solo para WindowsLa URL del instalador (https://github.com/marcelklehr/nodist/releases/download/v0.7.2/NodistSetup-v0.7.2.exe).Los comandos se encuentran en la documentación. (https://github.com/marcelklehr/nodist)","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://academia-binaria.com/tag/NodeJS/"},{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"}]},{"title":"npm: de instalador a publicador","slug":"npm-de-instalador-a-publicador","date":"2016-04-18T14:07:46.000Z","updated":"2016-04-19T05:01:25.000Z","comments":true,"path":"npm-de-instalador-a-publicador/","link":"","permalink":"https://academia-binaria.com/npm-de-instalador-a-publicador/","excerpt":"","text":"Seguro que estás harto de repetir la mítica instrucción npm install paquete-x Pero, ¿has pensado en publicar tus propios módulos?. Es muy recomendable crear soluciones distribuidas y muy fácil publicarlas en npm.Sigue este proceso y te convertirás en un creador de paquetes para npm :ProgramaTodo empieza por tener una necesidad y resolverla encapsulando su código en un módulo. Por supuesto que ese módulo puede requerir paquetes externos. Y por supuesto que tu código puede, y debe, escribirse en varios módulos.Antes de continuar vamos a fijar un par de conceptos:- módulo: Fichero .js que exporta un funcionalidad y oculta su implementación.- paquete: Uno o más módulos, con sus dependientes de otros paquetes que proponen una solución reutilizable.Conocidos los ingredientes, la receta es sencilla:Debes crear un proyecto para el paquete que vas a publicar.Has de subir el código a un repositorio público.Y debes rellenar convenientemente el package.json de tu proyecto.Este es un ejemplo que he creado y publicado en github que te puede servir de base.Presta especial atención al nombrado de tu proyecto porque ha de ser único en el repositorio de npm. Para reducir riesgos de colisiones de nombre te recomiendo que utilices un prefijo con tus iniciales o las de tu empresa.No te olvides de incluir un juego de pruebas y documentación necesaria para sus uso.PublicaPuedes descargar librerías y herramienta desde el repositorio de npm de forma anónima. De hecho, eso es lo más corriente. Pero, como era de esperar, tienes que registrarte para poder publicar contenido. El proceso de registro vía web es sencillo y grátis.Una vez verificado puedes hacer login en la web. Pero también en la terminal de tu ordenador: npm login te pedirá el nombre de usuario y contraseña. A partir de es momento estás identificado y puedes usar las herramientas de autor:1npm publishPuedes encontrar más información acerca de este mega comando en la documentación de npmjs. Pero siguiendo la máxima de cuanto menos, mejor, la herramienta hará con sus valores por defecto un publicación y actualización limpias.La clave está en que tu fichero de configuración package.json sea correcto y lo más completo posible. Escribe un completo readme.md que se convertirá en portada de tu paquete en el repositorio de npm. Mira en mi ejemplo cómo el contenido subido a github se transforma y se ve en la página de información de npm.Comprueba en un directorio vacío que npm install nombre-de-tu-paquete descarga todo lo necesario… y tómate un café mientras ves crecer la hierba y las estadísticas de descargas.ActualizaCon el tiempo mejorarás y corregirás tu solución. Te recomiendo que sigas el patrón de nombrado de versiones semántico:x.y.z = 1.2.3 = ruptura.mejora.parcheEs bueno que etiquetes tu repositorio con estas mismas versiones para que, una vez desplegadas, se encuentre con facilidad en github.12git tag 0.1.2git push --tagsDisfrutaFinalmente podrás utilizar ese código en todas tus aplicaciones. Sería fantástico que además otros lo encontrasen útil. Y mejor aún si te ayudan o al menos te proponen mejoras. Pero en cualquier caso siempre habrás ganado. El esfuerzo analítico que requiere se cobra con creces: dividiendo el problema, creando micro soluciones eficientes y reutilizando código siempre es rentable.","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://academia-binaria.com/tag/NodeJS/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"}]},{"title":"Soluciones BackEnd 2016","slug":"soluciones-backend-2016","date":"2016-03-21T10:50:58.000Z","updated":"2016-04-01T06:02:55.000Z","comments":true,"path":"soluciones-backend-2016/","link":"","permalink":"https://academia-binaria.com/soluciones-backend-2016/","excerpt":"","text":"Las soluciones JavaScript para el servidor que marcan tendencia en el desarrollo back end durante este 2016. Continuación de la saga que iniciamos con FrontEdge.Mi apuesta de mercado sigue empezando por la base, el lenguaje JavaScript. En concreto su última y muy necesaria versión: el conocido ES6. En el lado del servidor destaco la disponibilidad de Promesas de forma nativa..Las aplicaciones crecen y se controlan por su API.Así que este es el punto al que más atención debes prestarle. Por supuesto que hay que cumplir con el estándar REST y hay que documentar todo nuestro código. Pero para ser más productivo y mantener actualizado el sistema, te propongo que uses RAML. Un lenguaje para documentar APIs que con las herramientas adecuadas permite la generación de pruebas, esqueletos de aplicaciones e infraestructura.El ya viejo conocido NodeJS se ha modernizado y a partir de la versión 4, especialmente en la 5, admite la mayor parte de la sintaxis ES6. Además ha mejorado su velocidad en un 25% gracias a la actualización del motor V8 que procesa internamente el JavaScript.En la base de datos irrumpe con fuerza la nueva versión de MongoDB 3.2, que incorpora grandes novedades como: sistema de almacenamiento más rápido, índices parciales, validación de esquema y el esperado join entre colecciones .En esta presentación tienes más información acerca de lo que llamo backEdge : tecnología utilizable, de última generación y con enorme potencial.En este video tienes la charla que di con o que llamo Desarrollo Web presentando las tendencias tecnológicas del 2016.","categories":[],"tags":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://academia-binaria.com/tag/BackEnd/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://academia-binaria.com/tag/NodeJS/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://academia-binaria.com/tag/MongoDB/"},{"name":"Opinión","slug":"Opinion","permalink":"https://academia-binaria.com/tag/Opinion/"}]},{"title":"Soluciones FrontEnd 2016","slug":"soluciones-frontend-2016","date":"2016-01-14T09:39:32.000Z","updated":"2016-01-14T10:17:31.000Z","comments":true,"path":"soluciones-frontend-2016/","link":"","permalink":"https://academia-binaria.com/soluciones-frontend-2016/","excerpt":"","text":"Inicio el año proponiendo una selección de tecnologías que serán tendencia en el desarrollo front end durante este 2016.Mi apuesta de mercado empieza por la base, el lenguaje JavaScript. En concreto su última y muy necesaria versión: el conocido ES6. Tras siete años desde la anterior gran revisión, el éxito y la popularidad de JS no podía esperar más. Y tu tampoco debes esperar más para conocerlo y usarlo.Existe una creciente necesidad de dependencias externas en nuestra aplicaciones y sobre todo incorporar librerías provenientes de otros entornos y desarrolladas con variantes de JS. Para administrar todo ello propongo JSPM, que se incorporará definitivamente a nuestro toolbox durante el 2016.De entre las librerías y frameworks disponibles, AngularJS continuará siendo el rey. Este viejo conocido está creciendo en ya en grandes empresas, banca y administraciones públicas. Mientras esperamos la gloriosa venida de la versión 2.0, tenemos la oportunidad de adecuar nuestro estilo de programación y desarrollar de manera mas limpia con la versión puente AngularJS1.5En la parte visual, el look &amp; feel propuesto por Google con Material Design es un éxito de aceptación para el desarrollo de aplicaciones empresariales. La librería AngularMaterial es una implementación para Angular de dicha especificación gráfica. Moderno y con enorme potencial.En esta presentación tienes más información acerca de lo que llamo frontEdge : tecnología utilizable, de última generación y con enorme potencial.Presentación frontEdgeSi tienes tiempo, mira este vídeo con una charla en la que comentamos estas y otras tecnologías para programadores.video frontEdge","categories":[],"tags":[{"name":"Opinión","slug":"Opinion","permalink":"https://academia-binaria.com/tag/Opinion/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://academia-binaria.com/tag/FrontEnd/"},{"name":"AngularJS","slug":"AngularJS","permalink":"https://academia-binaria.com/tag/AngularJS/"}]},{"title":"Para qué puedo usar NodeJS","slug":"para-que-puedo-usar-nodejs","date":"2015-08-20T12:28:01.000Z","updated":"2015-08-20T12:53:50.000Z","comments":true,"path":"para-que-puedo-usar-nodejs/","link":"","permalink":"https://academia-binaria.com/para-que-puedo-usar-nodejs/","excerpt":"","text":"NodeJS se ha hecho muy popular por dos razones relacionas: potencia y escalabilidad. Ambas derivadas de su modelo de ejecución asíncrona no bloqueante.Se basa en el lenguaje JavaScript: sencillo, versátil y ampliamente conocido. NodeJS complementa a JS con librerías de sistema que sacan un gran rendimiento a los ejecutables.El uso más inmediato de NodeJS está en la programación de servicios web. Tanto en la creación de APIs como sirviendo páginas tradicionales. Esto le ha valido que se le conozca como el JavaScript del lado del servidor.Pero, más allá de la web destaca en entornos empresariales. Se puede utilizar para construir aplicaciones de escritorio con iniciativas como (NW)[] y (electron)[]. También y sobre todo se usa para scripts de administración o monitorización en departamentos IT. Pequeños proyectos aplicables a sistemas de ficheros, máquinas y servidores. Y una derivada de esto son los proyectos de ayuda al desarrollador que se integran en los development workflows de cada vez más empresas de programación en cualquier lenguaje.Dada la capacidad de procesamiento asíncrono es una herramienta ideal para generar sistemas que respondan en tiempo real. Y por su escasa demanda de hardware se usa también en proyectos de Internet of ThingsEn definitiva podemos decir que NodeJS y su ecosistema proponen un nuevo paradigma de desarrollo que eleva a JavaScript como lenguaje de propósito general.","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://academia-binaria.com/tag/NodeJS/"},{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"}]}]}