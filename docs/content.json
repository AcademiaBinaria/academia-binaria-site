{"meta":{"title":"Academia Binaria","subtitle":"Formación en español para programadores","description":"Artículos y tutoriales sobre Angular, NodeJS, MongoDB y todo lo relacionado con JavaScript y TypeScript","author":"Alberto Basalo","url":"https://academia-binaria.com"},"pages":[{"title":"404 No encontrado","date":"2017-12-20T09:17:19.801Z","updated":"2017-12-20T09:17:19.801Z","comments":false,"path":"/404.html","permalink":"https://academia-binaria.com//404.html","excerpt":"","text":"Lo sentimos, la ruta no se ha encontrado.Por favor, dirígete al inicio del blog– El equipo de Academia BinariaAprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo"},{"title":"Contacto","date":"2015-09-16T11:52:52.000Z","updated":"2017-02-14T08:21:50.000Z","comments":true,"path":"contacto.html","permalink":"https://academia-binaria.com/contacto.html","excerpt":"","text":"Vivimos en la nube y nos relacionamos contigo en cualquier sitio desde A Coruña, España.Si quieres visitarnos ven a:Ágora Binaria S.LFactoría de software y academia de programadores.Av. Primera C10. Edif Abanca InnovaCP:15190A Coruña,EspañaTelefóno: +34 609884782Email: info(at)agorabinaria.comPara temas comerciales de cursos presenciales con Vita Digital S.L.:Email: vitae(at)vitaedigital.comWeb: http://www.vitaedigital.com/"},{"title":"Cookies","date":"2016-04-14T12:29:58.000Z","updated":"2016-04-18T13:48:28.000Z","comments":true,"path":"cookies.html","permalink":"https://academia-binaria.com/cookies.html","excerpt":"","text":"Utilizamos cookies para facilitar el uso de nuestra página web.Las cookies son pequeños ficheros de texto que su navegador almacena en el disco duro de su ordenador y que son necesarias para navegar por nuestra página web.Las utilizamos para entender mejor la manera en la que se usa nuestra página web y de esta manera poder mejorar consecuentemente el proceso de navegación. Las cookies son el referente que nos indica, por ejemplo, si una página de nuestra web ha sido vista conanterioridad, o si su visita es nueva o recurrente.Las cookies que utilizamos no almacenan dato personal alguno, ni ningún tipo de información que pueda identificarle.En caso de no querer recibir cookies, por favor configure su navegador de Internet para que las borre del disco duro de su ordenador, las bloquee o le avise en caso de instalación de las mismas."},{"title":"Cursos","date":"2015-09-16T11:17:03.000Z","updated":"2017-02-23T16:07:39.000Z","comments":true,"path":"cursos.html","permalink":"https://academia-binaria.com/cursos.html","excerpt":"","text":"Calendario de cursos de formación impartidos y programados:^^^^2017vvv##Angular 2del 8 al 12 de mayopara universidad de A Coruña##Angular 2del 24 al 28 de abrilpara consultora informática en A Coruña##Angular 1.5 Avanzadodel 30 al 31 de marzopara consultora informática en Madrid##Angular 2del 22 de febrero al 6 de abrilpara consultora informática en A Coruña###Angular 2del 3 al 11 de febreroabierto al público en A Coruña###AngularJSdel 16 al 24 de eneropara consultora informática en A Coruña###Tecnología Webel 13 de eneropara consultora informática en A Coruña^^^20172016vvv###Angular2del 12 al 20 de diciembreabierto al público en Vigo###Angular 2del 28 de noviembre al 15 de diciembrepara consultora informática en Burgos On Line###AngularJSdel 21 al 24 de noviembrepara consultora informática en A Coruña###AngularJSdel 11 al 19 de noviembrepara consultora informática en Santiago###Angular2del 2 al 17 de noviembreabierto al público on line###AngularJSdel 24 de octubre al 27 de octubrepara consultora informática en A Coruña###AngularJSdel 13 de octubre al 21 de octubrepara consultora informática en Madrid###AngularJSdel 26 de septiembre al 29 de septiembrepara entidad bancaria en A Coruña###AngularJSdel 26 de septiembre al 29 de septiembrepara entidad bancaria en A Coruña###Angular 2del 15 de septiembre al 23 de septiembrepara empresa sector automóvil en Vigo###Angular 2del 12 de septiembre al 14 de septiembrepara empresa peritaje en Pontedeume###AngularJSdel 18 de agosto al 26 de agostopara consultora informática en Madrid###Angular2del 10 al 18 de junioabierto al público en A Coruña###Angular2del 9 al 22 de junioabierto al público on line###MEANjsdel 18 de mayo al 6 de juliopara consultora informática en A Coruña###AngularJSdel 15 al 23 de abrilabierto al público en Vigo###BackEdgedel 31 de marzo al 11 de abrilabierto al público on line###AngularJS, Material Designdel 3 de marzo al 8 de marzopara consultora, multinacional del automóvil y entidad bancaria en Vigo###AngularJS, Material Design y WebAPIdel 22 de febrero al 29 de febreropara entidad bancaria en A Coruña###MEANjs.pdf)del 29 de enero al 27 de febreroabierto al público en A Coruña###FrontEdgedel 14 de enero al 25 de eneroabierto al público on line^^^20162015vvv—###FrontEdgedel 14 de diciembre al 15 de diciembreen abierto en A Coruña###AngularJSdel 13 de noviembre al 27 de noviembrepara consultora informática en A Coruña###AngularJSel 10 de noviembrepara consultora informática en Santiago de Compostela###Web Workersel 5 de noviembreabierto al público on line###Angularel 20 de octubrepara consultora informática en Santiago de Compostela###MEANjsdel 14 de octubre al 2 de diciembrepara consultora informática en A Coruña###AngularJSdel 5 de octubre al 7 de octubrepara multinacional del turismo en Palma de Mallorca###AngularJS y WebAPIdel 28 de septiembre al 1 de octubrepara entidad bancaria en A Coruña###MEANjsdel 25 de septiembre al 17 de octubreabierto al público en A Coruña###AngularJSdel 21 de septiembre al 22 de septiembrepara multinacional del turismo en Palma de Mallorca###AngularJSdel 7 de septiembre al 8 de septiembrepara multinacional del turismo en Palma de Mallorca###AngularJSdel 26 de junio al 4 de julioabierto al público en A Coruña###AngularJSdel 5 de junio al 13 de juniomultinacional del automóvil en Vigo###AngularJSdel 8 de junio al 9 de juniopara multinacional del turismo en Palma de Mallorca###NodeJSdel 22 de mayo al 30 de mayoabierto al público en Vigo###MEANjsdel 18 de mayo al 28 de mayopara consultora informática en Santiago de Compostela###MongoDBdel 13 de abril al 23 de abrilpara consultora informática en A Coruña###MEANjsdel 16 de marzo al 8 de abrilabierto al público on line###NodeJSdel 6 de marzo al 14 de marzoabierto al público en A Coruña###AngularJSdel 10 de febrero al 13 de febreroabierto al público on line^^^^20152014vvvv###AngularJSdel 21 de noviembre al 29 de noviembreabierto al público en Vigo###AngularJSel 18 de noviembreuniversidad de Ourense###AngularJSdel 25 de septiembre al 10 de octubreabierto al público on line###AngularJSdel 19 de septiembre al 26 de octubrepara consultora informática en A Coruña###AngularJSdel 5 de julio al 6 de julioabierto al público on line###AngularJSdel 27 de junio al 5 de julioabierto al público en A Coruña^^^2014"},{"title":"Noticias Junio 2016","date":"2016-06-03T08:44:51.000Z","updated":"2016-06-06T12:28:19.000Z","comments":true,"path":"noticias-junio-16.html","permalink":"https://academia-binaria.com/noticias-junio-16.html","excerpt":"","text":"##06-06-16###Angular 2 R.C.: La evolución de la plataforma.AngularJS ha sufrido una metamorfosis. Mantiene el nombre a duras penas. Ahora ya ni le pone el sufijo …JS. Pero la esperada versión Angular2 lo cambia todo. Cambia el lenguaje, cambia la filosofía y cambia la sintaxis.Todo este cambio es necesario para competir en el ecosistema JavaScript. Continuamente aparecen y desaparecen librerías. Para sobrevivir fue necesario renacer. Ahora es una plataforma mucho más cercana al mundo empresarial.Usa esta serie de artículos sobre Angular2 como tutorial para adaptarte a esta evolución.###Enlaces para aprender####[AngularJS] : Mejorar el Rendimiento en una línea.Parece un eslogan de gancho fácil, pero funciona. La clave es la información de depuración que se genera de manera automática. Al eliminarla se reduce el peso y se mejora la velocidad.####[JavaScript] : La fatiga de frameworks comparada.Empiezo por la consabida broma de pedir una moratoria en el desarrollo de armas… digo de frameworks JavaScript . Mientras tanto mira esta tabla que compara la sintaxis de librerías muy populares.####[NodeJS] : Monitorizar aplicaciones bien y fácil.Si no sabes lo que hace tu aplicación estás perdido. Lo primero que necesitas es una estrategia para generar logs. En Node tienes muchas opciones. Además del console.log(‘ ;-) ‘).####[MongoDB] : Rendimiento y Monitorización de MongoDB.Ahora le toca a la base de datos. No es fácil entender ni usar correctamente la enorme cantidad de métricas que ofrece MongoDB. Pero es fundamental conocer y aplicar algunas para controlar y escalar las instalciones.####[CleanCode] : Escribe código pensando en mantenerlo.Escribimos una vez pero revisamos 20. Nosotros, nuestros compañeros y nuestros herederos. Unos cuantos consejos y buenas prácticas te ayudarán a tratar con lo heredado y a dejar mejores herencias.###Próximas actividadesEste es el mes de Angular2. Su estreno como Release Candidate permite ofrecer formación con garantías. Nos vemos.Keep coding, keep learning."},{"title":"Promociones","date":"2016-05-10T11:53:10.000Z","updated":"2016-05-27T06:46:03.000Z","comments":true,"path":"promociones.html","permalink":"https://academia-binaria.com/promociones.html","excerpt":"","text":"#Cursos de Angular2####OnlineInicio 9 de junio de 2016###Angular 2, desarrollo de aplicaciones empresariales con HTMLCon EscuelaIT####Presencial en CoruñaInicio 10 de junio de 2016###A Coruña : Curso en Abierto de Angular2, TypeScript y Estrategias de Migración de versiones 1.xCon Vitae Digital"},{"title":"[object Object]","date":"2017-10-31T10:46:44.448Z","updated":"2017-10-31T10:46:44.448Z","comments":true,"path":"scaffolds/draft.html","permalink":"https://academia-binaria.com/scaffolds/draft.html","excerpt":"","text":""},{"title":"[object Object]","date":"2017-10-31T10:46:44.450Z","updated":"2017-10-31T10:46:44.450Z","comments":true,"path":"scaffolds/page.html","permalink":"https://academia-binaria.com/scaffolds/page.html","excerpt":"","text":""},{"title":"[object Object]","date":"2017-10-31T10:46:44.452Z","updated":"2017-10-31T10:46:44.452Z","comments":true,"path":"scaffolds/post.html","permalink":"https://academia-binaria.com/scaffolds/post.html","excerpt":"","text":""}],"posts":[{"title":"Servicios inyectables en Angular","slug":"servicios-inyectables-en-Angular","date":"2019-02-15T08:54:58.000Z","updated":"2019-02-15T08:50:05.473Z","comments":true,"path":"servicios-inyectables-en-Angular/","link":"","permalink":"https://academia-binaria.com/servicios-inyectables-en-Angular/","excerpt":"La presentación, la lógica y el manejo de datos son tres capas de abstracción que usamos los programadores para mantener organizado nuestro código. En Angular 7, la presentación es cosa de los componentes. La lógica y los datos tienen su lugar en servicios compartidos.Para que los componentes consuman los servicios de forma controlada tenemos proveedores inyectables en la librería @angular/core con los que realizar la inyección de dependencias.","text":"La presentación, la lógica y el manejo de datos son tres capas de abstracción que usamos los programadores para mantener organizado nuestro código. En Angular 7, la presentación es cosa de los componentes. La lógica y los datos tienen su lugar en servicios compartidos.Para que los componentes consuman los servicios de forma controlada tenemos proveedores inyectables en la librería @angular/core con los que realizar la inyección de dependencias.Partiendo de la aplicación tal cómo quedó en Flujo de datos entre componentes Angular. Al finalizar tendrás una aplicación que comunica componentes entre páginas, reparte responsabilidades y gestiona claramente sus dependencias.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-board/4-flowTienes una versión desplegada operativa para probar Angular Board1. Inyección de dependenciasComo casi todo en Angular, los servicios son clases TypeScript. Su propósito es contener lógica de negocio, clases para acceso a datos o utilidades de infraestructura. Estas clases son perfectamente instanciables desde cualquier otro fichero que las importe. Pero Angular nos sugiere y facilita que usemos su sistema de inyección de dependencias.Este sistema se basa en convenios y configuraciones que controlan la instancia concreta que será inyectada al objeto dependiente. Ahora verás cómo funciona la Dependency Injection en Angular.Como demostración vamos a trabajar con un par de utilidades para conversión de unidades. Crearé un módulo y un componente en el que visualizarlo.12ng g m 5-inject/converter --routing trueng g c 5-inject/converter/converter1.1 Generación de serviciosLa particularidad de las clases de servicios está en su decorador: @Injectable(). Esta función viene en el @angular/core e indica que esta clase puede ser inyectada dinámicamente a quien la demande. Aunque es muy sencillo crearlos a mano, el CLI nos ofrece su comando especializado para crear servicios. Estos son ejemplos de instrucciones para crear un service.1ng g s 5-inject/converter/converterEl resultado es el fichero converter.service.ts con su decorador que toma una class normal y produce algo injectable. Veamos una implementación mínima:12345678910import &#123; Injectable &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root'&#125;)export class ConverterService &#123; constructor() &#123;&#125; public fromKilometersToMiles = (kilometers) =&gt; kilometers * 0.62137;&#125;Ahora tienes centralizado en este servicio la lógica de datos que tenemos hasta el momento. Los demás componentes la podrán utilizar.1.2 Consumo de dependenciasDeclarar y decorar la clase no es suficiente para poder reclamarla. Necesitas registrarla como un proveedor en algún módulo. Desde Angular 6 los servicios se auto-proveen en el módulo raíz mediante la configuración providedIn: &#39;root&#39; de su decorador.Esto es útil y cómodo en una gran cantidad de casos. El módulo raíz es visible para toda la aplicación de forma que cualquier componente puede reclamar un servicio suyo sin problema. Excepto que el problema sea el tamaño. El módulo raíz se carga al arrancar y todas sus referencias van el bundle principal. Si queremos repartir el peso debemos llevar ciertos servicios al módulo funcional que los necesite.Vamos a consumir este servicio en el converter.component.ts. Al consumo de los servicios inyectables se le conoce como dependencia. Cada componente o servicio puede declarar en su constructor sus dependencias hacia servicios inyectables. El convenio exige que se especifique el tipo esperado123456789101112export class ConverterComponent implements OnInit &#123; public kilometers = 0; public miles: number; constructor(private converterService: ConverterService) &#123;&#125; public ngOnInit() &#123; this.convert(); &#125; public convert() &#123; this.miles = this.converterService.fromKilometersToMiles(this.kilometers); &#125;&#125;Agregar el modificador de alcance private o public en la declaración de argumentos hace que TypeScript genere una propiedad inicializada con el valor recibido. Es azúcar sintáctico para no tener que declarar la propiedad y asignarle el valor del argumento manualmente. En resumen, los constructores en TypeScrip admiten argumentos que transforman en propiedades. Mantenemos privado el converterService para evitar su uso desde la vista.1234567891011121314151617&lt;h2&gt; Distance Converter.&lt;/h2&gt;&lt;h3&gt; From Europe to USA &lt;/h3&gt;&lt;form&gt; &lt;fieldset&gt; &lt;section&gt; &lt;label for=\"kilometers\"&gt;Kilometers&lt;/label&gt; &lt;input name=\"kilometers\" type=\"number\" [(ngModel)]=\"kilometers\" placeholder=\"0\" /&gt; &lt;/section&gt; &lt;/fieldset&gt; &lt;input value=\"Convert\" type=\"button\" (click)=\"convert()\"&gt;&lt;/form&gt;&lt;section&gt; &lt;h4&gt;&#123;&#123; miles | number:'1.2-2' &#125;&#125; miles&lt;/h4&gt;&lt;/section&gt;2. Inversión del controlUn concepto íntimamente relacionado con la inyección de dependencias es el de Inversion of Control. El componente dependiente expresa sus necesidades, pero es el framework el que en última instancia decide lo que recibirá. Vemos entonces que el invocado cede el control al invocador.Cuando proveemos un servicio en Angular, el comportamiento por defecto es el de proveer un singleton pero hay más opciones. Si se usa el objeto provider con useClass , useValue y useFactory podemos controlar el proceso de inyección.Se crea un singleton por cada módulo en el que se provea un servicio. Normalmente si el servicio es para un sólo módulo funcional se provee en este y nada más. Si va a ser compartido gana la opción de auto proveerlo en el raíz, garantizando así su disponibilidad en cualquier otro módulo de la aplicación.En un módulo cualquiera, siempre podríamos agregar un servicio a su array de providers.12345@NgModule(&#123; declarations: [...], imports: [...], providers: [ ConverterService ]&#125;)Pero siempre será una instancia única por módulo. Si un singleton no es lo adecuado, entonces puedes proveer el mismo servicio en distintos módulos. De esa forma se creará una instancia distinta para cada uno. Si se provee la misma clase en dos o más módulos se genera una instancia en cada uno de ellos. Los componentes recibirán la instancia del módulo jerárquicamente más cercano.Incluso es posible usar el array providers:[] en la decoración de un componente o de otro servicio. Haciendo así aún más granular la elección de instancia.Veamos un ejemplo extendiendo el problema del conversor de unidades de forma que se pueda escoger una estrategia de conversión en base a una cultura concreta. Para empezar necesitamos una interfaz, un servicio base que la implemente y un componente que lo consuma.123ng g interface 5-inject/converter/culture-converterng g service 5-inject/converter/culture-converterng g component 5-inject/converter/culture-converter123456export interface CultureConverter &#123; sourceCulture: string; targetCulture: string; convertDistance: (source: number) =&gt; number; convertTemperature: (source: number) =&gt; number;&#125;12345678export class CultureConverterService implements CultureConverter &#123; sourceCulture: string; targetCulture: string; convertDistance: (source: number) =&gt; number; convertTemperature: (source: number) =&gt; number; constructor() &#123;&#125;&#125;1234567891011121314151617export class CultureConverterComponent implements OnInit &#123; public source: string; public target: string; public sourceUnits = 0; public targetUnits: number; constructor(private cultureConverterService:CultureConverterService)&#123; &#125; public ngOnInit() &#123; this.source = this.cultureConverterService.sourceCulture; this.target = this.cultureConverterService.targetCulture; this.convert(); &#125; public convert() &#123; this.targetUnits = this.cultureConverterService.convertDistance(this.sourceUnits); &#125;&#125;1234567891011121314151617&lt;h2&gt; Culture Converter.&lt;/h2&gt;&lt;h3&gt; From &#123;&#123; source &#125;&#125; to &#123;&#123; target &#125;&#125; &lt;/h3&gt;&lt;form&gt; &lt;fieldset&gt; &lt;section&gt; &lt;label for=\"sourceUnits\"&gt;Distance&lt;/label&gt; &lt;input name=\"sourceUnits\" type=\"number\" [(ngModel)]=\"sourceUnits\" placeholder=\"0\" /&gt; &lt;/section&gt; &lt;/fieldset&gt; &lt;input value=\"Convert\" type=\"button\" (click)=\"convert()\"&gt;&lt;/form&gt;&lt;section&gt; &lt;h4&gt;Distance &#123;&#123; targetUnits | number:'1.2-2' &#125;&#125; &lt;/h4&gt;&lt;/section&gt;2.2 ImplementacionesEl CultureConverterComponent depende de CultureConverterService el cual implementa de forma abstracta la interfaz CultureConverter. Pero eso no es para nada funcional. Vamos a crear dos implementaciones específicas para Europa y USA. Estas clases concretas se apoyarán en el anteriormente creado ConverterService que necesita algo más de código.1234567891011export class ConverterService &#123; constructor() &#123;&#125; public fromKilometersToMiles = (kilometers) =&gt;kilometers * 0.62137; public fromMilesToKilometers = (miles) =&gt; miles * 1.609; public fromCelsiusToFarenheit = (celsius) =&gt; celsius * (9 / 5) + 32; public fromFarenheitToCelsius = (farenheit) =&gt; (farenheit - 32) * (5 / 9);&#125;Y aquí están las dos servicios concretos.12345678@Injectable()export class EuropeConverterService &#123; sourceCulture = 'USA'; targetCulture = 'Europe'; constructor(private converterService: ConverterService) &#123;&#125; convertDistance = this.converterService.fromMilesToKilometers; convertTemperature = this.converterService.fromFarenheitToCelsius;&#125;12345678@Injectable()export class UsaConverterService implements CultureConverter &#123; sourceCulture = 'Europe'; targetCulture = 'USA'; constructor(private converterService: ConverterService) &#123;&#125; convertDistance = this.converterService.fromKilometersToMiles; convertTemperature = this.converterService.fromCelsiusToFarenheit;&#125;2.3 Provisión manualPor ejemplo si queremos utilizar la implementación concreta de USA lo indicamos en el módulo que lo consuma.12345678&#123; providers: [ &#123; provide: CultureConverterService, useClass: UsaConverterService &#125; ]&#125;El componente reclama una instancia de CultureConverterService y le damos otra con la misma interfaz. De esta forma podríamos tener módulos distintos, cada uno con su propia estrategia de conversión.2.4 FactoríaUna situación muy común es poder elegir dinámicamente la implementación concreta. Para ello necesitamos una función factoría que con alguna lógica escoja la estrategia concreta.12345678910111213141516const cultureFactory = (converterService: ConverterService) =&gt; &#123; if (environment.unitsCulture === 'metric') &#123; return new EuropeConverterService(converterService); &#125; else &#123; return new UsaConverterService(converterService); &#125;&#125;;&#123; providers: [ &#123; provide: CultureConverterService, useFactory: cultureFactory, deps: [ConverterService] &#125; ]&#125;De esta forma la aplicación se comportará distinto en función de una variable de entorno.Ya tenemos la aplicación mucho mejor estructurada, pero el almacén de datos es mejorable. Se mantienen los datos hard-coded, muy incómodo para actualizar; y en memoria, poco fiable y volátil. Lo más habitual es guardar y recuperar la información en un servidor http. Sigue esta serie para añadir Comunicaciones HTTP en Angular mientras aprendes a programar con Angular.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"DI","slug":"DI","permalink":"https://academia-binaria.com/tag/DI/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Servicios","slug":"Servicios","permalink":"https://academia-binaria.com/tag/Servicios/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"}]},{"title":"Flujo de datos entre componentes Angular","slug":"flujo-de-datos-entre-componentes-angular","date":"2019-02-12T15:10:44.000Z","updated":"2019-02-14T10:46:47.884Z","comments":true,"path":"flujo-de-datos-entre-componentes-angular/","link":"","permalink":"https://academia-binaria.com/flujo-de-datos-entre-componentes-angular/","excerpt":"Los desarrollos profesionales son complicados pero con Angular tenemos soluciones de comunicación simples para pantallas complejas. Mediante el desarrollo de componentes atómicos y reutilizables Angular 7 favorece la implementación de buenas prácticas.Crear y comunicar muchos componentes puede llevarnos a código difícil de seguir. La librería @angular/forms ofrece tuberías de comunicación para mantener el flujo de datos bajo control.","text":"Los desarrollos profesionales son complicados pero con Angular tenemos soluciones de comunicación simples para pantallas complejas. Mediante el desarrollo de componentes atómicos y reutilizables Angular 7 favorece la implementación de buenas prácticas.Crear y comunicar muchos componentes puede llevarnos a código difícil de seguir. La librería @angular/forms ofrece tuberías de comunicación para mantener el flujo de datos bajo control.Partiendo de la aplicación tal cómo quedó en Formularios, tablas y modelos de datos en Angular. Al finalizar tendrás una aplicación que reparte la responsabilidad de recoger y presentar datos en componentes.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-board/4-flowTienes una versión desplegada operativa para probar Angular Board1. Comunicación entre componentesLas aplicaciones web en las que destaca Angular suelen ser complejas y con mucha variedad funcional en diversas páginas. A menudo esas páginas están repletas de formularios, informes y botones. La solución viene de mano del viejo principio divide y vencerás: La componentización1.1. Necesidad de comunicaciónEl framework permite y recomienda repartir el trabajo en múltiples componentes de responsabilidad única. También es práctica común el crear páginas específicas para situaciones concretas aunque relacionadas. Por supuesto que estructuras como el menú de navegación o secciones de estado general necesitan conocer datos provenientes de las páginas. Nada está completamente asilado. Esto nos enfrenta la problema de comunicar componentes.1.2. EscenariosLas situaciones que te encontrarás caerán en alguna de estas tres categorías para las que hay soluciones específicas.Comunicar componentes acopladosSolemos empezar creando un componente por página. Pero es normal que esa página se complique y la solución a la complejidad es la división en componentes y reparto de responsabilidades. Dado que están en una misma página existe cierto acoplamiento entre ellos y eso nos facilitará la comunicación.Comunicar componentes en páginas distintasCuando los componentes se carga en rutas distintas ya no hay forma de comunicarlos directamente. Pero lo resolveremos fácilmente usando las capacidades del router.Comunicar componentes entre estructuras dinámicasLa situación más compleja se da cuando queremos comunicar componentes o servicios desacoplados pero sin cambio de página. En este caso hará falta un mediador observable.2. El patrón Contendor / PresentadoresEn arquitectura de software cuando encontramos una solución a un problema recurrente le ponemos un nombre y tratamos de utilizarlo siempre que podemos. Obviamente es una elección del programador y siempre tiene un coste que debe valorar. En este caso la ventaja es clara: reparto de responsabilidades.2.1 El patrónEn este caso el patrón contendor/presentadores estipula que haya un único componente responsable de obtener, mutar y guardar el estado. Será el componente contenedor. Los presentadores serán responsables de.. ejem, presentar la información y los elementos de interacción con el usuario. Las ventajas derivadas son: mayor facilidad para el testeo y mayores posibilidades de reutilización de presentadores.A este patrón a veces se le conoce como parent/children por la jerarquía html que genera.Veamos una implementación sencilla. Haremos una interfaz mínima para simular el manejo de un coche. Habrá pedales de aceleración y freno, y un cuadro dónde se refleje la velocidad. Para todo ello vamos a usa el Angular CLI y crear un módulo y sus componentes base.1234ng g m 4-flow/carng g c 4-flow/car/carng g c 4-flow/car/car/displayng g c 4-flow/car/car/pedalsAgregamos una ruta en el enrutador con su enlace en el menú.1234&#123; path: 'car', loadChildren: './car/car.module#CarModule'&#125;123&lt;a routerLink=\"car\" class=\"button\"&gt; &lt;span&gt; 4 - Car&lt;/span&gt;&lt;/a&gt;2.2 El contendorEn el componente contenedor tendremos una vista muy sencilla y un controlador más complejo. La vista será la composición de los componentes presentadores, pero el controlador tendrá que obtener datos, aplicarles lógica de negocio y guardarlos cuando corresponda.No es habitual asignarle un sufijo al nombre del componente para indicar que es el contendor. Suele ser suficiente el verlo en la raíz de la jerarquía de carpetas.12345678910&lt;app-display [model]=\"car.name\" [currentSpeed]=\"car.currentSpeed\" [topSpeed]=\"car.maxSpeed\" [units]=\"'Km/h'\"&gt;&lt;/app-display&gt;&lt;app-pedals (brake)=\"onBrake($event)\" [disableBrake]=\"disableBrake\" (throttle)=\"onThrottle($event)\" [disableThrottle]=\"disableThrottle\"&gt;&lt;/app-pedals&gt;Vemos que usa los componentes presentadores Display y Pedals enviándoles información y suscribiéndose a sus eventos. Concretaremos esta funcionalidad más adelante.12345678910111213141516171819202122232425262728293031public car: CarModel;public disableBrake: boolean;public disableThrottle: boolean;constructor() &#123;&#125;public ngOnInit() &#123; this.car = &#123; name: 'Roadster', maxSpeed: 120, currentSpeed: 0 &#125;; this.checkLimits();&#125;private checkLimits() &#123; this.disableBrake = false; this.disableThrottle = false; if (this.car.currentSpeed &lt;= 0) &#123; this.car.currentSpeed = 0; this.disableBrake = true; &#125; else if (this.car.currentSpeed &gt;= this.car.maxSpeed) &#123; this.car.currentSpeed = this.car.maxSpeed; this.disableThrottle = true; &#125;&#125;public onBrake(drive: number) &#123; this.car.currentSpeed -= this.getDelta(drive); this.checkLimits();&#125;public onThrottle(drive: number) &#123; this.car.currentSpeed += this.getDelta(drive); this.checkLimits();&#125;private getDelta = (drive: number) =&gt; drive + (this.car.maxSpeed - this.car.currentSpeed) / 10;Lo dicho, la clase controladora del componente contendor retiene el grueso de la funcionalidad. En este caso inicializar una instancia de un coche y mantener sus velocidad en los límites lógicos respondiendo a las acciones del usuario conductor.2.3 Envío hacia el presentador con @Input()Esta comunicación hacia abajo envía la información desde el contenedor hacia el presentador. Es similar a como una plantilla recibe la información desde el controlador.@Input()Para que una vista muestre datos tiene que usar directivas como asociada a una propiedad pública de la clase componente. Se supone que dicha clase es la responsable de su valor. Pero también puede recibirlo desde el exterior. La novedad es hacer que lo reciba vía html.1234567891011&lt;h2&gt; &#123;&#123; model &#125;&#125; &lt;/h2&gt;&lt;h3&gt; Top speed: &#123;&#123; topSpeed | number:'1.0-0' &#125;&#125;&lt;/h3&gt;&lt;div class=\"card\"&gt; &lt;div class=\"section\"&gt; &#123;&#123; currentSpeed | number:'1.2-2' &#125;&#125; &#123;&#123; units &#125;&#125; &lt;/div&gt; &lt;progress [value]=\"currentSpeed\" [ngClass]=\"getSpeedClass()\" [max]=\"topSpeed\"&gt; &lt;/progress&gt;&lt;/div&gt;Empieza por decorar con @Input() la propiedad que quieres usar desde fuera. Por ejemplo un código como este del archivo display.component.ts.1234567891011export class DisplayComponent implements OnInit &#123; @Input() public model: string; @Input() public currentSpeed: number; @Input() public topSpeed: number; @Input() public units: string; constructor() &#123;&#125; ngOnInit() &#123;&#125; public getSpeedClass = () =&gt; this.currentSpeed &lt; this.getThreshold() ? 'primary' : 'secondary'; private getThreshold = () =&gt; this.topSpeed * 0.8;&#125;Ahora puedes enviarle datos a este componente desde el html de su consumidor. Por ejemplo desde car.component.html le puedo enviar una variable o cualquier expresión evaluable. Recordemos como usa [propiedad]=&quot;expresion&quot; en el elemento presentador.12345&lt;app-display [model]=\"car.name\" [currentSpeed]=\"car.currentSpeed\" [topSpeed]=\"car.maxSpeed\" [units]=\"'Km/h'\"&gt;&lt;/app-display&gt;En la clase controladora del presentador quedan responsabilidades reducidas a temas específicos como determinar las clases css apropiadas o transformar los datos para su presentación.Estoy usando al componente de nivel inferior como un presentador; mientras que el contenedor superior actúa como controlador. Este mismo patrón puede y debe repetirse hasta descomponer las vistas en estructuras simples que nos eviten repeticiones absurdas en código.De esta forma es fácil crear componentes reutilizables; y queda muy limpio el envío de datos hacia abajo. Pero, ¿y hacia arriba?.2.4. Respuesta del presentador con @Output()Los componentes de nivel inferior no sólo se dedican a presentar datos, también presentan controles. Con ellos el usuario podrá crear, modificar o eliminar los datos que quiera. Aunque no directamente; para hacerlo comunican el cambio requerido al contenedor de nivel superior.@Output()Por ejemplo, el componente PedalsComponent permite acelerar y frenar. Bueno, realmente permite que el usuario diga que lo quiere hacer; los cambios se harán más arriba. Veamos lo básico del pedals.component.html antes de nada:12345678910111213&lt;h3&gt; Pedals: &lt;/h3&gt;&lt;form&gt; &lt;input value=\"brake\" class=\"secondary\" type=\"button\" [disabled]=\"disableBrake\" (click)=\"brake.emit(1)\"/&gt; &lt;input value=\"throttle\" class=\"tertiary\" type=\"button\" [disabled]=\"disableThrottle\" (click)=\"throttle.emit(1)\"/&gt;&lt;/form&gt;Claramente son un par de botones que con el evento (click) responden a acciones del usuario. En este caso se manifiesta una intención de acelerar o frenar el coche. Pero el método del controlador no actúa directamente sobre los datos.Si lo hiciera sería más difícil gestionar los cambios e imposibilitaría el uso de inmutables o técnicas más avanzadas de programación que se verán más adelante…En su lugar, lo que hace es emitir un evento confiando que alguien lo reciba y actúe en consecuencia. Por ejemplo la emisión de la instrucción de frenado se realiza mediante la propiedad brake decorada con @Output() public brake new EventEmitter&lt;number&gt;();. Dicha propiedad será una instancia de un emisor de eventos que mediante el método .next() que emite la señal hacia arriba.12345678export class PedalsComponent implements OnInit &#123; @Input() public disableBrake: boolean; @Input() public disableThrottle: boolean; @Output() public brake = new EventEmitter&lt;number&gt;(); @Output() public throttle = new EventEmitter&lt;number&gt;(); constructor() &#123;&#125; ngOnInit() &#123;&#125;&#125;Mientras tanto, en el contenedor la vista se subscribe al evento (brake) como si este fuese un evento nativo y llama a los métodos que manipulan los datos de verdad.12345&lt;app-pedals (brake)=\"onBrake($event)\" [disableBrake]=\"disableBrake\" (throttle)=\"onThrottle($event)\" [disableThrottle]=\"disableThrottle\"&gt;&lt;/app-pedals&gt;Las propiedades output también pueden enviar argumentos que serán recibidos mediante el identificador $event propio del framework. Se declaran especificando el tipo del argumento en el genérico del constructor de EventEmitter&lt;any&gt;.En el controlador ya podemos operar con los datos. El método onBrake(drive: number) accede y modifica el valor de la velocidad y lo notifica automáticamente hacia abajo.De esta manera se cierra el círculo. Los componentes de bajo nivel pueden recibir datos para ser presentados o emitir eventos para modificarlos. El componente de nivel superior es el único responsable de obtener y actuar sobre los datos.3. Comunicaciones entre páginas o estructuras3.1 Comunicación entre distintas páginasEn las aplicaciones hay comunicaciones de estado más allá de la página actual. La comunicación entre páginas es responsabilidad del @angular/router. Una vez activada una ruta, el sistema carga un componente en el &lt;router-outlet&gt; correspondiente. No hay forma de comunicarse hacia (arriba) o [abajo] con algo desconocido. De una página a otra tampoco es problema pues la comunicación va mediante los parámetros de la url.Ya hemos usado esta comunicación anteriormente en el tema 2-spa el componente AuthorComponent es capaz de recibir por parámetros una identificación de un autor. Esa información es el resultado de una acción del usuario en la pantalla /about/authors programada en el componente AuthorsComponent. Por tanto es una comunicación entre componentes, en la que ambos son controladores hermanos.Desde luego habrá que mejorar el acceso y control de los datos que por ahora es muy rudimentario. Lo haremos en próximos pasos. Primero mediante Servicios inyectables en Angular y después usando Comunicaciones HTTP en Angular2.2 Comunicación entre estructuras desacopladasEstando en la misma ruta, no siempre se podrán conocer los componentes, y por tanto no se podrán usar sus [propiedades] y (eventos)2.2.1 El layout principal y los componentes por ruta páginas.Una situación habitual es comunicar la vista de negocio activa con elementos generales de la página. Por ejemplo podrías querer mostrar la velocidad máxima alcanzada en la barra del menú o un un mensaje emergente cada vez que se alcance la velocidad límite. En este caso, el &lt;router-outlet&gt; es una barrera que impide usar el patrón contendor-presentador pues no se puede predecir el contenido dinámico que carga el RouterOutlet.2.2.2 Múltiples niveles de presentadores.Cuando las pantallas se hacen realmente complejas empiezan a surgir árboles de componentes de muchos niveles de profundidad. En estas situaciones mantener un único controlador a nivel raíz es poco práctico. Enviar hacia abajo las [propiedades] es tedioso, pero peor aún es hacer burbujear los (eventos) por varias capas de presentadores.La solución en ambos casos pasa por permitir que algunos componentes presentadores tengan su propio control de datos. Este tipo de comunicaciones técnicamente se resuelve mediante Observables y merece un capítulo especial que se verá más adelante en esta serie. Incluso en situaciones complejas habrá que optar por patrones avanzados de gestión de estado como pueda ser Redux.Por ahora tienes una aplicación en Angular que comunica datos y cambios entre componentes de una misma página. Sigue el tutorial para añadirle Servicios inyectables en Angular mientras aprendes a programar con Angular 7.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Components","slug":"Components","permalink":"https://academia-binaria.com/tag/Components/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"}]},{"title":"Formularios, tablas y modelos de datos en Angular","slug":"formularios-tablas-y-modelos-de-datos-en-angular","date":"2019-01-31T18:17:37.000Z","updated":"2019-02-12T16:22:50.019Z","comments":true,"path":"formularios-tablas-y-modelos-de-datos-en-angular/","link":"","permalink":"https://academia-binaria.com/formularios-tablas-y-modelos-de-datos-en-angular/","excerpt":"Las aplicaciones Angular 7 son excelentes para el tratamiento de datos en el navegador. Su razón de ser fue la recogida de información mediante formularios y la presentación de páginas dinámicas de forma sencilla.Vamos a ver cómo la librería @angular/forms enlaza las vistas, los controladores y los modelos; y cómo se hace la presentación de datos en listas y tablas.","text":"Las aplicaciones Angular 7 son excelentes para el tratamiento de datos en el navegador. Su razón de ser fue la recogida de información mediante formularios y la presentación de páginas dinámicas de forma sencilla.Vamos a ver cómo la librería @angular/forms enlaza las vistas, los controladores y los modelos; y cómo se hace la presentación de datos en listas y tablas.Partiendo de la aplicación tal cómo quedó en Páginas y rutas Angular SPA, al finalizar tendrás una aplicación que recoge y presenta datos.Código asociado a este artículo en GitHub: [AcademiaBinaria/angular-board/3-data]https://github.com/AcademiaBinaria/angular-board/tree/master/src/app/3-data/contacts)1. Binding1.0 BaseLos formularios son el punto de entrada de información a nuestros sistemas. Llevan con nosotros desde el inicio de la propia informática y se han comido una buena parte del tiempo de programación. En Angular han prestado una especial atención a ellos facilitando su desarrollo, desde pantallas simples hasta complejos procesos.Para empezar crearemos un proceso sencillo. algo que permita mantener una lista de contactos empresariales. Con lo aprendido en el tema de Páginas y rutas Angular SPA creamos un par de ficheros.12ng g m contacts --routing trueng g c contacts/contactsY asignamos sus rutas delegadas en app-routing y en contacts-routing:12345678910// app-routing&#123; path: 'contacts', loadChildren: './contacts/contacts.module#ContactsModule'&#125;,// contacts-routing&#123; path: '', component: ContactsComponent&#125;Y finalizamos con un enlace en el HeaderComponent123&lt;a routerLink=\"contacts\" class=\"button\"&gt; &lt;span&gt; Contacts&lt;/span&gt;&lt;/a&gt;La clave para entender cómo funciona Angular está en el concepto de enlace entre elementos html de las vistas y propiedades de modelos de datos, el llamado binding.Para realizar el binding usaremos directivas en ambos sentidos.1.1 Enlace del modelo hacia la vistaVamos a crear un pequeño modelo de datos. Para empezar agregamos algunas propiedades. En contacts.component.ts:12345public header = 'Contacts';public description = 'Manage your contact list';public numContacts = 0;public counterClass = 'tag secondary';public formHidden = false;En contacts.component.html mostramos cabeceras con estilo1234567&lt;h2&gt;&#123;&#123; header &#125;&#125;&lt;/h2&gt;&lt;p&gt;&#123;&#123; description | uppercase &#125;&#125;&lt;/p&gt;&lt;p&gt; You have &lt;mark [class]=\"counterClass\"&gt;&#123;&#123; numContacts &#125;&#125;&lt;/mark&gt; contacts right now.&lt;/p&gt;La interpolación entre { { } }En el fichero contacts.component.ts tienes en su vista html encontrarás elementos ajenos al lenguaje. Son las directivas. La primera que encuentras es . Esas dobles llaves encierran expresiones que se evaluarán en tiempo de ejecución. La llamamos directiva de interpolación y es la manera más cómoda y usual de mostrar contenido dinámico en Angular.La expresión interna hace referencia a variables que se obtienen de las propiedades de la clase controladora del componente. En este caso ContactsComponent y header, con su valor Contacts en ejecución. Este enlace mantiene la vista permanentemente actualizada a través de un potente sistema de detección del cambio.Las tuberías |Si queremos que la presentación del dato sea distinta a su valor real, podemos usar funciones de transformación especiales. Se llaman tuberías o pipes y se indican mediante el carácter |.El framework nos provee de casos básicos como uppercase, lowercase, date, number.... También dispones de un mecanismo para crear tus propios pipes.Los atributos evaluados []En Html disponemos de atributos para asignar valores a propiedades de los elementos. Esos atributos reciben los valores como constantes. Pero, si se encierran entre corchetes se convierten en un evaluador de expresiones y puede recibir una variable o cualquier otra expresión.Como por ejemplo usando una clase css cuyo valor cambia en tiempo de ejecución. O para deshabilitar un elemento dinámicamente.1.2 Enlace de la vista hacia el modeloEn contacts.component.html también actuamos sobre la vista, para manipular el modelo… y de vuelta a la vista. Por ejemplo con mecanismo simple de ocultación de un elemento.12345&lt;input value=\"Show Form\" type=\"button\" (click)=\"formHidden = false\" /&gt;&lt;input value=\"Hide Form\" type=\"button\" (click)=\"formHidden = true\" /&gt;&lt;form [ngClass]=\"&#123; 'hidden' : formHidden &#125;\"&gt; &lt;fieldset&gt;&lt;legend&gt;Contact Form&lt;/legend&gt;&lt;/fieldset&gt;&lt;/form&gt;Las clases CSS como atributos especialesPara el caso concreto de determinar las clases CSS aplicables a un elemento de manera dinámica, usaremos la directiva ngClass. La cual recibe un objeto cuyas propiedades son nombres de clases CSS y sus valores son expresiones booleanas. Si se cumplen se aplica la clase y si no, se quita la clase.1[ngClass]=\"&#123; 'hidden' : formHidden &#125;\"En este caso se oculta el elemento dependiendo del valor de la expresión formHidden. Pero ¿Cómo se manipula esa variable?Los eventos ()Cualquier evento asociado a un elemento puede ejecutar una instrucción sin más que incluirlo entre paréntesis. Idealmente dicha instrucción debe llamar a un método o función de la clase controladora. Aunque si es trivial puedes dejarla en el Html.1(click)=\"formHidden = true\"2. Doble BindingLa comunicación del modelo hacia la vista es sólo el principio. En Angular también podrás comunicar la vista hacia el modelo, permitiéndole al usuario modificar los datos a través de formularios. Es lo que se conoce como double binding.2.1 El doble enlace al modelo [(ngModel)]La directiva [(ngModel)] se compone de un atributo custom ngModel y lo rodea de los símbolos [()]. Esta técnica es conocida como banana in a box porque su sintaxis requiere un () dentro de un [] y une las capacidades de las expresiones y los eventos facilitando la comunicación bidireccional.1[(ngModel)]=\"model.property\"Usa la comunicación en ambos sentidos(banana) : de la vista al modelo[box] : del modelo a la vistaAtención: La directiva ngModel viene dentro del módulo FormsModule que hay que importar explícitamente.Por ejemplo [(ngModel)]=&quot;contact.name&quot; enlaza doblemente la propiedad del modelo contact.name con el elemento &lt;input&gt; de la vista. Cada tecleo del usuario se registra en la variable. Y el valor de la variable se muestra en el &lt;input&gt;.Dada un modelo como este en contacts.component.ts:1public contact = &#123; name: '' &#125;;Podemos enlazarlos en la plantilla1234&lt;section&gt; &lt;label for=\"name\"&gt;Name&lt;/label&gt; &lt;input name=\"name\" type=\"text\" [(ngModel)]=\"contact.name\" placeholder=\"Contact name\" /&gt;&lt;/section&gt;Es muy útil mantener en desarrollo un espía visual de lo que está pasando con los datos. Algunas extensiones como Augury aportan muchas más prestaciones, pero al empezar el pipe json te ayudará mucho.1&lt;pre&gt;&#123;&#123; contact | json &#125;&#125;&lt;/pre&gt;La directiva ngModel es mucho más potente de lo visto aquí. Entre otras cosas permite decidir el criterio de actualización (a cada cambio o al salir del control). También se verá más adelante el asunto de la validación, que requiere un trato especial. Cuando empiezas con Angular Forms, un input y su ngModel asociado serán tus mejores amigos.2.2 FormHay más usos de las directivas en los formularios. Por ejemplo, dado el siguiente modelo:1public contact = &#123; name: '', isVIP: false, gender: '' &#125;;Le vendría muy bien un check box.CheckBox1234&lt;section&gt; &lt;label for=\"isVIP\"&gt;Is V.I.P.&lt;/label&gt; &lt;input name=\"isVIP\" type=\"checkbox\" [(ngModel)]=\"contact.isVIP\" /&gt;&lt;/section&gt;Y un para de radio buttons.Radio Buttons1234567&lt;section&gt; &lt;label for=\"gender\"&gt;Gender&lt;/label&gt; &lt;input name=\"gender\" value=\"male\" type=\"radio\" [(ngModel)]=\"contact.gender\" /&gt; &lt;i&gt;Male&lt;/i&gt; &lt;input name=\"gender\" value=\"female\" type=\"radio\" [(ngModel)]=\"contact.gender\" /&gt; &lt;i&gt;Female&lt;/i&gt;&lt;/section&gt;3 EstructurasLos anteriores modificadores actúan a nivel de contenido del HTML. Veremos ahora una para de directivas que afectan directamente a la estructura del árbol DOM. Son las llamadas directivas estructurales que comienzan por el signo *3.1 Repetitivas *ngForUna situación que nos encontramos una y otra vez es la de las repeticiones. Listas de datos, tablas o grupos de opciones son ejemplos claros. Hay una directiva en Angular para esa situación, la *ngFor=&quot;let iterador of array&quot;. La directiva *ngFor forma parte del grupo de directivas estructurales, porque modifica la estructura del DOM, en este caso insertando múltiples nodos hijos a un elemento dado.Puedes ver un ejemplo del uso la directiva *ngFor en el componente ContactsComponent. Se emplea para recorrer un array de tipos de estado laboral. Es el caso de uso más repetido de las repeticiones; mostrar listas de datos.Dado el siguiente modelo:1234567public workStatuses = [ &#123; id: 0, description: 'unknow' &#125;, &#123; id: 1, description: 'student' &#125;, &#123; id: 2, description: 'unemployed' &#125;, &#123; id: 3, description: 'employed' &#125;];public contact = &#123; name: '', isVIP: false, gender: '', workStatus: 0 &#125;;Montamos las opciones de un select html recorriendo el array y usando el iterador wkSt para acceder a sus datos.12345678&lt;section&gt; &lt;label for=\"workStatus\"&gt;Work Status&lt;/label&gt; &lt;select name=\"workStatus\" [(ngModel)]=\"contact.workStatus\"&gt; &lt;option *ngFor=\"let wkSt of workStatuses\" [value]=\"wkSt.id\"&gt; &lt;span&gt;&#123;&#123; wkSt.description &#125;&#125;&lt;/span&gt; &lt;/option&gt; &lt;/select&gt;&lt;/section&gt;3.2 Condicionales *ngIfLa directiva estructural más utilizada es la *ngIf, la cual consigue que un elemento se incluya o se elimine en el DOM en función de los datos del modelo.En el ejemplo puedes ver que la uso para mostrar el campo empresa cuando el contacto está trabajando. En otro aparecerá el campo de estudios.Dado el siguiente modelo:12345678public contact = &#123; name: '', isVIP: false, gender: '', workStatus: '0', company: '', education: ''&#125;;12345678&lt;section *ngIf=\"contact.workStatus=='3'; else education\"&gt; &lt;label for=\"company\"&gt;Company Name&lt;/label&gt; &lt;input name=\"company\" type=\"text\" [(ngModel)]=\"contact.company\" /&gt;&lt;/section&gt;&lt;ng-template #education&gt; &lt;label for=\"education\"&gt;Education&lt;/label&gt; &lt;input name=\"education\" type=\"text\" [(ngModel)]=\"contact.education\" /&gt;&lt;/ng-template&gt;if condition else templateIdentificadores con hashtagEn el código anterior apreciarás que aparece un elemento &lt;ng-template&gt; no estándar con el atributo llamado #education precedido por un #. La directiva # genera un identificador único para el elemento al que se le aplica y permite referirse a él en otros lugares del código.Ese truco permite que *ngIf muestre otro elemento cuando la condición principal falle. El otro elemento tiene que ser el componente especial &lt;ng-template&gt; que se usa para envolver una rama opcional del DOM. Para localizarlo se usa el identificador #.4 Modelo y controladorLos componentes los hemos definido como bloques de construcción de páginas. Mediante una vista y un controlador resuelven un problema de interacción o presentación de modelos. En los puntos anteriores te presenté la vista. Toca ahora estudiar el modelo y el controlador.4.1 El modelo y su interInterfaces y modelosSin ir muy lejos en las capacidades que tendría un modelo de datos clásico, vamos al menos a beneficiarnos del TypeScript para definir la estructura de datos. Esto facilitará la programación mediante el autocompletado del editor y reducirá los errores de tecleo mediante la comprobación estática de tipos.Para ello necesito una interfaz sencilla. Esto es puro TypeScript, no es ningún artificio registrable en Angular. Esos sí, en algún sitio tienen que estar. Yo suelo usar una ruta como contacts/models, pero es algo completamente arbitrario.12345678910111213export interface Option &#123; id: number; description: string;&#125;export interface Contact &#123; name: string; isVIP: boolean; gender: string; workStatus: number | string; company: string; education: string;&#125;Te recomiendo que no uses clases para definir modelos a menos que necesites agregarle funcionalidad imprescindible. Las interfaces, ayudan al control de tipos en tiempo de desarrollo, igual que las clases, pero sin generar nada de código en tiempo de ejecución, al contrario que las clases. Ojo al uso de tipos compuestos como number | stringSe usan para tipificar las propiedades que conforman nuestro modelo para la vista.123456789101112131415public workStatuses: Option[] = [ &#123; id: 0, description: 'unknow' &#125;, &#123; id: 1, description: 'student' &#125;, &#123; id: 2, description: 'unemployed' &#125;, &#123; id: 3, description: 'employed' &#125; ];public contact: Contact = &#123; name: '', isVIP: false, gender: '', workStatus: 0, company: '', education: '' &#125;;public contacts: Contact[] = [];4.2 ViewModel en el controladorLa parte de lógica del componente va en la clase que se usa para su definición. Como ya has visto podemos usar su constructor para reclamar dependencias y usar los interfaces para responder a eventos de su ciclo de vida. Repasemos el ContactsComponent viéndolo como la clase que es: no solo propiedades, también métodos1234public saveContact() &#123; this.contacts.push(&#123; ...this.contact &#125;); this.numContacts = this.contacts.length;&#125;Ahora se trata de invocar el método desde la vista. Es muy buena práctica llevar la lógica al controlador y no escribirla en la vista.1&lt;input value=\"Save\" type=\"submit\" (click)=\"saveContact()\" /&gt;Podemos decir que las propiedades públicas de la clase actuarán como binding de datos con la vista. Mientras que los métodos públicos serán invocados desde los eventos de la misma vista.OnInitLos componentes son clases con un ciclo de vida al que puedes enganchar tu código en algunos pasos. Por ejemplo al iniciarse el componente.El CLI hace que las clase del componente implemente la interfaz OnInit y eso permite al framework invocar al método ngOnInit en cuanto el componente esté listo para su uso. Que no suele ser justo durante la construcción, si no un poco después. Te recomiendo que lleves toda la lógica de inicialización a dicho método.123456789101112131415161718192021public workStatuses: Option[];public contact: Contact;public contacts: Contact[];constructor() &#123;&#125;public ngOnInit() &#123; this.workStatuses = [ &#123; id: 0, description: 'unknow' &#125;, &#123; id: 1, description: 'student' &#125;, &#123; id: 2, description: 'unemployed' &#125;, &#123; id: 3, description: 'employed' &#125; ]; this.contact = &#123; name: '', isVIP: false, gender: '', workStatus: 0, company: '', education: '' &#125;; this.contacts = [];&#125;Un listado de repasoPara mostrar lo que ahora estamos guardando en una lista, nada más sencillo que usar de nuevo a *nFor y a *ngIf para tratar listas vacías.1234567&lt;ul *ngIf=\"contacts.length&gt;0; else empty\"&gt; &lt;li *ngFor=\"let contact of contacts\"&gt; &lt;span&gt;&#123;&#123; contact.name &#125;&#125;&lt;/span&gt; &lt;input value=\"Delete\" type=\"button\" (click)=\"deleteContact(contact)\" /&gt; &lt;/li&gt;&lt;/ul&gt;&lt;ng-template #empty&gt; &lt;i&gt;No data yet&lt;/i&gt; &lt;/ng-template&gt;Y ya puestos incluso puedes animarte a borrar contactos. Es fácil, los métodos pueden recibir argumentos. Y la vista los puede enviar.1234public deleteContact(contact: Contact) &#123; this.contacts = this.contacts.filter(c =&gt; c.name !== contact.name); this.numContacts = this.contacts.length;&#125;Mira el código completo de la clase ContactsComponenten el fichero contacts.component.ts para tener una visión completa del componente. Como ves, las propiedades header, numContacas, formHidden, contacts ... se corresponden con las utilizadas en las directivas de enlace en la vista. Los métodos saveContact(), deleteContact() son invocados desde eventos de elementos del html.Juntos, la vista y su clase controladora, resuelven un problema de interacción con el usuario creando un componente. Todas las páginas que diseñes serán variaciones y composiciones de estos componentes.Y esto es sólo el comienzo. La idea de componente será fundamental en la web del mañana para la creación de páginas mediante web components. Pero eso ya se verá más adelante…Ahora tienes una aplicación en Angular 7 que recoge y muestra datos. Sigue esta serie para añadirle Flujo de datos entre componentes Angular mientras aprendes a programar con Angular7.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Forms","slug":"Forms","permalink":"https://academia-binaria.com/tag/Forms/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"}]},{"title":"Páginas y rutas Angular SPA","slug":"paginas-y-rutas-angular-spa","date":"2019-01-21T12:41:14.000Z","updated":"2019-02-12T16:21:20.818Z","comments":true,"path":"paginas-y-rutas-angular-spa/","link":"","permalink":"https://academia-binaria.com/paginas-y-rutas-angular-spa/","excerpt":"Las aplicaciones Angular 7 son conjuntos de páginas enrutadas en el propio navegador. Son las conocidas SPA, Single Page Applications. Estas apps liberan al servidor de una parte del trabajo, reducen la cantidad de llamadas y mejoran la percepción de velocidad del usuario.En este tutorial aprenderás a crear una Angular SPA fácilmente usando @angular/router, el enrutador de Angular.","text":"Las aplicaciones Angular 7 son conjuntos de páginas enrutadas en el propio navegador. Son las conocidas SPA, Single Page Applications. Estas apps liberan al servidor de una parte del trabajo, reducen la cantidad de llamadas y mejoran la percepción de velocidad del usuario.En este tutorial aprenderás a crear una Angular SPA fácilmente usando @angular/router, el enrutador de Angular.Partiendo de la aplicación tal cómo quedó en Base para una aplicación Angular. Seguimos usando el concepto de árbol, ahora como analogía de las rutas y las vistas asociadas. Al finalizar tendrás una angular SPA con vistas asociadas a sus rutas.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-board/2-spa1. RutasAl crear la aplicación hice uso del flag routing true en el comando de generación del CLI. Esto causó la aparición de no uno, sino dos módulos gemelos en la raíz de la aplicación. Has estudiado el AppModule verdadero módulo raíz, y ahora verás en profundidad a su gemelo: el módulo de enrutado AppRoutingModule y el uso que hace del RouterModule.1.1 RouterModuleEl Angular Router necesita ser importado y configurado. El módulo AppRoutingModule cumple dos funciones. Por un lado importa al RouterModule de Angular, el cual contiene toda la lógica necesaria para enrutar en el navegador. Por otro lado, permite la definición de rutas en el array Routes[].1234567891011121314151617181920import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [ &#123; path: 'heroes', component: HeroesComponent &#125;, &#123; path: 'not-found', component: NotFoundComponent &#125;, &#123; path: '**', redirectTo: 'not-found' &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123;&#125;El array de rutas recibe objetos ruta con propiedades de configuración.La primera es path: en la que se especifica la dirección que resuelve, en este caso la ruta vacía o raíz del árbol de rutas. Las otras son opcionales y las veremos poco a poco.1.1.1 ComponentVamos a crear un componente donde guardar el contenido que el CLI nos regala de inicio. Los enlaces a las páginas oficiales de Angular y al ejemplo del Tour Of Heroes. Para ello crearé el componente HeroesComponent.1ng g c heroesLo hago en la carpeta raíz; algo poco aconsejado si queremos tener una estructura escalable. Pero es un buen anti-ejemplo ;-)Ahora debo decidir qué ruta asociarle… por ejemplo /heroes. Eso es lo que se ve en el inicio de la configuración de rutas. Para no perderme lo ideal es tener un nuevo enlace de navegación en el HeaderComponent123456&lt;header class=\"sticky\"&gt; &lt;a routerLink=\"/\" class=\"logo\"&gt; &lt;span class=\"icon-home\"&gt;&lt;/span&gt; &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;a routerLink=\"heroes\" routerLinkActive=\"router-link-active\" class=\"button\"&gt; &lt;span&gt; Heroes&lt;/span&gt; &lt;/a&gt;&lt;/header&gt;Vayamos casi al final y de paso hagamos algo útil para no volver a perdernos sin remedio. Un detector de rutas no contempladas, y una ruta a dónde redirigir a los usuarios perdidos. Para ello estudiaremos la propiedad component que es fundamental pues indica el componente que se debe mostrar cuando esta ruta se active.Así es cómo funciona el enrutado. Un camino y un componente asociado. La tabla de enrutado se procesa de arriba a abajo y cuando un camino coincide con la ruta actual, se para y se carga el componente.Vamos a crear un componente con la intención de mostrarlo sólo cuando las demás ruta fallen. Se llamará not found Lo creo asociado al CoreModule lo cual ayuda a organizar los elementos de la aplicación.1ng g c core/not-foundYa podemos asociar dicho componente al camino not-found. Pero esto es poca cosa. Hay mucho más.1.1.2 RedirectToLa configuración de rutas no sólo permite asignar componentes a las direcciones. También se pueden hacer redirecciones de unas direcciones a otras. Y por supuesto puede haber rutas no contempladas o errores por parte del usuario, los infames 404 Not Found.En este caso cuando se escriba la ruta /not-foud se mostrará un componente, el NotFoundComponent, cuyo contenido indicará al usuario que se ha perdido. Claro que nadie va voluntariamente a esa ruta. Mediante el path: &#39;**&#39; le indico que ante cualquier ruta no contemplada anteriormente se ejecute el comando redirectTo: &#39;not-found&#39;, el cual nos lleva a una ruta conocida con un mensaje bien conocido. Page Not Found.Pero ¿Cómo es eso de que se mostrará?, ¿Dónde se cargará?. Presentamos a &lt;router-outlet&gt;.1.2 Router OutletLa idea general de una SPA es tener una única página que cargue dinámicamente otras vistas. Normalmente la página contenedora mantiene el menú de navegación, el pie de página y otras áreas comunes. Y deja un espacio para la carga dinámica. Para ello necesitamos saber qué componente cargar y dónde mostrarlo. De esto último se ocupa el router outlet mediante la etiqueta &lt;router-outlet&gt;&lt;/router-outlet&gt;.En el main.component.ts había un contenido hard-coded. Para hacer que el contenido sea dinámico se sustituye por el elemento de Angular &lt;router-outlet&gt;&lt;/router-outlet&gt;. Este elemento del framework inyectará dinámicamente el componente que le corresponda según la ruta activa. El MainComponent queda así:1234&lt;main class=\"container\"&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;!-- Dynamic content here! --&gt;&lt;/main&gt;1.3 Router LinkLos enlaces web tradicionalmente se han resuelto con elementos &lt;a href=&quot;&quot;&gt;&lt;/a&gt; dónde en su atributo href se asociaba la dirección a la cuál navegar ante el click del usuario. En Angular los enlaces se declaran con un atributo especial llamado routerLink. Este atributo se compila dando lugar al href oportuno en tiempo de ejecución.En el fichero not-found.component.ts pon algo así:123&lt;h1&gt;Not Found&lt;/h1&gt;&lt;h2&gt;404&lt;/h2&gt;&lt;a routerLink=\"/\"&gt;Go home&lt;/a&gt;Por ahora la funcionalidad de routerLink no mejora en nada a href. Pero lo hará. Mientras tanto familiarízate con su sintaxis y… asegúrate de importar RouterModule en los módulos en los que lo vayas a usar.Salgamos de este bucle creando más rutas y más componentes. Pero esta vez con un nueva técnica.2 Lazy LoadingLa web clásica funcionaba con un navegador pidiendo una ruta al servidor. El servidor buscaba o montaba un documento html y se lo devolvía al navegador para que lo renderizase. Una nueva ruta significaba repetir todo ese viaje. Hasta que aparecieron las Single Page Applications. En este caso el código cliente es el responsable del contenido asociado a cada ruta. Y eso es mucha responsabilidad.Las webs SPA se crearon por una razón que casi acaba con ellas: la velocidad. Al realizar el enrutado en el cliente y querer evitar todos los viajes posibles hasta el servidor, se cargó a la única página web con todo el peso de la aplicación. Lo cual la hizo terriblemente lenta en la primera visita de cada usuario.El impacto de la primera visita en una aplicación de intranet no suele ser un problema grave. Pero en internet esa visita puede ser la primera y si tarda mucho, también será la última. La solución viene de mano del concepto de lazy loading o carga perezosa. Consiste en diferir la carga de la lógica asociada a una dirección hasta el momento en que sea activada dicha ruta. De esa forma, una página no visitada es una página que no pesa. Y la carga inicial se hace mucho más liviana.En Angular el lazy loading es tan sencillo que ya se recomienda implementarlo por defecto. Para hacerlo conoceremos más comandos del Router y algunas herramientas de compilación usadas por el Angular CLI.2.1 Webpack y los bundles por rutaHay que saber que el Angular CLI usa internamente la herramienta de empaquetado webpack. La cual recorre el código TypeScript buscando imports y empaquetando su contenido en sacos o bundles. Luego introduce las referencias a esos bundles en la sección se scripts del index.html, haciendo que se descarguen todos nada más arrancar la aplicación. Esto puede ser muy pesado en aplicaciones grandes. Así que hay que buscar una manera de diferir esa descarga, repartiendo el bundle principal en otros más pequeños que se cargará bajo demanda.Objetivo: adelgazar el peso del bundle principal, el main.js.Para conseguirlo hay que configurar las rutas de forma que no sea necesario importar los componentes a mostrar. Tal como se ha hecho con el NotFoundComponent, de hacerlo así con todos, webpack empaquetaría esos componentes como algo necesario… y por tanto serían enviados al navegador en el bundle principal sin que sea seguro su uso. Ese no es el camino, es una excepción para componentes poco pesados y muy utilizados.La solución que ofrecen el cli y webpack consiste en delegar la asignación del componente a otro módulo, pero sin importarlo hasta que su ruta principal se active.He creado unas vistas para ser usadas en las direcciones / y /about. Los componentes asociados se llaman HomeComponent u AboutComponent. Se han declarado pero no exportado en sus respectivos módulos HomeModule y AboutModule. No es necesario exportarlos porque no serán reclamados directamente por nuestro código.1234ng g m home --routing trueng g c home/homeng g m about --routing trueng g c about/aboutEstos módulos no deben ser importados por el AppModule; no queremos saber de su existencia. Simplemente debe usarse su ruta relativa en el módulo de enrutado AppRoutingModule como un valor especial. Vamos a agregarlo al app-routing.module.ts que quedará así.123456789101112131415161718192021222324import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [ &#123; path: '', loadChildren: './home/home.module#HomeModule' &#125;, &#123; path: 'about', loadChildren: './about/about.module#AboutModule' &#125;, &#123; path: 'not-found', component: NotFoundComponent &#125;, &#123; path: '**', redirectTo: 'not-found' &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123;&#125;Fíjate que la dirección del fichero es una cadena de texto asignada a una nueva propiedad de objeto route, la propiedad loadChildren:&quot;&quot;. No se está produciendo ninguna importación en TypeScript como ocurre con el componente NotFoundComponent.Con esta información webpack va a generar un bundle específico para cada módulo. Si durante la ejecución se activa la ruta / (muy probable porque es la ruta raíz) o la ruta /about entonces se descarga ese paquete concreto y se ejecuta su contenido. Mientras tanto, se queda almacenado en el servidor.Esto hace que la aplicación de Angular pese menos y responda antes, mejorando el tiempo de pintado inicial. La combinación de estas y otras técnicas que veremos en este tutorial sacarán el mejor rendimiento posible a tu aplicación Angular.2.2 El enrutador delegadoYa sabemos que hasta que no se active la ruta / o la /about no hay que hacer nada. Pero si se activa, entonces se descarga un bundle que contiene un módulo y los componentes necesarios. Sólo falta escoger dentro de ese módulo el componente que se asignará a la ruta.Para eso al crear los módulos Home y About use el flag routing true. Esto hace que se genere un segundo módulo de enrutado. El HomeRoutingModule y el AboutRoutingModule son prácticamente idénticos al enrutador raíz.Digamos que son enrutadores subordinados al primero. Sólo se llega aquí si en la ruta principal se ha navegado a una dirección concreta. Se hace notar esa distinción durante el proceso de importación del módulo de Angular RouterModule. En el caso principal se pone imports: [RouterModule.forRoot(routes)] y en todos los demás imports: [RouterModule.forChild(routes)].A nivel subordinado, la dirección path: &quot;&quot; se agrega al path: &quot;&quot; de su enrutador padre. Cuidado, es un error común repetir el path a nivel hijo. En este caso incluso parece redundante. Pero con about no quedan dudas. En el root lleva path: &quot;about&quot; y en el child solamente path: &quot;&quot;.La ventaja real de este segundo enrutador es que irá empaquetado en el mismo bundle que el módulo de negocio y sus componentes. Descargando ese peso en el momento que se necesite. Aquí sí que asignaremos un componente concreto: el HomeComponent o el AboutComponent. Por ejemplo el fichero home-routing.module.ts quedará más o menos así:123456789101112import &#123; HomeComponent &#125; from './home/home.component';const routes: Routes = [ &#123; path: '', component: HomeComponent &#125;];@NgModule(&#123; imports: [RouterModule.forChild(routes)], exports: [RouterModule]&#125;)export class HomeRoutingModule &#123;&#125;2.3 NavegaciónAhora que ya tenemos un par de rutas reales, es buen momento para crear un mini menú de navegación. Vayamos al core/shell/header.component.html y pongamos algo así:123456&lt;header class=\"sticky\"&gt; &lt;a routerLink=\"/\" class=\"logo\"&gt; &lt;span class=\"icon-home\"&gt;&lt;/span&gt; &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;a routerLink=\"about\" routerLinkActive=\"router-link-active\" class=\"button\"&gt; &lt;img width=\"32\" style=\"vertical-align: -0.5em\" src=\"./assets/logo.png\" /&gt; &lt;span&gt; About us&lt;/span&gt; &lt;/a&gt;&lt;/header&gt;3 Rutas anidadasCuando las interfaces se complican, es habitual que las aplicaciones dispongan de menús de navegación a distintos niveles. Dentro de una misma página podemos querer ver distinto contenido y además reflejarlo en la URL. Para resolver esta situación en Angular disponemos de la técnica de las nested routes.De una manera un tanto forzada la he incluido en la página /about. La cual disponen de su propio menú de navegación, y lo que es más importante, su propio &lt;router-outlet&gt;&lt;/router-outlet&gt;.Para empezar veamos como queda el html del about.component.ts. Vamos a dotarlo de dos rutas nuevas /about/links y /about/info. Cada una mostrará contenido en un componente adecuadamente insertado en el &lt;router-outlet&gt;&lt;/router-outlet&gt; local.3.1 ChildrenPara repasar conceptos de generación de componentes12ng g c about/about/linksng g c about/about/infoPara que funcione empezamos por crear los dos componentes LinksComponent e InfoComponent de forma rutinaria. Y los asignamos en el about-routing.module.ts como subordinados a la ruta principal con el comando children:[]. Los caminos se van agregando sobre la ruta principal activa, la /about. Esto es así tanto el routerLink como el path de los children.12345678910111213141516const routes: Routes = [ &#123; path: '', component: AboutComponent, children: [ &#123; path: 'links', component: LinksComponent &#125;, &#123; path: 'info', component: InfoComponent &#125; ] &#125;];3.2 RouterOutlet anidadoLos componentes de las rutas children se inyectarán en el &lt;router-outlet&gt; del componente contenedor AboutComponent. Es como si todo volviese a empezar desde aquí.12345&lt;header class=\"sticky\"&gt; &lt;a routerLink=\"links\" class=\"button\"&gt; &lt;span&gt; Tutorial Links&lt;/span&gt; &lt;/a&gt; &lt;a routerLink=\"info\" class=\"button\"&gt; &lt;span&gt; More Info&lt;/span&gt; &lt;/a&gt;&lt;/header&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;Con estos conceptos y la combinación de children, loadChild, component, redirectTo … asociadas a path podrás configurar tu aplicación y responder a cualquier URL desde la misma y única página index.html.4 ParámetrosLas rutas vistas hasta ahora se consideran estáticas pues se han definido usando constantes. Es muy habitual tener páginas con la misma estructura pero distintos contenidos. Un blog con sus posts, una tienda con sus productos, o un proyecto con sus tareas… hay miles de ejemplos así.4.1 Variables en la rutaEse tipo de direcciones se consideran paramétricas, tienen unos segmentos estáticos y otros dinámicos. Estos últimos se definen con parámetros, algo así como variables dentro de la cadena de la ruta. Su sintaxis obliga a precederlas de dos puntos. Por ejemplo countries/:country/cities/:city resolvería rutas como countries/usa/cities/new-york o countries/italy/cities/roma. Rellenando los parámetros :country y :city con los valores necesarios.Esta aplicación no tiene un propósito de negocio concreto. Iremos creando rutas según sea necesario por motivos pedagógicos. Empezaremos con unas páginas destinadas a mostrar los autores del proyecto.Vamos a crear rutas como /authors/albertobasalo o /authors/johndoe. Para ello necesitamos el segmento principal /authors y una par de componentes.Vamos a agregar los componentes necesarios como hasta ahora.12ng g c about/about/authorsng g c about/about/authors/authorEn las rutas del about-routing.module.ts agregamos un nuevos children paths1234567891011121314151617&#123; path: '', component: AboutComponent, children: [ &#123; path: 'links', component: LinksComponent &#125;, &#123; path: 'info', component: InfoComponent &#125;, &#123; path: 'authors', component: AuthorsComponent &#125;, &#123; path: 'authors/:id', component: AuthorComponent &#125; ]&#125;Esta configuración resuelve las rutas about/links, about/info, about/authors y about/authors/cualquier-otra-cosa. Y las carga con el componente adecuado. Lo novedoso en el camino :id. El prefijo dos puntos indica que es un parámetro. Algo así como una variable en el segundo segmento que se almacenará y será recogido con el arbitrario nombre id.Para mostrar el uso de los nuevos enlaces he agregado el authors/ al AboutComponent y he creado un listado en el AuthorsComponent. Familiarízate con las rutas relativas para componer la ruta completa.12&lt;a routerLink=\"albertobasalo\" class=\"button\"&gt; &lt;span&gt; Alberto Basalo&lt;/span&gt; &lt;/a&gt;&lt;a routerLink=\"johndoe\" class=\"button\"&gt; &lt;span&gt; John Doe&lt;/span&gt; &lt;/a&gt;Aún más interesante es el componente que muestra cada autor de la lista, el AuthorComponent. En este caso fíjate cómo accede a la ruta, cómo obtiene el valor del parámetro y cómo lo usa para mostrarlo en la web.4.2 ActivatedRouteEl framework Angular trae muchas librerías para facilitar la vida al programador. Sólo hay que saber dónde están y cómo pedirlas. Para ello volvemos a la tecnología escogida, TypeScript, que permite las importaciones y la inyección de dependencias. Hay un tema dedicado a conocer en profundidad los servicios inyectables en Angular. Por ahora una breve introducción.Contenido del fichero author.component.ts relacionado con la obtención del parámetro de la ruta activa:12345678910import &#123; Component, OnInit &#125; from '@angular/core';import &#123; ActivatedRoute &#125; from '@angular/router';export class AuthorComponent implements OnInit &#123; public authorId = ''; constructor(activateRoute: ActivatedRoute) &#123; this.authorId = activateRoute.snapshot.params['id']; &#125; ngOnInit() &#123;&#125;&#125;La instrucción import { ActivatedRoute } from &quot;@angular/router&quot;; pone a disposición del programador el código donde está definida la clase ActivatedRoute. Pero no se instancia directamente; en su lugar, se usa como un argumento del constructor de la clase del componente. Ese constructor es invocado por Angular, y dinámicamente el propio framework sabe cómo rellenar los argumentos que se pidan en los constructores. Es decir, sabe cómo inyectar instancias en las que dependencias declaradas.Una vez que han inyectan las dependencias en el constructor ya están listas para ser usadas. En concreto activateRoute da acceso a métodos y propiedades para trabajar con la ruta activa y poder leer sus parámetros.Obtenidos los datos desde la URL, ya se muestran en la vista de forma ya conocida. Fichero /about/authors/author/author.component.html12&lt;h2&gt;Author profile&lt;/h2&gt;&lt;h3&gt;&#123;&#123; authorId &#125;&#125;&lt;/h3&gt;Con esto tendrás una aplicación SPA en Angular. Sigue esta serie para añadirle Formularios, tablas y modelos de datos en Angular mientras aprendes a programar con Angular7.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"SPA","slug":"SPA","permalink":"https://academia-binaria.com/tag/SPA/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Routing","slug":"Routing","permalink":"https://academia-binaria.com/tag/Routing/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"}]},{"title":"Base para una aplicación Angular","slug":"base-aplicacion-angular","date":"2019-01-16T10:57:00.000Z","updated":"2019-02-12T16:24:56.264Z","comments":true,"path":"base-aplicacion-angular/","link":"","permalink":"https://academia-binaria.com/base-aplicacion-angular/","excerpt":"Vamos a crear una base sobre la que programar una aplicación Angular 7 profesional. Usaremos el CLI para generar una estructura sobre la que crecer. Será como una semilla para un desarrollo controlado.La idea de árbol se usa en muchas analogías informáticas. La emplearemos en dos conceptos básicos en Angular: los módulos y los componentes.","text":"Vamos a crear una base sobre la que programar una aplicación Angular 7 profesional. Usaremos el CLI para generar una estructura sobre la que crecer. Será como una semilla para un desarrollo controlado.La idea de árbol se usa en muchas analogías informáticas. La emplearemos en dos conceptos básicos en Angular: los módulos y los componentes.Partimos de la aplicación tal cómo la dejamos en el Hola Mundo en Angular. Al finalizar tendrás un esqueleto del que colgar módulos y componentes funcionales.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-board/1-base1. MódulosLos módulos son contenedores para almacenar los componentes y servicios de una aplicación. En Angular cada programa se puede ver como un árbol de módulos jerárquico. A partir de un módulo raíz se enlazan otros módulos en un proceso llamado importación.1.1 Anatomía de un móduloAntes de usar cualquier módulo hay que conocerlo. En Angular los módulos de declaran como clases de TypeScript. Estas clases, habitualmente vacías, son decoradas con una función especial. Es la función @NgModule() que recibe un objeto como único argumento. En las propiedades de ese objeto es donde se configura el módulo.Mira el módulo AppModule original que genera el CLI en el fichero app.module.ts.1234567@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125;1.1.1 Importación de otros módulosEl módulo App también se conoce como módulo raíz porque de él surgen las demás ramas que conforman una aplicación. La asignación de los nodos hijos se realiza en la propiedad imports:[], que es un array de punteros a otros módulos.En la situación original el módulo principal depende un módulo custom pre-generado (el AppRoutingModule que usarás más adelante) y de otro del framework para la presentación en el navegador (el BrowserModule).Veremos esto con más profundidad en el punto 4.1.2 Generación de módulosHasta ahora los módulos involucrados son librerías de terceros o que se crearon mágicamente con la aplicación. Es hora de crear tu primer módulo. Para eso usaremos otro comando del cli, el ng generate module. En una ventana del terminal escribe:1ng g m coreEsta es la sintaxis abreviada del comando ng generate el cual dispone de varios planos de construcción o blueprints. El que he usado aquí es el de module para la construcción de módulos.Si no te gusta teclear en la terminal, también puedes lanzar estos comandos desde Angular ConsoleEl resultado es la creación del fichero core/core.module.ts con la declaración y decoración del módulo CoreModule.Este módulo te servirá de contenedor para guardar componentes y otros servicios esenciales para nuestra aplicación. Pero eso lo veremos más adelante.12345@NgModule(&#123; imports: [], declarations: []&#125;)export class CoreModule &#123;&#125;Por ahora hay que asegurar que este módulo será importado por el raíz, el AppModule. Para ello comprobaremos que la línea de importación del módulo principal esté parecida a esto:1234567@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, CoreModule], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125;El módulo raíz, al igual que como verás más tarde con el componente raíz, es un tanto especial. Su nombre oficial es App, aunque todo la documentación se refiere a él como raíz o root.2. ComponentesLos módulos son contenedores. Lo primero que vamos a guardar en ellos serán componentes. Los componentes son los bloques básicos de construcción de las páginas web en Angular 7. Contienen una parte visual en html (la Vista) y una funcional en Typescript (el Controlador).La aplicación original que crea el CLI nos regala un primer componente de ejemplo en el fichero app.component.ts. Según la configuración del CLI este componente puede haber sido creado en un sólo fichero o hasta cuatro: (el controlador, con la vista y los estilos en ficheros propios y fichero extra para pruebas unitarias).2.1 Anatomía de un componenteLos componentes, como el resto de artefactos en Angular, serán clases TypeScript decoradas con funciones específicas. En este caso la función es @Component() que recibe un objeto de definición de componente. Igual que en el caso de los módulos contiene las propiedades en las que configurar el componente.12345678import &#123; Core &#125; from '@angular/core';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styles: []&#125;)export class AppComponent &#123;&#125;Los componentes definen nuevas etiquetas HTML para ser usados dentro de otros componentes. Excepcionalmente en este caso por ser el componente raíz se consume en el página index.html. El nombre de la nueva etiqueta se conoce como selector. En este caso la propiedad selector: &quot;app-root&quot; permite el uso de este componente dentro de otro con esta invocación &lt;app-root&gt;&lt;/app-root&gt;. En este caso el componente raíz.Particularidades del componente raíz. Su nombre oficial es AppComponent, y su selector debería llamarse app-app. Pero su selector real es app-root, formado a partir del prefijo de la aplicación y su supuesto nombre oficioso. Observa el prefijo app que se usará en todos los componentes propios, fue asignado por defecto durante la generación de la aplicación. Puede personalizarse usando el modificador --prefix de ng new y en distintos ficheros de configuración. Volviendo al componente raíz; está destinado a ser usado en la página principal, en el index.html. Eso obliga a registrarlo de una manera especial en el módulo raíz. Hay que incluirlo en el array bootstrap: [AppComponent], es ahí donde se incluyen los componentes con la capacidad de lanzar bootstrap la aplicación.1234567@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, CoreModule], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125;Y en el index.html123&lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt;La plantilla representa la parte visual del componente. De forma simplificada, o cuando tiene poco contenido, puede escribirse directamente en la propiedad template del objeto decorador. Pero es más frecuente encontrar la plantilla en su propio fichero html y referenciarlo como una ruta relativa en la propiedad templateUrl.La propiedad styles y su gemela stylesUrl permiten asignar estilos CSS, SASS o LESS al componente. Estos estilos se incrustan durante la compilación en los nodos del DOM generado. Son exclusivos del componente y facilitan el diseño y maquetación granular de las aplicaciones.Los estilos, ausentes en este ejemplo, podrían incluirse como un array de cadenas, o llevarse a un fichero propio como en el caso de la vista.12345&lt;div style=\"text-align:center\"&gt; &lt;h1&gt;Welcome to &#123;&#123; title &#125;&#125;!&lt;/h1&gt; &lt;img width=\"100\" src=\"./assets/logo.png\" /&gt;&lt;/div&gt;...En la clase del componente nos encontraremos la implementación de su funcionalidad. Normalmente expondrá propiedades y métodos para ser consumidos e invocados de forma declarativa desde la vista.Una aplicación web en Angular se monta como un árbol de componentes. El componente raíz ya viene creado y convenientemente declarado; ahora toca darle contenido mediante una estructura de página y las vistas funcionales.2.2 Generación de componentesPara crear nuevos componentes vamos a usar de nuevo el comando generate del CLI . Pero ahora con los planos para construir un componente. La sintaxis completa del comando ng generate component o abreviadamente ng g c permite crear componentes en diversas formas.Casi todas las páginas tienen una estructura similar que de forma simplista queda en tres componentes. Uno para la barra de navegación, otro para el pie de página y otro intermedio para el contenido principal.Ejecuta en una terminal estos comandos para que generen los componentes y comprueba el resultado en el editor.1234ng g c core/shellng g c core/shell/headerng g c core/shell/mainng g c core/shell/footerFíjate en el componente del fichero shell.component.ts. Su estructura es igual a la del componente raíz. Destaca que el nombre del componente coincide con el nombre del selector: app-shell y ShellComponent. Esto será lo normal a partir de ahora. Sólo el componente raíz tiene la excepción de que su nombre App no coincide con su selector root.12345678910import &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-shell', templateUrl: './shell.component.html', styles: []&#125;)export class ShellComponent implements OnInit &#123; constructor() &#123;&#125; ngOnInit() &#123;&#125;&#125;Y esta es su vista asociada. La cual es de nuevo una composición de otros selectores. Estamos creando un frondoso árbol de componentes.123&lt;app-header&gt;&lt;/app-header&gt;&lt;app-main&gt;&lt;/app-main&gt;&lt;app-footer&gt;&lt;/app-footer&gt;3 Visibilidad entre componentesLa clave del código limpio es exponer funcionalidad de manera expresiva pero ocultar la implementación. Esto es sencillo con los lenguajes de POO, pero en HTML no era nada fácil. Con la programación basada en componentes podemos crear pantallas complejas, reutilizables y que a su vez contengan y oculten la complejidad interna a sus consumidores.3.1 Componentes públicos y privadosLos componentes no deciden por sí mismos su visibilidad. Cuando un componente es generado se declara en un módulo contenedor en su propiedad declares:[]. Eso lo hace visible y utilizable por cualquier otro componente del mismo módulo. Pero si quieres usarlo desde fuera tendrás que exportarlo. Eso se hace en la propiedad exports:[] del módulo en el que se crea.La exportación debe hacerse a mano incluyendo el componente en el array, o indicarse con el flag --export para que lo haga el cli. Esto es lo que se ha hecho en el módulo Core para poder exportar el componente shell.123456@NgModule(&#123; declarations: [ShellComponent, HeaderComponent, MainComponent, FooterComponent], imports: [CommonModule, RouterModule], exports: [ShellComponent]&#125;)export class CoreModule &#123;&#125;Los componentes privados suelen ser sencillos. A veces son creados para ser específicamente consumidos dentro de otros componentes. En esas situaciones interesa que sean privados y que generen poco ruido. Incluso, en casos extremadamente simples, si usamos el modificador --flat ni siquiera generan carpeta propia.Por supuesto que HeaderComponent necesitará la propiedad title y también la moveremos desde app.component.ts. Dejando de esa manera el componente raíz en los huesos.3.2 Importación y exportación entre módulosQue un componente sea público es la primera condición para que se consuma fuera de su módulo. Ahora falta que quién lo quiera usar el selector &lt;app-shell&gt; importe su módulo CoreModule. Esto lo haremos en el AppModule para que lo use el AppComponent.1234567@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule, CoreModule], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125;Como regla general, cuando en una plantilla se incruste otro componente, Angular lo buscará dentro del propio módulo en el que pretende usarse. Si no lo encuentra entonces lo buscará entre los componentes exportados por los módulos que hayan sido importados por el actual contenedor.Ahora mismo en AppComponente sólo puedo usar a ShellComponent, que es el único componente accesible. En ShellComponent se pueden usar sus vecinos Header, Main y Footer. Es un práctica recomendada el mantener el AppModule y el AppComponent tan simples como sea posible. Para ello movemos todo lo que podemos al módulo de ayuda CoreModule distribuyendo el contenido de app.component.html en las plantillas de Header, Main y Footer que corresponda.3.2.1 Dos mundos paralelos: imports de Angular e import de TypeScriptSi es la primera vez que ves código TypeScript te llamarán la atención las primeras líneas de cada fichero. En el app.module.ts son algo así:1234import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppRoutingModule &#125; from './app-routing.module';import &#123; AppComponent &#125; from './app.component';Estas sentencias de importación son propias del lenguaje y nada tienen que ver con Angular. En ellas se indica que este fichero importa el contenido de otros ficheros TypeScript. La importación se realiza en base a convenios personalizables. Si empieza con ./ entonces se busca a través de la ruta física relativa al fichero actual. En otro caso se busca en el directorio node_modules y se trata como código de terceros.En general no tendrás que preocuparte de estas importaciones físicas, pues el VSCode y las extensiones esenciales se encargan de hacerlo automáticamente según lo uses en tu código4. Transitividad y Organización4.1 Transitividad en una cadena de módulosUn problema que reforzará tu conocimiento sobre el sistema modular surgirá al mover la etiqueta &lt;router-outlet&gt;&lt;/router-outlet&gt; del app.component.html al componente Main. En su vista main.component.html tendrás algo así.12345678910111213&lt;h2&gt;Here are some links to help you start:&lt;/h2&gt;&lt;ul&gt; &lt;li&gt; &lt;h2&gt;&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://angular.io/tutorial\"&gt;Tour of Heroes&lt;/a&gt;&lt;/h2&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://angular.io/cli\"&gt;CLI Documentation&lt;/a&gt;&lt;/h2&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://blog.angular.io/\"&gt;Angular blog&lt;/a&gt;&lt;/h2&gt; &lt;/li&gt;&lt;/ul&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;Todo son etiquetas html estándar salvo la última &lt;router-outlet&gt;&lt;/router-outlet&gt;. El propósito de este componte lo veremos en la próxima lección dedicada a enrutado. Pero por ahora más que una ayuda es un dolor de cabeza porque es un desconocido para el módulo CoreModule. Resulta que el RouterOutletComponent está declarado en un módulo del framework llamado RouterModule. Dicho módulo fue importado de manera automática durante la generación del código inicial, pero ¿Dónde?.Como digo el tema del enrutado es un capítulo aparte, pero las relaciones de los módulos debes conocerlas cuanto antes. Durante la generación inicial se crearon dos módulos: el AppModule, ya estudiado, y su asistente para enrutado AppRoutingModule. Este último aún no lo hemos visitado. Su contenido es:12345678import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123;&#125;Obviando la por ahora inútil instrucción .forRoutes(routes), llama la atención que este módulo es dependiente del famoso RouterModule, es decir lo importa en su array imports:[]. Pero además va y lo exporta haciendo uso de la interesante propiedad transitiva de los módulos. Cada módulo puede exportar sus propios componentes o los de terceros. Incluso puede exportar todo un módulo al completo. Al hacerlo así, el AppRoutingModule estaba poniendo a disposición del AppModule todo el contenido de RouterModule, incluido el por ahora fastidioso RouterOutletComponent.Pero el módulo Core no importa al AppRouting, así que nada sabe de un selector llamado router-outlet. Para solucionarlo sólo puedes hacer una cosa: importar al RouterModule en el CoreModule, que quedará así:1234567891011121314import &#123; CommonModule &#125; from '@angular/common';import &#123; NgModule &#125; from '@angular/core';import &#123; RouterModule &#125; from '@angular/router';import &#123; FooterComponent &#125; from './shell/footer/footer.component';import &#123; HeaderComponent &#125; from './shell/header/header.component';import &#123; MainComponent &#125; from './shell/main/main.component';import &#123; ShellComponent &#125; from './shell/shell.component';@NgModule(&#123; declarations: [ShellComponent, HeaderComponent, MainComponent, FooterComponent], imports: [CommonModule, RouterModule], exports: [ShellComponent]&#125;)export class CoreModule &#123;&#125;4.2 Organización de la aplicación en módulosTodos los programas tiene partes repetitivas. Los principios de organización y código limpio nos permiten identificarlas y reutilizarlas. Con los componentes ocurre lo mismo. El módulo y los componentes recién creados suelen ser comunes a casi todas las aplicaciones. Estos y otros muchos surgirán de manera natural durante el desarrollo de una aplicación para ser utilizados en múltiples páginas.Son componentes de infraestructura. Conviene guardarlos en una carpeta especial. Aquí la he llamado shared, pero tools, common, o lib suelen ser otros nombres habituales. Para reforzar el uso del CLI escribe el siguiente comando que aprovecharemos en el futuro.1ng g m sharedPor ahora déjalo huérfano, no lo importaremos hasta que tengamos módulos funcionales. Sólo anticiparte que es un módulo dónde se hace mucho uso de la propiedad transitiva del sistema modular de Angular.El caso es distinguir los componentes de infraestructura de los de negocio o funcionalidad. Los módulos core y shared los trataremos como de infraestructura y todos los demás serán de negocio (aún no tenemos). El primero es para meter cosas de uso único esenciales para la aplicación. El segundo para meter bloques reutilizables durante la construcción de la aplicación. Recuerda que sólo son convenios de arquitectura de software; adáptalos a tus necesidades.En esta aplicación hasta ahora no es nada funcional,!y ya tiene seis módulos y seis componentes!. Puede parecer sobre-ingeniería, pero a la larga le verás sentido. Por ahora te permitirá practicar con la creación de módulos y componentes.El bosque de módulos a vista de pájaro12345678910111213AppModule|+--AppRoutingModule| || +--RouterModule|+--BrowseModule|+--CoreModule | +--RouterModuleSharedModuleEl bosque de componentes a vista de pájaro1234567891011AppComponent|+--ShellComponent | +--HeaderComponent | +--MainComponent | | | +--RouterOutletComponent | +--FooterComponentCon esto tendrás una base para una aplicación Angular 7. Sigue esta serie para añadirle funcionalidad mediante Páginas y rutas Angular SPA mientras aprendes a programar con Angular7.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"CLI","slug":"CLI","permalink":"https://academia-binaria.com/tag/CLI/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"}]},{"title":"Hola Angular CLI","slug":"hola-angular-cli","date":"2019-01-09T11:54:00.000Z","updated":"2019-02-12T16:24:32.016Z","comments":true,"path":"hola-angular-cli/","link":"","permalink":"https://academia-binaria.com/hola-angular-cli/","excerpt":"Angular en su versión 7 es la plataforma perfecta para el desarrollo profesional de aplicaciones modernas. El Angular CLI es la herramienta adecuada para generar aplicaciones Angular. Juntos son imbatibles en cuanto a velocidad en desarrollo y a potencia en ejecución.","text":"Angular en su versión 7 es la plataforma perfecta para el desarrollo profesional de aplicaciones modernas. El Angular CLI es la herramienta adecuada para generar aplicaciones Angular. Juntos son imbatibles en cuanto a velocidad en desarrollo y a potencia en ejecución.El comúnmente conocido como AngularCLI o angular cli o angular-cli o _ CLI a secas_ es la herramienta de línea de comandos estándar para crear, depurar y publicar aplicaciones Angular. En su actual versión 7 es más potente y versátil que nunca y es muy sencillo dominar los aspectos básicos.Código asociado a este artículo en GitHub: AcademiaBinaria/angular-board/0-hello1. Instalación de Angular CLI 7Angular es una plataforma de desarrollo dogmática y llave en mano. Para empezar, como en casi cualquier desarrollo necesitarás NodeJS y su manejador de de paquetes npm. Tenerlos actualizados es un mandamiento básico para un desarrollador web. Comprueba tu versión con el siguiente comando:1node -vEmpieza con una instalación global que te permita usar la herramienta desde cualquier directorio. Comprueba la versión instalada y accede a la ayuda en línea. La ayuda está disponible tanto de modo general como para cada comando que vayas a usar.Instrucciones para instalar Angular CLI.1234$ npm i -g @angular/cli@latest$ ng version$ ng help$ ng new --help2. Crear y ejecutar una aplicación Angular 7Una vez que hayas instalado el CLI de manera global ya puedes empezar a usarlo en tu directorio de trabajo. El primer comando será ng new que te va a generar toda una aplicación funcional y las configuraciones necesarias para su depuración, pruebas y ejecución.Como novedad, en las últimas versiones, el CLI te preguntará por algunas opciones para crear tu aplicación. Eso es porque no todos los desarrollos son iguales. Se puede configurar el tipo, el estilo y muchas más cosas, tanto de forma interactiva como mediante opciones en línea de comandos.Lo más habitual es usar la configuración que viene por defecto, pero también se pueden crear soluciones a medida. Te muestro unos ejemplos para que pruebes y te familiarices con la herramienta. Para más información mira la documentación del comando ng new.2.1 Normal123ng new normalcd normalnpm start2.2 Minimalista123ng new minimalista -s -S -tcd minimalistanpm start2.3 Profesional123ng new profesional -p acme --routing truecd profesionalnpm start2.4 Empresarial1234ng new empresarial --create-application falsecd empresarialng generate application compras -p acme --routing truenpm startUna vez finalizada la instalación de todas las librerías necesarias puedes bajar a la carpeta recién creada y ejecutar el comando standard de npm para el arranque de cualquier aplicación: npm start. Si todo va bien, en unos segundo podrás visitar http://localhost:4000 para ver en marcha la aplicación. Lo veremos con más detalle en el apartado de configuración.ejemplo: La aplicación que sirve de ejemplo a este tutorial fue creada con este comando:1ng new angular-board --routing true -s -S3. Estructura de una aplicación AngularUna vez generada y comprobada la ejecución, toca estudiar cómo es la estructura de la aplicación. Para ello revisa carpeta a carpeta. Las malas noticias son que hay una enorme cantidad de ficheros y carpetas, las buenas son que como verás, casi todo es configuración e infraestructura.3.1 Visual Studio CodePara ver y editar los ficheros te vale cualquier editor de código, pero yo uso y te recomiendo VSCode. Es un gran editor, gratuito y multiplataforma. Viene con un terminal integrado y puedes mejorarlo instalando extensiones desde una galería del propio editor.Te recomiendo instalar un paquete de extensiones ya configurado y preparado para el desarrollo de aplicaciones con Angular, se llama Angular Essentials. Con eso y el Material Icon Theme verás Angular en colores.3.2 Carpetas y Ficheros principalesVolviendo a la estructura de ficheros y carpetas te encontrarás con muchos archivos de distintos tipos. Si eres completamente nuevo en Angular, te llamará la atención las extensiones .ts. Son para ficheros TypeScript, una evolución del JavaScript con facilidades para el programador. Por ahora sólo tienes que familiarizarte con estos:angular.json : configuración del propio CLI. La madre de todos los configuradorespackage.json : dependencias de librerías y scriptssrc/ : la carpeta donde están los archivos fuentesindex.html : un fichero HTML índice estándarmain.ts : fichero TypeScript de arranque de la aplicaciónapp/ : la carpeta con el código específico de tu aplicaciónapp.module.ts : la aplicación es un árbol de módulos, y este es su raízapp.component.ts : la página es un árbol de componentes, y este es su raízapp.component.html : el componente tiene una parte visual, esta es su vistaEcha un vistazo a estos ficheros, pronto los modificaremos para sentirnos programadores.4. EdiciónAngular CLI instala y configura un conjunto de herramientas que te harán la vida más fácil. Entre otras, destaca la capacidad de recargar la aplicación en caliente en cuanto guardas tu trabajo como programador. En esta última versión, la 7, se ha mejorado el proceso y es realmente rápido.Para probarlo sólo tienes que dejar arrancada la aplicación con el comando npm start; cambiar un fichero de código y comprobar el resultado en el navegador. Te propongo empezar como en cualquier otro lenguaje; por el famoso hola mundo.4.1 Hola MundoAbre el fichero app.component.ts y busca dentro de él una clase llamada AppComponent. Encontrarás que tiene una propiedad title. Asígnale el saludo de rigor: title = &#39;actibot: hello world ;-)&#39;;. Guarda y comprueba cómo tu navegador se habrá actualizado automáticamente.Toda esta magia depende de una cadena de comandos que lanzan distintas herramientas previamente instaladas y configuradas por el CLI. Entre ellas cabe mencionar a WebPack, un coloso que afortunadamente viene instalado y preparado para funcionar de manera transparente.4.2 npm startEsta es una lista no exhaustiva de lo que sucede.npm startng servewebpack server en http://localhost:4270vigilancia de cambios sobre la carpeta src/live reloadcompilado de la aplicaciónrecarga del navegadorCambia a tu antojo el app.component.ts o su hermano app.component.html y comprueba los cambios de manera inmediata en tu navegador.5. ConfiguraciónEl CLI 7 viene con pilas incluidas, se puede usar desde el primer momento. Sólo quedan pequeñas mejoras que hacer. Por ejemplo ajustar el package.json y agregar librerías de terceros.5.1 Package.jsonEl package.json es el fichero estándar de npm donde se almacenan las dependencias de terceros. Contiene las librerías que necesita la aplicación para ejecutarse, por ejemplo todas las de Angular 7. Y también las herramientas que necesita el programador, por ejemplo el propio AngularCLI;12345678&#123; \"dependencies\": &#123; \"@angular/core\": \"^7.2.0\" &#125;, \"devDependencies\": &#123; \"@angular/cli\": \"7.2.0\" &#125;&#125;Otro uso del package.json es servir de contenedor de scripts para automatizar tareas de operaciones rutinarias. Por ejemplo, el comando estándar npm start ejecutará el contenido asignado en el fichero json, originalmente ng serve. Esto lanza el servidor de pruebas con sus opciones por defecto.Pero el comando ng serve admite muchas configuraciones. Te propongo que uses esta para activar un modo de compilación más rápido y seguro, y para que se abra el navegador de forma automática en cuanto lances el servidor. Y además te recomiendo que uses un puerto específico para cada aplicación.Otras configuraciones en producción123&#123; \"start\": \"ng serve --aot -o --port 4270\"&#125;5.2 Estilos y librerías de tercerosLas librerías que vienen de fábrica tienen todo lo necesario para crear aplicaciones. Pero raro es el caso en que no necesitemos algún que otro producto de terceros. Ya sean utilidades como date-fns, librerías gráficas como chart.js o la aplicación de estilos y componentes visuales de frameworks como Bootstrap o MaterialDesign. Pero todos se instalan de igual forma. Descargándolos con npm y adjuntándolos en el angular.json.En este tutorial te propongo usar una hoja de estilos muy simple que mejora la apariencia de cualquier aplicación sin necesidad de usar clases propias. Se llama MiniCSS y es apropiada para prototipos, pruebas o pequeños proyectos.Se descargan e instalan de manera estándar.1npm install mini.css --savePara que se incluyan en la distribución hay que ir a la configuración del CLI. Entonces se agrega dentro del fichero .angular.json a la colección de styles o de scripts que corresponda.123&#123; \"styles\": [\"src/styles.css\", \"./node_modules/mini.css/dist/mini-default.min.css\"]&#125;Estas colecciones de archivos los usa el cli a través de webpack para incluirlos minificados y concatenados en un fichero bundle sustituyendo a las clásicas etiquetas html.Todo, el html y sus estilos, se construirá en el cliente a partir de instrucciones JavaScript. De esta forma el fichero index.html apenas tendrás que tocarlo, salvo para algunas etiquetas de meta información.123&lt;meta name=\"description\" content=\"A sample project for learning Angular ;-)\" /&gt;&lt;meta name=\"keywords\" content=\"Angular Sample Tutorial Ejemplo\" /&gt;&lt;meta name=\"author\" content=\"Alberto Basalo\" /&gt;Una cosa más, los cambios en los ficheros de configuración no se auto recargan. Tienes que parar la servidor y volver a lanzarlo para apreciar el estilo MiniCSS.5.3 EnvironmentsLa carpeta environments/ contiene dos ficheros, y puede contener más, para cada entorno de distribución necesario. En código siempre importaremos el fichero base, pero durante la compilación el CLI lo sustituirá por el adecuado.1title = environment.appName + 'hello world ;-)';5.4 AssetsLos ficheros de la carpeta assets/ se copian tal cual al despliegue. Es un buen lugar para logos, imágenes y ficheros de datos estáticos.Por ejemplo, en el app.component.html he sustituido la imagen incrustada del Angular con un logo propio.1&lt;img width=\"100\" src=\"./assets/logo.png\" /&gt;6. Angular 7, el CLI 7 y su ecosistemaAlgunos consejos y herramientas útiles que rodean al mundo Angular.Pero si la línea de comandos te suena muy antigua y lo tuyo son las interfaces gráficas, estás de suerte. El reciente proyecto Angular Console te permite generar y ejecutar comandos desde una cómoda interfaz gráfica.Una mejora digna de mención es la capacidad de presupuestar tamaños de los ficheros generados. De esa forma podemos controlar el peso y tiempo de descarga de la aplicación.Para garantizar la limpieza del código conviene usar herramientas como Prettier y configurarlas para su compatibilidad con Angular.Los últimos toques antes de publicar pueden incluir el script de analytics en el index.html y ajustes de retro-compatibilidad en el fichero polyfills.ts. Luego un comando y listo para publicar en github pages.Te recomiendo que te familiarices y uses mucho estos scripts en el package.json para poder lanzarlos más tarde.123456789101112131415&#123; \"scripts\": &#123; \"build:prod\": \"ng build --prod\", \"build:pub\": \"ng build --prod --output-path docs --base-href https://academiabinaria.github.io/angular-board/\", \"e2e\": \"ng e2e\", \"http-server\": \"http-server ./dist/angular-board/ -c-1 -p4271 -a localhost -o\", \"lint\": \"ng lint\", \"ng\": \"ng\", \"pub\": \"npm run build:pub &amp;&amp; npm run push\", \"push\": \"git add * &amp;&amp; git commit -m 'pub' &amp;&amp; git push\", \"start:prod\": \"npm run build:prod &amp;&amp; npm run http-server\", \"start\": \"ng serve --aot -o --port 4270\", \"test\": \"ng test\" &#125;&#125;Comprueba las ejecuciones de los distintos scripts. Con npm start no se generan ficheros físicos. Todos es en memoria para mayor velocidad de re-compilación mientras desarrollas. En cambio npm run build:prod creará una carpeta ./dist/angular-board en la que dejará los archivos necesarios para ejecución. Por último npm run pub los prepara para enviar compilados a la carpeta estándar ./docs listos para publicarse en las github pages.Otros enlaces de interés sobre el ecosistema Angular.Extensiones EsencialesPrettierAngular ConsoleAngular MaterialBootstrapAuguryApollo GraphQLIonicAngular ConsolePara complementar tu conocimiento te recomiendo la documentación de Angular/CLI y este artículo avanzado que trata la configuración del CLI en profundidad Angular CLI under the hood Esto es sólo el principio, Angular CLI 7 puede hacer mucho más por ti; descúbrelo en esta serie tutorial para aprender a programar con Angular 7. En el próximo artículo crearemos una Base para una aplicación Angular.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"CLI","slug":"CLI","permalink":"https://academia-binaria.com/tag/CLI/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"}]},{"title":"Velocidad y SEO con el SSR de Angular Universal","slug":"velocidad-y-seo-con-el-ssr-de-angular-universal","date":"2018-10-30T11:50:27.000Z","updated":"2018-12-03T16:37:55.771Z","comments":true,"path":"velocidad-y-seo-con-el-ssr-de-angular-universal/","link":"","permalink":"https://academia-binaria.com/velocidad-y-seo-con-el-ssr-de-angular-universal/","excerpt":"Las SPA JavaScript, muy balanceadas hacia el navegador, nacieron para crear con tecnología web aplicaciones de negocio. Normalmente se desplegaban en intranets, o en internet para usuarios autorizados. Eran aplicaciones de uso intensivo, visita recurrente y alto rendimiento diario. El éxito tecnológico de frameworks como Angular las llevó a ser usadas para desarrollar webs clásicas de internet y ser utilizadas por visitantes ocasionales.Pero en esta situación presentaron dos problemas para los que inicialmente no estaban preparadas. Por un lado la primera visita de un humano obligaba a la descarga completa de la aplicación antes de poder ver nada. Y nada era lo que veían los visitantes robóticos que pretendían indexar un sitio. Las soluciones a estos problemas incluyen, entre otras medidas, una vuelta al servidor. Lo que en Angular se conoce como aplicación universal.","text":"Las SPA JavaScript, muy balanceadas hacia el navegador, nacieron para crear con tecnología web aplicaciones de negocio. Normalmente se desplegaban en intranets, o en internet para usuarios autorizados. Eran aplicaciones de uso intensivo, visita recurrente y alto rendimiento diario. El éxito tecnológico de frameworks como Angular las llevó a ser usadas para desarrollar webs clásicas de internet y ser utilizadas por visitantes ocasionales.Pero en esta situación presentaron dos problemas para los que inicialmente no estaban preparadas. Por un lado la primera visita de un humano obligaba a la descarga completa de la aplicación antes de poder ver nada. Y nada era lo que veían los visitantes robóticos que pretendían indexar un sitio. Las soluciones a estos problemas incluyen, entre otras medidas, una vuelta al servidor. Lo que en Angular se conoce como aplicación universal.Partiendo del código tal cómo quedó en El patrón Redux con NgRx en Angular. Al finalizar tendrás una aplicación que se instala, actualiza y comporta como una aplicación nativa.Código asociado a este artículo en GitHub: AcademiaBinaria/AutoBot/c-universal y en el proyecto demo AcademiaBinaria/Astrobot1 Velocidad, primera visita y sucesivasEl reto está en mantener lo bueno de las aplicaciones javascript como es la transición fluida entre páginas, la interactividad o la descarga de datos bajo demanda. Pero combinado con una mejor primera experiencia. Para ello la descarga del index.html tiene que venir con un documento html ya preparado con algo para mostrar y tardar lo menos posible en permitir la interacción.El tiempo para el primer pintado se ve penalizado por el tamaño del bundle principal de Angular, pues en él reside habitualmente el componente app que actúa de raiz. Por supuesto que utilizar la carga diferida de módulos es una manera obligada de reducir el peso del main. Todas las rutas, incluída la ruta base, deben ser lazy para retrasar la navegación y que la descarga se produzca más tarde. Sólo el componente raiz con la shell de navegación básica debería venir en el bundle principal.Pero ni con eso es suficiente. El usuario no verá nada hasta que Angular se descargue, reclame el bundle main, lo procese y renderece ese shell. Hay usar alguna estrategia extra para reducir el tiempo de espera y entretener al usaurio.1.1 Prerenderizado estáticoLa más sencilla es hacer que el index.html, habitualmente vacío, se rellene con un contenido visualizable mientras el proceso principal de Angular no arranca. En ocasiones basta con poner a mano algún mensaje o animación que indique que estamos cargando. Pero cuanto más se parezca esa primera visión al resultado final mejor para el usuario. Así que lo propio sería que el index.html ya bajase con el shell real de la aplicación.Montar eso a mano no es la mejor opción. La solución parte de renderizar el html durante el proceso de deploy. Se trata de configurar el CLI para que ejecute la aplicación en la máquina del desarrollador sobre una ruta predefinida; y que copie el resultado sobre el index.html que enviará a distribución.Este trabajo se ha automatizado y se resuelve con un par de comandos del Angular CLI.1ng g app-shell --client-project astrobot --universal-project server-astrobotEl efecto de este comando se materializa especialmente con la aparición de nuevos targets para los builders del CLI en el fichero angular.json.Con el comando ng run astrobot:app-shell podrás generar una versión especial de distribución en al que el index.html ya va prerenderizado con el contenido del componente asociado a la ruta shell. Realmente lo que hace es ejecutar tu aplicación sobre una ruta predefinida, tomar el html resultado e inyectarlo en el body del index.html que irá a distribución.Compruébalo en la ejecución de Astrobot, viendo el código fuente de la página descargada.Por cierto, esta técnica no obliga a disponer de ningún servidor web especial. Sigue funcinando con un servidor estático de ficheros pues la prerenderización se produjo en la máquina del programador.1.2 Renderizar en el servidor con SSRClaro que esto es sólo un truco para que ese primer momento de espera se reduzca y no perdamos potenciales visitantes. Si queremos algo más, como por ejemplo que el contenido a descargar sea más fresco, entonces necesitaremos renderizar en el servidor. Y para ello necesitaremos un servidor de verdad. El propuesto y mejor documentado es Express de NodeJS.Para empezar tendrás que instalar y registrar las librerias necesarias. Además habrá que crear el pequeño servidor Express, y configurar al CLI para que haga el despliegue de ambos: cliente y servidor. Este laborioso trabajo se ha automatizado y ahora mismo se resuelve casi todo con un par de instrucciones.12ng add @nguniversal/express-enginenpm run build:ssr &amp;&amp; npm run serve:ssrEl resultado es un servidor Node que a cada petición web responde enviando el index.html. Pero, y esta es la clave, resolverá la ruta ejecutando la aplicación Angular antes de responder al navegador. De esa forma el index.html irá recién generado con el contenido tal cual lo vería el usuario tras la ejecución de Angular en local. Así que la espera al primer pintado significativo se reduce y eso es bueno.Por si fuera poco, la principal ventaja al usar este método es que al traer información dinámica puede usarse para indexar el contenido real del sitio. Esto es dóblemente bueno, porque ahora todos los robots indexadores podrán catalogar tu site como si de una web clásica se tratase. Y los usuarios humanos podrán continuar la ejecución en local disfrutando de las ventajas de una SPA.De todas formas tengo que advertirte de que tomes todo esto con cautela por varios motivos:Tecnología compleja estable pero con carenciasHerramientas de generación buenas pero incompletasTransferencia de estado manual para evitar llamadas repetidas al APITampoco es sencilla la convivencia con librerias propias del browser, y menos si se trata de una PWA. Yo procuro usar un servicio que aisle al servidor de ciertas llamadas sólo disponibles en el navegador, como por ejemplo todo lo relativo al localStorage.123456789101112131415161718192021222324import &#123; isPlatformBrowser, isPlatformServer &#125; from '@angular/common';import &#123; Inject, Injectable, PLATFORM_ID &#125; from '@angular/core';@Injectable(&#123; providedIn: 'root'&#125;)export class UniversalService &#123; constructor(@Inject(PLATFORM_ID) private platformId: string) &#123;&#125; public isBrowser() =&gt; isPlatformBrowser(this.platformId); public isServer() =&gt; isPlatformServer(this.platformId); public saveOnStorage(key, value) &#123; if (this.isBrowser()) &#123; sessionStorage.setItem(key, value); &#125; else &#123; &#125; &#125; public loadFromStorage(key) &#123; if (this.isBrowser()) &#123; sessionStorage.getItem(key); &#125; else &#123; return null; &#125; &#125;&#125;2 SEO en la página, en el navegador y en el servidorCon lo visto hasta ahora tu apliación estará más que cubierta en cuanto a ofrecer la mejor experiencia para usuarios al tiempo que envía contenido indexable para robots… Pero falta algo.Habitualmente las aplicaciones Angular manejan el contenido visible de una página web; es decir, el body. Para acceder y cambiar el contenido del header, tan utilizado por los robots de redes sociales, hay que usar algo más.2.1 Titulo y meta etiquetas de páginaComo parte del framework viene la librería platform-browser dónde tenemos un par de servicios para manipular el título y cualquier etiqueta de meta información de la página.Para ello suele usarse un código similar a este en el componente raiz de la aplicacion. Es muy sencillo pero te dará una idea del potencial de estos servicios:123456789101112import &#123; Meta, Title &#125; from '@angular/platform-browser';@Component(&#123; selector: 'app-root', template: `&lt;p&gt;Aprende a usar el framework Angular&lt;/p&gt;`,&#125;)export class AppComponent implements OnInit &#123; constructor(private title: Title, private meta: Meta) &#123;&#125; ngOnInit() &#123; this.title.setTitle('My title'); this.meta.addTag(&#123; property: 'og:title', content: 'My title' &#125;, true); &#125;&#125;Ahora ya tienes una aplicación que satisface a usuarios y robots por igual. Continúa tu formación avanzada para crear aplicaciones Angular siguiendo la serie del tutorial avanzado de desarrollo con Angular y verás como aprendes a programar con Angular 7.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular6","slug":"Angular6","permalink":"https://academia-binaria.com/tag/Angular6/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"},{"name":"Universal","slug":"Universal","permalink":"https://academia-binaria.com/tag/Universal/"},{"name":"SSR","slug":"SSR","permalink":"https://academia-binaria.com/tag/SSR/"}]},{"title":"PWA, Entre la web y las apps con Angular","slug":"pwa-entre-la-web-y-las-apps-con-angular","date":"2018-10-15T10:50:27.000Z","updated":"2018-12-03T16:38:39.288Z","comments":true,"path":"pwa-entre-la-web-y-las-apps-con-angular/","link":"","permalink":"https://academia-binaria.com/pwa-entre-la-web-y-las-apps-con-angular/","excerpt":"Las aplicaciones web han evolucionado desde el contenido estático al dinámico, luego al adaptable y ahora se acercan progresivamente a la experiencia y rendimiento de aplicaciones nativas. En Angular se incorporan esas capacidades desde el propio framework.Mediante la librería @ngular/pwa dispondremos de todo lo necesario para ofrecer instalación en escritorio, actualizar la aplicación controladamente, recibir notificaciones del servidor e incluso mejoras en la caché de comunicaciones que pudieran permitir un funcionamiento offline.","text":"Las aplicaciones web han evolucionado desde el contenido estático al dinámico, luego al adaptable y ahora se acercan progresivamente a la experiencia y rendimiento de aplicaciones nativas. En Angular se incorporan esas capacidades desde el propio framework.Mediante la librería @ngular/pwa dispondremos de todo lo necesario para ofrecer instalación en escritorio, actualizar la aplicación controladamente, recibir notificaciones del servidor e incluso mejoras en la caché de comunicaciones que pudieran permitir un funcionamiento offline.Partiendo del código tal cómo quedó en El patrón Redux con NgRx en Angular. Al finalizar tendrás una aplicación que se instala, actualiza y comporta como una aplicación nativa.Código asociado a este artículo en GitHub: AcademiaBinaria/AutoBot/b-pwa1 Las herramientas de la librería PWAAprovechando las nuevas características del Angular CLI 7 tenemos el comando ng add @angular/pwa que instala los paquetes y configura cualquier aplicación Angular conviertiéndola en una PWA básica.Estos son los actores y ficheros involucrados en este proceso tras la agregación del paquete pwa.ServiceWorkerModule./angular.json { “serviceWorker”: true }./ngsw-config.json./src/manifest.json./src/index.html./assets/icons/..Con todo instalado y configurado, querrás probar que funciona. Pero, a primera vista no ocurre nada. Las características PWA están preparadas para funcionar en modo producción. Así que lo primero será ejecutar el comando ng build --prod y lanzar un servidor sobre la carpeta de distribución recién creada.De entre los nuevos ficheros que aparecen hay dos que debes conocer especialmente, el manifest y el service worker.1.1 El manifest.jsonEste sencillo documento acompaña al index.html y le da indicaciones al navegador para que trate esta aplicación de menera especial. El fichero en sí contiene una metadata con textos descriptivos, colores e iconos para ser usados por el navegador y el sistema operativo y ofrecerle al usuario que instale la web como una app.Casi todo es cosmético, pero merece la pena prestar especial atención a los iconos. Por defecto el CLI instala distintas versiones del logo ofical de Angular. Una forma cómoda de sustituirlo por los tuyos es usar la herramienta ngx-pwa-icons1234567891011121314151617&#123; \"name\": \"Play with cars, learning Angular\", \"short_name\": \"autobot\", \"theme_color\": \"#1976d2\", \"background_color\": \"#fafafa\", \"display\": \"standalone\", \"scope\": \"/\", \"start_url\": \"/autobot/?utm_source=homescreen\", \"icons\": [ &#123; \"src\": \"assets/icons/icon-72x72.png\", \"sizes\": \"72x72\", \"type\": \"image/png\" &#125;, ... ]&#125;Asegúrate de que en la start_url apunte a la página de inicio correcta y despliega en modo producción en un servidor seguro con https. Pruébalo varias veces en distintos navegadores y verás las distintas experiencias de instalación que ofrecen.1.2 El ngsw-worker.jsEl otro gran fichero, y más importante para los desarrolladores, es el configurador del Service Worker. Cuando un navegador ejecuta un script lo hace en thread dedicado a la interacción con el usuario y la manipulación del DOM. Normalmente ese hilo está muy ocupado, cuando no está saturado. La solución para agilizar los procesos está en usar más threads. Presentamos el worker thread.Se le llama así a los hilos creados a partir del principal y que le ayudan en tareas en segundo plano. Esos hilos tienen prohibido el acceso al DOM, ni lo escuchan ni lo manipulan. Pero a cambio están muy liberados para realizar cálculos complejos o llamadas a servicios. Se comunican con el thread principal a traves de un sencillo protocolo de eventos y subscripciones.Una de las tareas para las que más se les utiliza es para la gestión inteligente de las comunicaciones. Este fichero viene pre programado para realizar las siguientes funciones PWA de Angular:Caché de contenido estático para funcionamiento offlineCaché de datos dinámicos para mayor velocidadGestión de instalaciones y versionesNotificaciones de datos pushTodo lo que hay que hacer es configurar estas funciones en un fichero, el ngsw-config.json, ya generado con valores por defecto. El CLI, durante el proceso de construcción en modo producción, copiará y manipulará los scripts y sus configuraciones. En ejecución, el ServiceModule registrará el script en el navegador, se subscribirá a sus eventos y ejecutará lo configurado por el programador en el json.2 Comunicaciones y cachéEl service worker de Angular está especialmente diseñado para hacerse cargo de las comunicaciones con el servidor. Digamos que se convierte en un interceptor transparente de todas las peticiones http. Tanto de los ficheros propios de la aplicación como de las comunicaciones de datos.2.1 Descarga y actualización de la aplicaciónUna vez descargado el index.html con el contenido mínimo de Angular, diríamos que la aplicación se ha instalado y está lista para ejecutarse. A partir de ese momento el ngsw toma el control y puede pre descargar ficheros en segundo plano; de forma que cuando sean reclamados ya estén disponibles y mejoren la experiencia del usuario.Rutinariamente el servicio se ocupará de consultar novedades en el servidor para mantener los ficheros locales actualizados. Todo ello se configura en la sección assetGroups del ngsw-config.json.123456789101112131415161718192021222324252627282930313233&#123; \"assetGroups\": [ &#123; \"name\": \"app\", \"installMode\": \"prefetch\", \"updateMode\": \"prefetch\", \"resources\": &#123; \"files\": [ \"/favicon.ico\", \"/index.html\", \"/*.css\", \"/common*.js\", \"/main*.js\", \"/ngsw*.js\", \"/woker*.js\", \"/polyfills*.js\", \"/runtime*.js\", \"/fontawesome*\" ] &#125; &#125;, &#123; \"name\": \"assets\", \"installMode\": \"lazy\", \"updateMode\": \"prefetch\", \"resources\": &#123; \"files\": [ \"/assets/logo.png\", \"/assets/icons/**\", \"/*.js\" ] &#125; &#125;],&#125;2.2 Caché inteligente de datosEl control de la recepción de datos dinámicos es la otra gran tarea del service worker. En este caso para tener una caché que acelere la presentación de datos o que incluso permita un funcionamiento offline.Mediante dos estrategias complementarias que tratan de mantener los datos actualizados y disponibles en todo momento. En este caso configurandolo en los dataGroups.La idea del cache-first es tener el dato ya listo para ser usado cuanto antes. Mientras que con api-first se pretende tener la versión más actual posible, y usar la última descargada en caso de problemas o desconexión total.123456789101112131415161718192021222324252627&#123; dataGroups\": [ &#123; \"name\": \"cache-first\", \"urls\":[ \"https://academiabinaria.github.io/autobot/assets/data/cars.json\" ], \"cacheConfig\":&#123; \"strategy\":\"performance\", \"maxSize\":10, \"maxAge\":\"1d\" &#125; &#125; ,&#123; \"name\": \"api-first\", \"urls\":[ \"https://api-base.herokuapp.com/api/priv/travels/**\" ], \"cacheConfig\":&#123; \"strategy\" : \"freshness\", \"maxSize\": 100, \"maxAge\" : \"1h\", \"timeout\" : \"5s\" &#125; &#125; ]&#125;3 ServiciosLa librería @angular/pwa publica el módulo ServiceWorkerModule que contiene la lógica de registro del service worker y dos servicios programables con los que interactuar desde el código de tu aplicación Angular.3.1 Actualización con el SwUpdateCuando despliegas una nueva versión seguro que estás deseando que los usuarios disfruten cuanto antes de las mejoras o correcciones. Pero en las aplicaciones SPA resulta que la actualización no es tan inmediata como pudiera parecer. Al no forzar la recarga del documento en las navegaciones internas, el index.html puede residir sin cambios más de lo debido. Confiar en que lo hagan el navegador o el usuario puede no ser una opción.La solución PWA es usar el ServiceWorker para detectar nuevas versiones en el servidor. Para ello utiliza un sistema propio de hashes que le permite comparar la versión descargada y la disponible en el servidor. Cuando detecta un cambio emite un evento al que te puedes subscribir usando el servicio SwUpdate. En ese momento puedes consultar al usuario, o forzar a lo bestia la recarga ;-).123456789constructor(private swUpdate: SwUpdate) &#123; if (this.swUpdate.isEnabled) &#123; this.swUpdate.available.subscribe((event: UpdateAvailableEvent) =&gt; &#123; if (confirm(`Do you want to update?`)) &#123; window.location.reload(); &#125; &#125;); &#125;&#125;3.2 Notificaciones con el SwPushUna caracterísitca de las apps nativas muy aprecia por los usuarios es la capacidad de mostrar mensajes recibidos vía push por parte del servidor. Pueden ser avisos, novedades o simple marketing. Pero lo importante es que lo recibe el sistema operativo, la aplicación no necesita estar en marcha y el mensaje se muestra de forma nativa.Obviamente para ello hay que involucrar código de servidor y un servicio de mensajería de terceros. Pero la parte Angular del desarrollo es muy sencilla. Consite en registrar al usuario, que voluntariamente decide ser notificado, y luego escuchar los mensajes provenientes en forma de eventos. Todo ello reclamando una dependencia al servicio de notificaciones constructor(private swPush: SwPush).Ya tienes una web que se comporta progresivamente como una App nativa, una Progressive Web Application. Las mejoras en rendimiento y experiencia de usuario son recompensa más que suficiente para que le des una oportunidad a las Angular PWA.Continúa tu formación avanzada para crear aplicaciones con mayor Velocidad y SEO con el SSR de Angular Universal y verás como aprendes a programar con Angular 7.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular6","slug":"Angular6","permalink":"https://academia-binaria.com/tag/Angular6/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"},{"name":"PWA","slug":"PWA","permalink":"https://academia-binaria.com/tag/PWA/"}]},{"title":"El patrón Redux con NgRx en Angular","slug":"el-patron-redux-con-ngrx-en-angular","date":"2018-10-08T10:50:27.000Z","updated":"2018-12-03T16:40:17.371Z","comments":true,"path":"el-patron-redux-con-ngrx-en-angular/","link":"","permalink":"https://academia-binaria.com/el-patron-redux-con-ngrx-en-angular/","excerpt":"Le pasa a todas las aplicaciones. Crecen y crecen en funcionalidad y complejidad. En Angular estamos preparados para modularizar, componentizar e inyectar servicios. Pero con grandes aplicaciones, o con grandes equipos, parece que nada es suficiente. Se necesita una gestión del estado centralizada como la del patrón Redux.Redux no hace rápido lo simple, sino mantenible lo complejo. Y si tienes delante un desarrollo complejo, te recomiendo que uses NgRX; la solución estándar para implementar Redux con Angular.","text":"Le pasa a todas las aplicaciones. Crecen y crecen en funcionalidad y complejidad. En Angular estamos preparados para modularizar, componentizar e inyectar servicios. Pero con grandes aplicaciones, o con grandes equipos, parece que nada es suficiente. Se necesita una gestión del estado centralizada como la del patrón Redux.Redux no hace rápido lo simple, sino mantenible lo complejo. Y si tienes delante un desarrollo complejo, te recomiendo que uses NgRX; la solución estándar para implementar Redux con Angular.Partiendo del código tal cómo quedó en Detección del cambio en Angular. Al finalizar tendrás una aplicación que gestiona centralizadamente los cambios, que permite conocer qué ocurrió y predecir lo que ocurrirá.Código asociado a este artículo en GitHub: AcademiaBinaria/AutoBot/a-redux1 El patrón ReduxRedux es como una base de datos, es en un almacén para el estado de la aplicación. Pero un almacén que gestiona sus cambios de manera predictiva. Combina dos patrones: Action para el envio de comandos para actualizar el estado del almacén; y Observable para la subscripción a cambios en el estado del almacén. Desacopla los emisores de acciones de los receptores de cambios en los datos.Para lograrlo tendremos que cumplir una serie de principios y utilizar unos elementos predefinidos. Esto introduce capas de abstracción y burocracia que inicialmente complican el desarrollo. Pero a medio plazo harán que mantener la aplicación sea mucho más sencillo y seguro.1.1 Principios de ReduxTenemos tres principios básicos que cumplir:Single Source Of Truth: Cada pieza de información se almacena en un único lugar, independientemente de dónde sea creada, modificada o requerida.Read Only State: La información será de sólo lectura y sólo podrá modificarse a través de conductos oficiales.Changes By Pure Functions: Los cambios tienen que poder ser replicados, cancelados y auditados; lo mejor, usar una función pura.1.1 Elementos de ReduxEstos son los artificios fundamentales que incorporaremos a nuestro desarrollo:Store: El sistema que mantiene el estado. Despacha acciones de mutado sobre el mismo y comunica cambios enviando copias de sólo lectura a los subscriptores.State: Árbol de objetos que contienen la única copia válida de la información. Representa el valor del almacén en un momento determinado.Actions: Objetos identificados por un tipo y cargados con un payload. Transmiten una intención de mutación sobre el estado del store.Reducers : Son funciones puras, que ostentan la exclusividad de poder mutar el estado. Reciben dos argumentos: el estado actual y una acción con su tipo y su carga. Clonan el estado, realizan los cambios oportunos y devuelven el estado mutado.Los funciones reductoras, al ser puras, mezclan la programación funcional con la orientada a objetos. Un reto pero también una demostración de la coexistencia de paradigmas en un mismo desarrollo.2 NgRxNgRx es el estándar de facto para implementar Redux en Angular. Está basada en RxJS y es una librería modular con todo lo necesario para crear grandes aplicaciones. Esto son los módulos que la componen:store: Es el módulo principal con el administrador del estado centralizado y reactivo.store-devtools: Instrumentación para depurar desde el navegador. Vale su peso en oro.router-Store : Almacena el estado del router de Angular en el store, tratando cada evento como una acción Redux.effects: Los reductores son funciones puras sin efectos colaterales. Este módulo es la solución para comandos asíncronos.schematics, entity, ngrx-data: Son otros módulos opcionales con ayudas y plantillas de NgRX.2.1 Instalación y configuraciónPara agregar NgRx a un app te propongo la siguiente receta de comandos. Además de esto tendrás que instalar en tu navegador las herramientas de diagnóstico Redux DevTools.1234567npm i @angular-devkit/schematics --save-devnpm i @ngrx/schematics --save-devng config cli.defaultCollection @ngrx/schematicsnpm i @ngrx/store --savenpm i @ngrx/store-devtools --save ng g st RootState --root -m app.module.ts --spec falsenpm install @ngrx/router-store --saveCon esto habrás instalado y configurado NgRx en tu app. Completa tu módulo principal para que tenga algo así:12345678910@NgModule(&#123; imports: [ CommonModule, RouterModule, StoreModule.forRoot(rootReducers, &#123; metaReducers &#125;), StoreRouterConnectingModule.forRoot(&#123; stateKey: 'router' &#125;), !environment.production ? StoreDevtoolsModule.instrument() : [] ]&#125;)export class AppModule &#123;&#125;El código generado por @ngrx/schematics no es para todos los gustos. Tómalo como un punto de partida y crea la estructura que mejor te encaje. En Autobot he empezado por llevarlo todo al CoreModule y guardarlo en una carpeta propia convenientemente nombrada store/state. Veámosla en detalle.2.2 State y reducers, los cambios de estado mediante reductoresEl estado en redux es un objeto tipado a partir de una interfaz, normalmente llamada State a secas, aunque yo prefiero identificarla como RootState. Tendrá propiedades para almacenar objetos más o menos complejos. Cada propiedad tendrá su propio tipo complejo y será gestionada por una función reductora específica. Se necesita un proceso de mapeo que asigne la función reductora a cada propiedad del estado raiz. Eso es lo que hace este código:1234567891011export interface RootState &#123; router: any; global: GlobalState; cars: CarsState;&#125;export const rootReducers: ActionReducerMap&lt;RootState&gt; = &#123; router: routerReducer, global: globalreducer, cars: carsReducer&#125;;Las funciones reductoras pueden estar en cualquier fichero. Son puras y no deben ser incluídas en ninguna clase. Normalmente tendrás un fichero para cada reductor. El del router ya viene hecho por NgRx, todos los demás son cosa tuya. Por ejemplo este es el reductor sobre la propiedad global: GlobalState.123456789101112export function globalReducer(state = initialState, action: GlobalActions): GlobalState &#123; switch (action.type) &#123; case GlobalActionTypes.SendUserMessage: return &#123; ...state, userMessage: action.payload &#125;; case GlobalActionTypes.IsLoginNeeded: return &#123; ...state, loginNeeded: action.payload &#125;; case GlobalActionTypes.StoreToken: return &#123; ...state, token: action.payload &#125;; default: return state; &#125;&#125;Como puedes ver esta función recibe dos argumento: el estado y la acción que pretende mutarlo. La acción es un objeto con dos propiedades. La primera y obligatoria es el tipo y sirve para escoger la lógica que se aplicará. La otra, opcional, es el payload que actúa como argumento de la acción. El reductor no puede usar nada más que estos argumentos: state y action. Y por ser puro no puede mutar ninguno, por tanto tiene que clonar el estado recibido antes de aplicarle cualquier cambio. Una vez efectuado el cambio, usando el payload si es preciso, devolverá el clon mutado.2.3 Actions, las acciones permitidasEl patrón Redux no obliga a grandes cosas respecto a cómo implementar las acciones. Lo único que de verdad necesitas es crear objetos con una propiedad obligatoria type y otra opcional payoload.Pero en NgRX han decidido aprovechar al máximo las papacidades del TypeScript y proponen usar un código fuertemente tipado. Para empezar crean un enum que detalla los posible tipos de una acción y les asigna un texto para que luzcan y faciliten su búsqueda en logs.12345export enum GlobalActionTypes &#123; SendUserMessage = '[Global] Show Message', IsLoginNeeded = '[Auth] Is Login Needed', StoreToken = '[Auth] Store Token'&#125;Y claro, en un ambiente tipado, la acción será una clase que ha de cumplir una interfaz. En dicha clase queda ya predetermindo su tipo de acción; y por supuesto que permiten fijar el tipo de datos de la payload. Todo ello genera un código como el siguiente.1234export class SendUserMesage implements Action &#123; readonly type = GlobalActionTypes.SendUserMessage; constructor(public payload: string) &#123;&#125;&#125;Para terminar, y ya que habremos de crear un buen número de clases para las acciones, también nos propone exprimir TypeScript para crear un tipo combinado que ofrezca a los consumidores el plantel completo y delimitado de acciones posibles.1export type GlobalActions = SendUserMesage | IsLoginNeeded | StoreToken;Es normal que al principio todo este boilerplate te parezca un exceso. Pero entre las plantillas, los snipets y el copy and paste no es tan trabajoso como pudiera parecer. A cambio tienes un código robusto y explícitamente detallado.2.4 Dispatch y Select, despacho de acciones y selección de cambiosDesde el resto del código la comunicación con este estado centralizado se realizará por dos conductos oficiales : Dispatch y Select. El primero es un método que recibe como único parámetro una instancia de una acción. Dicha instancia lleva implícito el tipo y puede ir rellena de una payload. Así es como se envían los cambios hacia el almacén.123constructor(private store: Store&lt;RootState&gt;) &#123; this.store.dispatch(new SendUserMesage('Tutorial Angular en Español'));&#125;No esperamos respuesta de este método. Es un mundo de fire and forget. Pero en cualquier otro lugar o lugares de nuestro código podremos recibir notificicadciones de cualquier cambio que se haya producido. De forma desacoplada podremos recibir el mensaje con una simple subscripción RxJS.123this.store .select('global', 'userMessage') .subscribe(userMessage: string =&gt; console.log(userMessage));A este método de consulta asíncrona se le envía un argumento con múltiples sobrecargas llamado selector. En este caso está formado por dos claves que apuntan a una propiedad concreta en la que estoy interesado: global.userMessage.Con esto tenemos una primera implementación del patrón Redux en Angular usando NgRx. Pero aún hay más.3 Efectos y módulos funcionalesLas funciones reductoras, como ya se ha dicho, deben ser puras. La idea es que puedan ser auditadas, re-ejecutadas y testeadas sin que necesiten servicios externos ni causen efectos colaterales. Y esto es un problema con la cantidad de ejecuciones asíncronas en las aplicaciones web. Cualquier tentación de lanzar una llamada AJAX dentro de un reductor debe ser elimindad de inmediato.Dos razones: por un lado en Angular se necesita invocar al httpClient de alguna manera para realizar la llamada AJAX. Y, ya que la función no pertenece a ninguna clase, no puede haber constructor que reclame la inyección de dicho servicio. Tampoco las funciones puras tienen permitido usar nada que no venga entre sus argumentos. Por otra parte las funciones puras han de ser predecibles, y una llamada a un servidor remoto no es en absoluto predecible. Puede pasarle de todo, así que los reductores no son país para procesos asíncronos.La solución que proponen NgRX es usar un artificio llamado efecto, porque será encargado de los efectos secundarios que provocan las las instrucciones asíncronas. De una forma simplista, diremos que las acciones asíncronas se multiplicarán por tres. El comando que genera la llamada, y los dos potenciales eventos con la respuesta correcta o el error.Para manejarlo todo incluyen en la librería el módulo EffectsModule que ha de registrarse junto al StoreModule. Desde ese momento NgRX activa un sistema de seguimiento que trata las acciones como un stream de RxJS y permite subscribirse a la invocación de dichas acciones y tratarlas adecuadamente. Una vez más, aprovechan las caraterísticas del TypeScript y hacen uso de los decoradores para definir las funciones que responderán a la ejecución de las acciones.3.1 @Effect(), efectos secundariosEl decorador @Effect() se aplica a propiedades de servicios estandar de Angular. NgRX invoca esas funciones ante cada acción despachada, así que lo primero que debemos hacer es aplicar un filtro para quedarnos con las acciones del tipo que nos interese. El que lanzará la llamda http.Todo el trabajo se realizará con streams y requiere de un conocimiento previo de la librería RxJS y de la mecánica de su método pipe y sus operadores reactivos.Cuando llegue una de esas acciones realizaremos la llamada asíncrona sin complejos. Recordemos que un efecto forma parte de un servicio inyectable de Angular. No tienen ninguna restricción funcional por parte de Redux. Obviamente la respuesta debe ser capturada y tratada según haya sido correcta o no.Si recibimos una respuesta válida podremos retornar directamente una nueva acción que actualice el estado con los datos recibidos. En cambio si ha habido un error, habrá que reactivar el stream con un nuevo observable que emita la acción que procesará el error.123456789101112@Effect()constructor(private actions$: Actions, private cars: CarsService) &#123;&#125;public loadCarsEffect$: Observable&lt;CarsActions&gt; = this.actions$.pipe( ofType&lt;LoadCars&gt;(CarsActionTypes.LoadCars), mergeMap(() =&gt; this.cars.getCars$().pipe( map((cars: Car[]) =&gt; new LoadCarsOK(cars)), catchError(err =&gt; of(new LoadCarsError('Error loading cars'))) ) ));Tómate el tiempo necesario para comprender este código. Especialmente los operadores ofType de NgRX y el mergeMap de RxJS. Fíjate bien en los tipos de los datos recibidos y devueltos. El efecto trata con observables de acciones. Recibe una y devuelve otra que puede ser de alguno de los otros dos tipos previstos. En el caso correcto se cambia una acción por otra, en otro caso se crea un nuevo observable mediante el constructor of() antes del retorno.Para un ejemplo más completo de estos conceptos explora la implementación en el proyecto Autobot. El RootStore hace uso de efectos en la carpeta store/state/cars.3.2 Feature, módulos funcionalesYa que Redux está especialmente indicado en grandes aplicaciones pero manteniendo un estado centralizado, es fácil que acabemos con un módulo raiz demasiado pesado que ralentice el inicio de la aplicación. Para adaptar la gestión central a un entorno con módulos cargado con lazyloading necesitamos una última ayuda, de la mano de FeatureModule.Esencialmente es una nuevo store supeditado al principal pero que no se define, y por tanto no pesa, hasta que no es necesario. En Autobot el CarModule es un buen ejemplo de store cargado de forma dinámica como una Feature.Ya tienes los conocimientos para gestionar de manera centralizada, auditable y predecible el estado de tus programas. El patrón Redux lucirá más cuanto más grande y compleja sea tu aplicación.Continúa tu formación avanzada para crear aplicaciones PWA, entre la web y las apps con Angular y verás como aprendes a programar con Angular 7.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular6","slug":"Angular6","permalink":"https://academia-binaria.com/tag/Angular6/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"},{"name":"Redux","slug":"Redux","permalink":"https://academia-binaria.com/tag/Redux/"},{"name":"NgRx","slug":"NgRx","permalink":"https://academia-binaria.com/tag/NgRx/"}]},{"title":"Detección del cambio en Angular","slug":"deteccion-del-cambio-en-Angular","date":"2018-09-28T10:09:27.000Z","updated":"2018-12-03T16:39:36.951Z","comments":true,"path":"deteccion-del-cambio-en-Angular/","link":"","permalink":"https://academia-binaria.com/deteccion-del-cambio-en-Angular/","excerpt":"La forma en que Angular realiza su renderizado y actualiza sus vistas es un factor clave para el rendimiento de las aplicaciones. ¿Cómo funciona la estrategia de detección de cambios de Angular? Pues tiene dos modos: default o automágico y onPush o mindfullness.Es importante tomar consciencia porque es costoso realizar la detección más veces de lo necesario y porque no hacerlo suficientemente implica no ver resultados reales. Con un mayor conocimiento del changDetectionStrategy y un poco de trabajo extra tendrás aplicaciones más eficientes y mantenibles.","text":"La forma en que Angular realiza su renderizado y actualiza sus vistas es un factor clave para el rendimiento de las aplicaciones. ¿Cómo funciona la estrategia de detección de cambios de Angular? Pues tiene dos modos: default o automágico y onPush o mindfullness.Es importante tomar consciencia porque es costoso realizar la detección más veces de lo necesario y porque no hacerlo suficientemente implica no ver resultados reales. Con un mayor conocimiento del changDetectionStrategy y un poco de trabajo extra tendrás aplicaciones más eficientes y mantenibles.Partiendo de la aplicación tal cómo quedó en Formularios reactivos con Angular. Al finalizar tendrás una aplicación que actualiza la vista sólo cuando es necesario, es decir: cuando los datos han cambiado.Código asociado a este artículo en GitHub: AcademiaBinaria/AutoBot/9-change1 Comunicación de datos entre componentesLa detección de cambios se dispara ante eventos que le ocurren a los componentes. La detección se realiza componente a componete, así que compensa tener muchos componentes pequeños, para que cada uno por si sólo no genere demasiado ruido.1.1 Componentes Contenedores y PresentadoresAl pasar de un único componente a varios mini-componentes, se propone usar el patrón contenedor / presentadores. Se mantiene un componente padre que contiene múltiples componentes presentadores hijos. El contendor es el único con acceso a los servicios de negocio y datos. Los presentadores reciben los datos y emiten eventos. Los presentadores no obtienen ni modifican por su cuenta.NomenclaturaContainer: aka Parent, SmartPresenter: aka Child, DumbEste reparto de responsabilidades es aconsejable independientemente de la estrategia de detección aplicada.2 Change detectionstrategiesCon la aplicación bien estructurada en componentes y con la comunicación estandarizada, habremos reducido el impacto de la detección del cambio y estaremos preparados para optimizarlo. Conozcamos en detalle las estratégias de detección del cambio.El decorador @Component() admite en su configuración la poco conocida propiedad changeDetection. Que de forma explícita se usa así:1234567import &#123; ChangeDetectionStrategy, Component &#125; from '@angular/core';@Component(&#123; changeDetection: ChangeDetectionStrategy.Default, selector: 'app-root', template: `&lt;h1&gt;Changes are wellcome&lt;/h1&gt; `&#125;)export class AppComponent &#123;&#125;2.1 Detección automática, defaultPor defecto, Angular tiene que ser conservador y verificar cada posible cambio, esto se denomina comprobación sucia o dirty checking. Se dispara con demasiada frecuencia, al menos en los siguientes casos:Eventos desde el browserTimers, intervals etc..Llamadas httpPromesas y código asíncrono.Por si fuera poco, además de dispararse mucho es muy costoso. Determinar que algo ha cambiado implica comparar dos estados: el actual y el anterior.La comparación es valor a valor, en profundidad, para cada objeto de cada array, para cada propiedad de cada objeto.Contod, esta estrategia es cómoda para el programador y suficiente para casos básicos. Pero demasiada mágia dificulta el control en aplicaciones complejas. Y en pantallas de mucha información e interacción degrada el rendimiento percibido.2.2 Detección manual, onPushComo se puede preveer, la detección del cambio manual es lanzada por el programador. No siempre va a ser laborioso, pero será más consciente pues para que ocurra han de darse alguna de estas circunstancias:Explícitamente el programador solicita la detección llamando a `ChangeDetectorRef.detectChanges();Implícitamente al usar el pipe Async en la vista se llama a ese mismo método.Conscientemente el desarrollador obliga a un componente a repintarse si le cambia la referencia a un @Input().En este modo los componentes dejan de evaluar y comparar sus propiedades rutinariamente. Sólo atienden a eventos @Output() o cambios de referencia @Input(). Esto relaja mucho al motor de Angular, que ya no tiene que hacer comparaciones odiosas. Sabrá que algo ha cambiado porque… es otro objeto.3 InmutabilidadComo ya se ha dicho, para que Angular en la estrategia automática decida que algo ha cambiado necesita hacer una comparación por valor. Para evitar ese coste usamos la estrategia manual y el programador tienen que cambiar la referencia de algo cuando quiera que Angualar repinte la vista.3.1 Por referencia y por valorNormalmente tendrá que crear un nuevo objeto y reasignarlo en lugar del anterior en un ciclo de clonación, mutación y asignación. Por costoso que parezca siempre compensa si evita muchas e innecesarias comparaciones por valor en estructuras profundas.La estrategia onPush trata a todos los Inputs en inmutables, es decir, algo que no espera que cambie. Similar al paso de parámetros por valor, que si cambia es porque és otro puntero.3.2 El clonadoEl potencialmente pesado trabajo de clonado lo podemos evitar en muchos casos usando alguna de estas técnicas:Tipos primitivos que se pasan por valor en las propiedades @Input()Arrays: muchos métodos como .filter() .slice() .sort() .concat() etc, devuelven nuevas referencias sin modificar el array original.Observables y el pipe Async, pues en este caso se subscribe y lanza implícitamente la detección del cambio. Sin necesidad de clonar.Para los demás casos tenemos operadores TypeScript sencillos y optimizados para obtener nuevas referencias a partir de otros ya existentes.1234567const original = &#123; name:'first', value:1 &#125;;const cloned = &#123; ...original &#125;;const mutated = &#123; ...original, value:2, newProperty: 'added' &#125;;const list = [ original, cloned, mutated ];const clonedList = [ ...list ];const mutatedList = [ ...list, &#123; name: 'new item'&#125; ];const newList = list.filter(i =&gt; i.name=='first');Ya tienes los conocimientos para acelerar y reducir la incertidumbre sobre el actualización de vistas usando el patrón contenedor / presentador junto con la estrategia de detección de cambios OnPush.Para un ejemplo más completo de estos conceptos explora los componentes Home de Autobot. En Car tienes un ejemplo de notificación manual usando ChangeDetectorRef.Continúa tu formación avanzada aprendiendo a usar el patrón Redux con NgRX en Angular y verás como aprendes a programar con Angular 7.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular6","slug":"Angular6","permalink":"https://academia-binaria.com/tag/Angular6/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"},{"name":"ChangeDetection","slug":"ChangeDetection","permalink":"https://academia-binaria.com/tag/ChangeDetection/"}]},{"title":"Formularios reactivos con Angular","slug":"formularios-reactivos-con-Angular","date":"2018-09-26T08:59:27.000Z","updated":"2018-12-03T16:35:12.938Z","comments":true,"path":"formularios-reactivos-con-Angular/","link":"","permalink":"https://academia-binaria.com/formularios-reactivos-con-Angular/","excerpt":"El doble enlace automático entre elementos html y propiedades de objetos fue el primer gran éxito de Angular. Ese doble-binding facilita mucho el desarrollo de formularios. Pero esa magia tienen un coste en escalabilidad; impacta en el tiempo de ejecución y además dificulta la validación y el mantenimiento de formularios complejos.La solución en Angular 7 pasa por desacoplar el modelo y la vista, introduciendo una capa que gestione ese doble enlace. Los servicios y directivas del módulo ReactiveFormsModule que viene en la librería @angular/forms permiten programar formularios reactivos conducidos por el código.","text":"El doble enlace automático entre elementos html y propiedades de objetos fue el primer gran éxito de Angular. Ese doble-binding facilita mucho el desarrollo de formularios. Pero esa magia tienen un coste en escalabilidad; impacta en el tiempo de ejecución y además dificulta la validación y el mantenimiento de formularios complejos.La solución en Angular 7 pasa por desacoplar el modelo y la vista, introduciendo una capa que gestione ese doble enlace. Los servicios y directivas del módulo ReactiveFormsModule que viene en la librería @angular/forms permiten programar formularios reactivos conducidos por el código.Partiendo de la aplicación tal cómo quedó en Vigilancia y seguridad en Angular. Al finalizar tendrás una aplicación con formularios model driven fáciles de mantener y validar.Código asociado a este artículo en GitHub: AcademiaBinaria/AutoBot/8-reactive1 DesacopleLa directiva [(ngModel)]=&quot;model.property&quot; con su popular banana in a box establece el doble enlace entre el elemento de la vista al que se le aplica y una propiedad del modelo. Los cambios en la vista son trasladados automáticamente al modelo, y al revés; cualquier cambio en el modelo se refleja inmediatamente en la vista.Se pueden establecer validaciones y configurar los eventos que disparan las actualizaciones; pero todo ello usando más y más atributos y directivas en la plantilla. Son los formularios template driven que degeneran en un html farragoso y difícil de mantener.1.1 Form BuilderEntra en acción el FormBuilder, un servicio del que han de depender los componentes que quieran desacoplar el modelo de la vista. Se usa para construir un formulario creando un FormGroup, (un grupo de controles) que realiza un seguimiento del valor y estado de cambio y validez de los datos.Veamos un ejemplo mínimo de su declaración.123456import &#123; FormBuilder, FormGroup &#125; from '@angular/forms';public form: FormGroup;constructor(private formBuilder: FormBuilder) &#123;&#125;public ngOnInit() &#123; this.form = this.formBuilder.group(&#123;&#125;);&#125;2 Form GroupEl formulario se define como un grupo de controles. Cada control tendrá un nombre y una configuración. Esa definición permite establecer un valor inicial al control y asignarle validaciones.En este paso tenemos a disposición varias sobrecargas para configurar con mayor o menor detalle el objeto de control.2.1 Default dataPara empezar es fácil asignar valores por defecto. Incluso es un buen momento para modificar o transformar datos previos para ajustarlos a cómo los verá el usuario, sin necesidad de cambiar los datos de base.1234567this.name = 'TUTORIAL ANGULAR';this.form = this.formBuilder.group(&#123; email: 'tutorial@angular.io', name: this.name.toLowerCase(), registeredOn : new Date().toISOString().substring(0, 10) password: ''&#125;);2.1 Enlace en la vistaMientras tanto en la vista html… Este trabajo previo y extra que tienes que hacer en el controlador se recompensa con una mayor limpieza en la vista. Lo único necesario será asignar por nombre el elemento html con el control typescript que lo gestionará.Para ello usaremos dos directivas que vienen dentro del módulo reactivo son [formGroup]=&quot;objetoFormulario&quot; para el formulario en su conjunto, y formControlName=&quot;nombreDelControl&quot; para cada control.123456789101112131415161718&lt;form [formGroup]=\"form\"&gt; &lt;label for=\"email\"&gt;E-mail&lt;/label&gt; &lt;input name=\"email\" formControlName=\"email\" type=\"email\" /&gt; &lt;label for=\"name\"&gt;Name&lt;/label&gt; &lt;input name=\"name\" formControlName=\"name\" type=\"text\" /&gt; &lt;label for=\"registeredOn\"&gt;Registered On&lt;/label&gt; &lt;input name=\"registeredOn\" formControlName=\"registeredOn\" type=\"date\" /&gt; &lt;label for=\"password\"&gt;Password&lt;/label&gt; &lt;input name=\"password\" formControlName=\"password\" type=\"password\" /&gt;&lt;/form&gt;2 Validación de formulariosLa validación es una pieza clave de la entrada de datos en cualquier aplicación. Es el primer frente de defensa ante errores de usuarios; involuntarios o deliberados.Dichas validaciones se solían realizar agregando atributos html tales como el conocido required. Pero todo eso ahora se traslada a la configuración de cada control, donde podrás establecer una o varias reglas de validación sin mancharte con html.De nuevo tienes distintas sobrecargas que te permiten resolver limpiamente casos sencillos de una sola validación, o usar baterías de reglas. Las reglas son funciones y el objeto Validators del framework viene con las más comunes listas para usar.123456789101112131415this.form = this.formBuilder.group(&#123; email: [ 'tutorial@angular.io', [ Validators.required, Validators.email ] ], name: [ this.name.toLowerCase(), Validators.required ], registeredOn : new Date().toISOString().substring(0, 10) password: [ '', [ Validators.required, Validators.minLength(4) ] ]&#125;);A estas validaciones integradas se puede añadir otras creadas por el programador. Incluso con ejecución asíncrona para validaciones realizadas en el servidor.Revisa por los validadores de ejemplo en Autobot3 EstadosLos formularios y controles reactivos están gestionados por máquinas de estados que determinan en todo momento la situación de cada control y del formulario en si mismo.3.1 Estados de validaciónAl establecer una o más reglas para uno o más controles activamos el sistema de chequeo y control del estado de cada control y del formulario en su conjunto.La máquina de estados de validación contempla los siguientes estados mutuamente excluyentes:VALID: el control ha pasado todos los chequeosINVALID: el control ha fallado al menos en una regla.PENDING: el control está en medio de un proceso de validaciónDISABLED: el control está desactivado y exento de validaciónCuando un control incumple con alguna regla de validación, estas se reflejan en su propiedad errors que será un objeto con una propiedad por cada regla insatisfecha y un valor o mensaje de ayuda guardado en dicha propiedad.3.2 Estados de modificaciónLos controles, y el formulario, se someten a otra máquina de estados que monitoriza el valor del control y sus cambios.La máquina de estados de cambio contempla entre otros los siguientes:PRINSTINE: el valor del control no ha sido cambiado por el usuarioDIRTY: el usuario ha modificado el valor del control.TOUCHED: el usuario ha tocado el control lanzando un evento blur al salir.UNTOUCHED: el usuario no ha tocado y salido del control lanzando ningún evento blur.Como en el caso de los estados de validación, el formulario también se somete a estos estados en función de cómo estén sus controles.Puedes saber en todo momento los estados de cambio y validación de cada control, mira cómo se obtienen en Autobot4 ValorEste sistema de gestión de los controles del formulario oculta la parte más valiosa (el valor que se pretende almacenar) en la propiedad value del formulario.Contendrá un objeto con las mismas propiedades usadas durante la definición del formulario, cada una con el valor actual del control asociado.Un ejemplo típico suele ser como la siguiente vista y su controlador:123456789&lt;form [formGroup]=\"form\" (submit)=\"onSubmit(form.value)\"&gt; &lt;label for=\"email\"&gt;E-mail&lt;/label&gt; &lt;input name=\"email\" formControlName=\"email\" type=\"email\" /&gt; &lt;button type=\"submit\" [disabled]=\"form.invalid\"&gt;Save&lt;/button&gt;&lt;/form&gt;1234public onSubmit(formValue: any) &#123; console.log(formValue); // &#123; email:'tutorial@angular.io' &#125;&#125;Ya tenemos formularios reactivos conducidos por los datos que te permitirán construir pantallas complejas manteniendo el control en el modelo y dejando la vista despejada. Como resumen podemos decir que vamos a programar más en TypeScript que en Html. La ventaja del desacople es que podremos controlar lo que enviamos y recibimos de la vista. Así se pueden aplicar formatos, validaciones y transformaciones entre lo que presentamos y lo que enviamos hacia los servicios.Para un ejemplo más completo de los formularios reactivos en Angular explora el componente Access de Autobot. En Shared tienes un par de servicios de ayuda para validación de fromularios.Con esto incias tu formación avanzada y dispones de más conocimiento para crear aplicaciones Angular. Repasa la serie de introducción a Angular tutorial de introducción a Angular y avanza dominando la Detección del cambio en Angular verás como aprendes a programar con Angular 7.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Angular6","slug":"Angular6","permalink":"https://academia-binaria.com/tag/Angular6/"},{"name":"reactiveForms","slug":"reactiveForms","permalink":"https://academia-binaria.com/tag/reactiveForms/"},{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/tag/Avanzado/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"}]},{"title":"Vigilancia y seguridad en Angular","slug":"vigilancia-y-seguridad-en-Angular","date":"2018-09-20T09:49:27.000Z","updated":"2018-12-03T16:41:52.266Z","comments":true,"path":"vigilancia-y-seguridad-en-Angular/","link":"","permalink":"https://academia-binaria.com/vigilancia-y-seguridad-en-Angular/","excerpt":"La seguridad de los datos es una responsabilidad compartida entre el servidor y el cliente. En Angular 6 usaremos los interceptores para detectar intrusos y enviar credenciales. Veremos como los guards nos permiten controlar la navegación interna y los resolvers nos aseguran los datos por adelantado.La identificación de usuarios y el control de acceso y navegación es parte del trabajo de un desarrollador front-end. Veremos nuevos usos de los observables y los servicios de la librerías @angular/common/http y @angular\\router con los que tratar comunicaciones seguras y fluidas en Angular.","text":"La seguridad de los datos es una responsabilidad compartida entre el servidor y el cliente. En Angular 6 usaremos los interceptores para detectar intrusos y enviar credenciales. Veremos como los guards nos permiten controlar la navegación interna y los resolvers nos aseguran los datos por adelantado.La identificación de usuarios y el control de acceso y navegación es parte del trabajo de un desarrollador front-end. Veremos nuevos usos de los observables y los servicios de la librerías @angular/common/http y @angular\\router con los que tratar comunicaciones seguras y fluidas en Angular.Partiendo de la aplicación tal cómo quedó en Comunicaciones http en Angular. Al finalizar tendrás una aplicación que identifica usuarios y se responsabiliza de almacenar y comunicar el token de seguridad de un servicio REST y mejora la usabilidad controlando la entrada y la salida en las páginas.Código asociado a este artículo en GitHub: AcademiaBinaria/AutoBot/7-watchTienes una versión desplegada operativa para probar AutoBot1 ResolverCuando una ruta se activa, el router de Angular carga un componente en la vista. Bien, pero normalmente necesitará unos datos iniciales para ser mostrados. Y casi siempre serán datos de obtención asíncrona. Lo cual nos lleva a tener que esperar antes de mostrar, mostrar vacíos, o cargando… En cualquier caso tendremos algún que otro if comprobando si los datos están listos o no.Una posible solución vienen de la mano de los resolvers. Son servicios que implementan la interfaz Resolve&lt;any&gt; y que se ejecutan (resuelven) antes de cargar el componente de la ruta activa. Cuando termina avisa al router y este pone a disposición del componente los datos ya cargados, liberándolo de la lógica de carga, de la espera y de las comprobaciones de nulos e indefinidos.A cambio, la transición hacia la ruta no es tan fluida y agradece una buena animación. Veamos por ejemplo la ruta raíz de Autobot que necesita la lista de coches para empezar. Esta solución involucra tres ficheros.1.1 Interfaz ResolveEn el fichero cars-resolver.service.ts partimos de un servicio inyectable local y le hacemos implementar la interfaz Resolve&lt;Cars[]&gt;:12345@Injectable()export class CarsResolverService implements Resolve&lt;Car[]&gt; &#123; constructor(private cars: CarsService) &#123;&#125; public resolve = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;Car[]&gt; =&gt; this.cars.getCars$();&#125;El método devuelve un observable al que se subscribe el router.1.2 RoutesEn el fichero de configuración de rutas home-routing.module.ts nos encontramos con el uso del CarsResolverService1234567const routes: Routes = [&#123; path: '', component: HomeComponent, resolve: &#123; cars: CarsResolverService &#125;&#125;];Lo que hace el Angular Router es subscribirse al método resolve y almacenar su respuesta en una variable, en este caso llamada cars. Dicha variable será consumida de forma síncrona por el componente.1.3 Snapshot dataEl HomeComponent no interactúa directamente con el resolver y por tanto no reclama el servicio en sus dependencias. Símplemente trabaja con el router.12345public cars: Car[];constructor(private route: ActivatedRoute) &#123;&#125;public ngOnInit() &#123; this.cars = this.route.snapshot.data.cars;&#125;No hay necesidad de subscripción ni de control extra en la vista sobre la propiedad cars. Este patrón es recomendable cuando no queremos mostrar una vista a medio cargar, o cuando la lógica de carga asíncrona complica demasiado el componente.2 InterceptorHasta ahora todas las comunicacione con nuestro servidor han sido anónimas. Los datos eran públicos y no se exigía nada para poder leer o guardar información. Pero no siempre es así y los procesos de envío y recepción de datos del servidor suelen ser nominales y por tanto requieren de una identificación del usuario.La seguridad de las comunicaciones con un servicio REST se resuelve habitualmente mediante una credencial generada por el servidor llamada token. Un usuario registrado en el sistema puede hacer log in enviando una vez su identificador y contraseña. Si todo va bien, a cambio el servidor le enviará un token que deberá usar en las siguientes llamadas. Con esto el servidor será capaz de autentificar las llamadas y responder adecuadamente.La detección de fallos y el envío de credenciales es algo que haremos a casi todas las llamadas http. Parece razonable disponer de un mecanísmo único que se aplique a todas las llamadas sin necesidad de ir una por una. En Angular, eso se consigue con los interceptores.2.1 Interfaz HttpInterceptorEl módulo http de Angular nos ofrece una interfaz para implementar en servicios estándar y convertirlos en interceptores. Es la interfaz HttpInterceptor, que obliga a crear el método intercept que nos deja una firma un pelín compleja, intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler):Observable&lt;HttpEvent&lt;any&gt;&gt; . Vayamos por partes:req: HttpRequest&lt;any&gt; es un puntero a la peticíon en curso y su tipo lo deja bien, es una http request.next: HttpHandler cada petición es manipulada por múltiples manejadores y cada interceptor es encadenado al siguiente manejador mediante este parámetro.: Observable&lt;HttpEvent&lt;any&gt;&gt;el tipo devuelto es llamativo porque además de ser un observable, resulta que usa un doble genérico. La razón es que este observable no se queda simplemente con el evento de respuesta, sino que observa cualquier evento http que le suceda a la petición. Entre ellos estará la recepción de la respuesta. Pero es uno más.123public intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; return next.handle(req)&#125;La respuesta del método se puede simplificar con next.handle(req). Esto sería como tener un interceptor que no hace abosolutamente nada. Habitualmente usaremos los interceptores para mutar la llamada, procesar la respuesta o ambas tareas como en este caso.1234public intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; const authReq = this.getReqWithAuthorization(req); return next.handle(authReq).pipe(tap(null, this.handleError));&#125;La llamada en curso no se puede modificar alegremente. Es inmutable, y por tanto, exige ser clonada si queremos hacer algún cambio. Afortunadamente Angular nos ofrece métodos de clonación y mutado para las operaciones más habituales. Como agregar una cabecera de autorización adjuntando un token a cada llamada.1234private getReqWithAuthorization = (req: HttpRequest&lt;any&gt;) =&gt; req.clone(&#123; setHeaders: &#123; Authorization: `Bearer $&#123;this.token&#125;` &#125; &#125;);Claro que para que esto funcione this.token ha de tener un valor del que por ahora no tenemos ni idea.En Angular promueven el uso de funciones y datos inmutables de ahí que nos obliguen a clonar las cabeceras para modificarlas.La otra gran labor encomendada a los interceptores es procesar las respuestas cuando lleguen desde el API. Para ello no hay más que entubar el operador RxJS adecuado en el stream de la petición. Por ejemplo este es un capturador genérico de errores con una especial atención al 401.1234567891011private handleError = err =&gt; &#123; let userMessage = 'Fatal error'; if (err instanceof HttpErrorResponse) &#123; if (err.status === 401) &#123; userMessage = 'Authorization needed'; &#125; else &#123; userMessage = 'Comunications error'; &#125; &#125; console.log(userMessage);&#125;;A parte de toda la liturgia a la que nos obliga el HttpInterceptor, al final la lógica es sencilla. Se trata de rellenar la cabecera con el token actual. Si es o no válido es algo que decidirá el servidor. Aquí simplemente envías lo que tienes y capturas la respuesta.2.2 Enviar credenciales para obtener un tokenUna correcta separación de responsabilidades no debe exigir nada más al interceptor. Debemos proveerle de un mecanismo mediante el cual pueda notificar fallos de seguridad. Y de otro con el que pueda estar al tanto de cambios en el testigo de identificación del usuario.Esa labor la realizaremos en un servicio de intermediación. Hay muchas soluciones para este problema: un bus de eventos es una de ellas. Y un refinamiento del mismo es el patrón redux. Sin complicarnos demasiado, podemos empezar con una implementación naive como la del servicio core/global-store.service.ts12345678910111213141516export class GlobalStoreService &#123; private state: GlobalState = &#123; token: '', loginNeeded: false &#125;; private token$ = new BehaviorSubject&lt;string&gt;(this.state.token); private loginNeeded$ = new BehaviorSubject&lt;boolean&gt;(this.state.loginNeeded); constructor() &#123;&#125; public selectToken$ = (): Observable&lt;string&gt; =&gt; this.token$.asObservable(); public selectLoginNeeded$ = (): Observable&lt;boolean&gt; =&gt; this.loginNeeded$.asObservable(); public dispatchToken = (token: string) =&gt; &#123; this.state.token = token; this.token$.next(this.state.token); &#125;; public dispatchLoginNeeded = (loginNeeded: boolean) =&gt; &#123; this.state.loginNeeded = loginNeeded; this.loginNeeded$.next(this.state.loginNeeded); &#125;;&#125;Sin entrar en mucho detalle, por ahora ;-), esta clase es un intermediario que permite comunicar objetos despachando operaciones y recibir notificaciones subscribiendonos a temas de interés seleccionados.En el caso de la seguridad, el interceptor notifica los fallos y recibe los cambios en el token. Este es un extracto de la funcionalidad usada en el AuthInterceptorService.123456789private token: string;constructor(private globalStore: GlobalStoreService) &#123; this.globalStore.selectToken$().subscribe((token: string) =&gt; (this.token = token));&#125;private handleError = err =&gt; &#123; if (err instanceof HttpErrorResponse &amp;&amp; err.status === 401) &#123; this.globalStore.dispatchLoginNeeded(true); &#125;&#125;;En algún lugar de la raíz de la aplicación, como por ejemplo el core/navigator.componente.ts, es necesario escuchar ciertos eventos y redirigir al usuario convenientemente.123456789101112export class NavigatorComponent implements OnInit &#123; constructor(private globalStore: GlobalStoreService, private router: Router) &#123;&#125; ngOnInit() &#123; this.globalStore.selectLoginNeeded$().subscribe(loginNeeded =&gt; &#123; if (loginNeeded) &#123; this.router.navigateByUrl('/auth'); &#125; else &#123; this.router.navigateByUrl('/'); &#125; &#125;); &#125;&#125;Por supuesto que necesitaremos un formulario que recoja las credenciales del usuario y la envíe al servidor para validar y en su caso recibir un token. Pero todo eso lo tienes en el repositorio de ejemplo. Aquí simplemente pongo la pieza que cierra el círulo de la seguridad, la recepción del token en auth/access.component.ts que luego será enviado por el interceptor en las cabeceras de cada llamada.1234567export class AccessComponent implements OnInit &#123; constructor(private http: HttpClient, private globalStore: GlobalStoreService) &#123;&#125; public onLogin() &#123; this.http.post(this.url, this.credentials) .subscribe(authResponse =&gt; this.globalStore.dispatchToken(authResponse.token)); &#125;&#125;Si se aceptan las credenciales, el servidor nos devolverá un objeto con el token de la sesión para el usuario. Es habitual que envíe más información como roles, y preferencias del usuario… pero eso ya depende del API. Lo que depende de ti es guardar ese token. El almacenamiento recomendado en los navegadores es el localStorage o el sessionStorage pero en este tutorial introductorio tendrás que conformarte con almacenarlo en la memoria.3 GuardiasCon este nombre y viniendo de tratar el tema de la seguridad, parecería que estos servicios están destinados al control de acceso de las aplicaciones. Pero no tiene por qué ser así. Los guards son servicios que implementan interfaces del RouterModule. Concretamente alguna de estas: canActivate, canLoad, canActivateChild, canDeactivate. Que vengan con el router nos debe hacer pensar más en rutas que en seguridad.Es cierto que las tres primeras pueden colaborar en una mejor experiencia de usuarios no autenticados al impedirles acceder a páginas para las que no tienen permiso. Aunque asumiendo siempre que la última palabra la tiene el API que evalúa la petición del usuario.Pero, además de la seguridad, se usan mucho para comprobar si se han seguido los pasos correctos en un proceso. Por ejemplo, para llegar al paso del pago en una tienda online podría ser imprescindible haber rellenado antes la dirección postal. Este sería una caso de uso para cualquiera de los tres primeros cancerberos.3.1 Interfaz canDeactivateEn el fichero car/travel.guard.ts he implementado un caso poco relacionado con la seguridad; el canDeactivate para impedir o avisar antes de abandonar una página.123456789@Injectable()export class TravelGuard implements CanDeactivate&lt;CarComponent&gt; &#123; canDeactivate( component: CarComponent, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState: RouterStateSnapshot ): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean &#123; return component.canBeDeactivated(); &#125;&#125;Como ves, es mucho más compleja la declaraciíon del método que su implementación. Basta con responder cierto o falso de forma síncrona o asíncrona. Este método será invocado por el Angular Router antes de cambiar la ruta activa, dando así oportunidad al programador para interceptar la acción del usuario. En mi ejemplo, si hay cambios en el viaje debe guardarlos antes de abandonar la página.El resto de la sintáxis involucra al router para enganchar el guard y al componente para suministrar la información relevante. Tenemos sendos extractos del car-routing.module.ts y del car.component.ts.1234567const routes: Routes = [ &#123; path: ':carId', component: CarComponent, canDeactivate: [TravelGuard] &#125;];123456public canBeDeactivated() &#123; if (this.hasTravelData &amp;&amp; this.hasPendingChanges) &#123; return false; &#125; return true;&#125;Terminamos así con una aplicación que es capaz de mostrar, recoger y almacenar información relativa a un usuario de manera segura. También usa los observables y el router eficientemente. Es lo menos que se puede pedir y con ello se completa el tutorial de introducción a Angular.Pero hay temas más avanzados con los que continuar. Sigue esta serie para iniciar el tutorial de Angular avanzado y crear tus formularios reactivos con Angular mientras aprendes a programar con Angular6.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"http","slug":"http","permalink":"https://academia-binaria.com/tag/http/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular6","slug":"Angular6","permalink":"https://academia-binaria.com/tag/Angular6/"},{"name":"Observables","slug":"Observables","permalink":"https://academia-binaria.com/tag/Observables/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"}]},{"title":"Comunicaciones http en Angular","slug":"comunicaciones-http-en-Angular","date":"2018-09-14T09:06:00.000Z","updated":"2018-12-03T16:41:52.263Z","comments":true,"path":"comunicaciones-http-en-Angular/","link":"","permalink":"https://academia-binaria.com/comunicaciones-http-en-Angular/","excerpt":"Las comunicaciones http son una pieza fundamental del desarrollo web, y en Angular siempre han sido fáciles y potentes. ¿Siempre?, bueno cuando apareció Angular 2 echábamos en falta algunas cosillas… y la librería RxJs y sus streams son intimidantes para los novatos.Pero con la versión Angular 6 consumir un servicio REST puede ser cosa de niños si aprendes a jugar con los observables y los servicios de la librería @angular/common/http. Conseguirás realizar comunicaciones http asíncronas en Angular 6.","text":"Las comunicaciones http son una pieza fundamental del desarrollo web, y en Angular siempre han sido fáciles y potentes. ¿Siempre?, bueno cuando apareció Angular 2 echábamos en falta algunas cosillas… y la librería RxJs y sus streams son intimidantes para los novatos.Pero con la versión Angular 6 consumir un servicio REST puede ser cosa de niños si aprendes a jugar con los observables y los servicios de la librería @angular/common/http. Conseguirás realizar comunicaciones http asíncronas en Angular 6.Partiendo de la aplicación tal cómo quedó en Servicios inyectables en Angular. Al finalizar tendrás una aplicación que almacena y recupera los datos consumiendo un servicio REST usando las tecnologías de Angular Http.Código asociado a este artículo en GitHub: AcademiaBinaria/AutoBot/6-httpTienes una versión desplegada operativa para probar AutoBot1. El servicio HttpClientLa librería @angular/common/http trae el módulo HttpClientModule con el servicio inyectable HttpClient que debes declarar como dependencia en tus propios constructores.En tu código tienes que reclamar la dependencia para poder usarla. Atención a la importación pues hay más clases con el nombre HttpClient. Debe quedar algo así:1234import &#123; HttpClient &#125; from '@angular/common/http';export class CarsService &#123; constructor(private http: HttpClient) &#123;&#125;&#125;A partir de este momento sólo queda invocar los métodos REST en la propiedad this.http.1.1 Métodos RESTPara cada verbo http tenemos su método en el servicio HttpClient. Su primer parámetro será la url a la que invocar. Los métodos de envío reciben la carga en el segundo argumento, y la envían automáticamente como objetos JSON.Veamos un ejemplo sencillo para montar un CRUD de cualquier cosa, coches por ejemplo. He usado una notación similar al SQL para ilustrar lo que se espera de los comandos.12345678910111213141516private url = 'https://autobot.com/api/cars/'; public selectCars$(): Observable&lt;Car[]&gt; &#123; return this.http.get&lt;Car[]&gt;(this.url); &#125; public selectCar$(carId: string): Observable&lt;Car&gt; &#123; return this.http.get&lt;Car&gt;(this.url + carId); &#125; public insertCar$(car: Car): Observable&lt;car&gt; &#123; return this.http.post&lt;Car&gt;(this.url, car); &#125;public updateCar$(car: Car): Observable&lt;car&gt; &#123; return this.http.put&lt;Car&gt;(this.url + car._id, car); &#125; public deleteCar$(operation: Operation): Observable&lt;any&gt; &#123; return this.http.delete(this.url + car._id); &#125;Cada método de negocio, configura la llamada de infraestructura; parece poca cosa. Podría ser un buen sitio para validar la información antes de ser enviada, o quizás agrupar varias llamadas de red para una misma operación de negocio. El dolar al final del nombre es un convenio para las funciones que devuelven observables.1.2 SubscribeLos observables http han de consumirse mediante el método subscribe para que realmente se lancen. Dicho método subscribe admite hasta tres callbacks: susbcribe(data, err, end) para que se ejecuten en respuesta a eventos. El consumo de este servicio en su versión más básica sería algo así:1234567891011export class CarsComponent &#123; constructor(private cars: CarsService) &#123;&#125; public ngOnInit()&#123; this.cars.selectCars$() .susbcribe( cars =&gt; console.log('Cars: ' + cars.lenght), err =&gt; console.error('Ops: ' + err.message) ) &#125;&#125;El método de nuestro servicio nos devuelve un observable de los datos de la respuesta http. Es un stream de un sólo suceso pero al que alguien debe subscribirse. En la susbcripción asignamos funciones callback. La primera se ejecutará al recibir los datos. La segunda en caso de que haya un error. El método subscribeY hasta aquí lo básico de comunicaciones http. ¿Fácil verdad?. Pero la vida real raramente es tan sencilla. Si quieres enfrentarte a algo más duro debes prepararte y dominar los observables RxJs.Lo que viene a partir de ahora requerirá tiempo y concentración. Si continúas adelante esto ya no será your grandpa´s http anymore.2 ObservablesLas comunicaciones entre navegadores y servidores son varios órdenes de magnitud más lentas que las operaciones en memoria. Por tanto deben realizarse de manera asíncrona para garantizar una buena experiencia al usuario.Esta experiencia no siempre fue tan buena para el programador. Sobre todo con las primeras comunicaciones AJAX basadas en el paso de funciones callback. La aparición de las promises mejoró la claridad del código, y ahora con los Observables tenemos además una gran potencia para manipular la información asíncrona.El patrón Observable fue implementado por Microsoft en la librería Reactive Extensions más conocida como RxJs. El equipo de Angular decidió utilizarla para el desarrollo de las comunicaciones asíncronas. Esta extensa librería puede resultar intimidante en un primer vistazo. Pero con muy poco conocimiento puedes programar casi todas las funcionalidades que se te ocurran.Lo primero es importar el código, de forma similar a cualquier otra clase o función. Para empezar basta con import { Observable } from &quot;rxjs/Observable&quot;;. Tendremos la clase usada por angular para observar el respuesta http.Pero esta es una clase genérica donde sus instancias admiten la manipulación interna de tipos más o menos concretos. Por eso ves en el ejemplo que algunas funciones retornan el tipo esperado : Observable&lt;Car&gt;, o si no saben que tipo esperar se conforman con : Observable&lt;any&gt;.En cualquier caso, toda operación asíncrona retornará una instancia observable a la cual habrá que subscribirse para recibir los datos o los errores, cuando termine. Por limpieza eso debes hacerlo en los componentes que consuman el servicio, no en el propio servicio.El servicio, definie y manipula la instancia observable de la comunicación http. El componente recibe dicho observable que monitoriza la respuesta, se subscribe a ella y consume sus datos o errores.2.1 PipeEn HomeComponent tenemos un ejemplo sencillo para empezar con el consumo de observables. En una llamada al servicio obtemos como resultado un Observable. Pero mira el código relevante y verás que las cosas cambian. Presta especial atención a los tipos de datos:12345678910111213141516171819202122232425import &#123; Observable &#125; from 'rxjs';import &#123; map &#125; from 'rxjs/operators';export class HomeComponent implements OnInit &#123; public carLinks$: Observable&lt;Link[]&gt;; constructor(private cars: CarsService) &#123;&#125; public ngOnInit() &#123; this.carLinks$ = this.cars.getCars$() .pipe( map( (cars: Car[]): Link[] =&gt; cars.map(this.getLinkFromCar) ) ); &#125; private getLinkFromCar(car: Car): Link &#123; return &#123; caption: car.link.caption, routerLink: '/car/' + car.link.routerLink, value: formatNumber(car.cost, 'en-US') + ' EUR' &#125;; &#125;&#125;2.1.1 El operador mapLos datos devueltos raramente vienen en el formato preciso para usar en la vista. Con frecuencia hay que transformarlos al vuelo en cuanto se reciben. Recordemos que HttpClient no devuelve los datos tal cual sino un stream de estados de dichos datos. La manipulación será sobre el stream no directamente sobre los datos; y, claro, para manipular un torrente hay que encauzarlo en tuberías.Aquí es donde aparece el método .pipe(operator1, operator2...) aplicado a un observable, en lugar de, o antes de, .susbcribe(okCallback, errCallback). Este método entuba una serie de operadores predefinidos que manipulan el chorro de estados observados.El operador más utilizado es map(sourceStream =&gt; targetStream). Este operador recibe una función callBack que será invocada ante cada dato recibido. Esa función tienen que retornar un valor para sustituir al actual y así transformar el contenido del chorro.En este caso partimos de un array de objetos de tipo Car[] y lo transformamos en otro array de tipo Link[]. Para ello, forzando un poco el ejercicio, he usado la función .map(sourceElement =&gt; targetElement) de los arrays Javascript. El conflicto es intencionado por mi parte para mostrar la coincidencia en nombre y propósito. Pero son artificios muy distintos; el operador map ha de importarse de rxjs/operators y aplicarse a un observable dentro de su método .pipe(), recibe y emite observables. Nada que ver con la sencilla función array.map(callback), que recibe y devuelve datos estándar.2.1.2 El pipe asyncSiguiendo con las coincidencias en nombres que suelen causar confusión nos encontramos con el pipe async. En este caso es tecnología puramente Angular. En las vistas usamos | para trasnformar la representación de un dato mediante una función. En este caso, la función recibirá un observable y retornará su contenido… cuando llegue.123&lt;app-menu-list caption=\"Cars in your garage:\" [links]=\"carLinks$ | async\"&gt;&lt;/app-menu-list&gt;Este es el modo recomendado de consumo de observables en la vista. Hacerlo mediante el pipe observable&lt;any&gt; | async aporta múltiples ventajas que se irán viendo en este tutorial. Este pipe de Angular es una función que se subscribe al torrente recibido y devuelve sus estados concretos.Se podría, pero no se recomienda, haber resuelto el tema de la siguiente manera:12345678910111213141516171819202122232425@Component(&#123; selector: 'app-home', template: `&lt;app-menu-list caption=\"Cars in your garage:\" [links]=\"carLinks\"&gt;&lt;/app-menu-list&gt; `&#125;)export class HomeComponent implements OnInit &#123; public carLinks: Link[]; constructor(private cars: CarsService) &#123;&#125; public ngOnInit() &#123; this.carLinks$ = this.cars.getCars$() .pipe(map( (cars: Car[]): Link[] =&gt; cars.map(this.getLinkFromCar) )) .subscribe( (links: Link[]): void =&gt; this.links= links; ); &#125; private getLinkFromCar(car: Car): Link &#123; return &#123; caption: car.link.caption, routerLink: '/car/' + car.link.routerLink, value: formatNumber(car.cost, 'en-US') + ' EUR' &#125;; &#125;&#125;Recordatorio para novatos asíncronos: Es importante comprender la naturaleza asíncrona de estas operaciones. El código de las funciones callbacks subscritas se ejecutará en el futuro, no de una manera secuencial.2.2 Switch MapHemos visto como recuperar información asícrona y recibirla con un observable. Hemos aprendido a transformar los datos recibidos. Pero, ¿qué ocurre si lo que necesito para la transformación es otra llamada asíncrona?.El operador map() trabaja con el contenido de un stream. Pero si queremos derivar el curso hacia otro arroyo necesitamos un operador más poderoso: el switchMap().Esta es una situación habitual cuando llamamos a un servicio y con su resultado futuro tenemos que llamar a otro. En realidad lo que queremos es el resultado del segundo observable, no el del primero. Para ello cambiamos al vuelo uno por otro; de ahí el switch.En el car.component.ts tienes un ejemplo completo y complejo del entubado encadenado de operadores. Se trata de que al aplicación almacene y recupere los datos de viaje de cada coche, de forma que al cogerlo podamos continuar el viaje. Además del mencionado switchMap te presento también al sencillo tap(). Este operador se usa cuando queremos ejecutar instrucciones que no manipulen los datos del stream, pero que se efectúen cuando los datos lleguen. Es decir, tap usa el dato pero no lo transforma.Analicemos el siguiente snipet linea a línea. Prestando una vez más especial atención a los tipos recibidos y devueltos por cada función.1234567891011public ngOnInit() &#123; this.subscription: Subscription = this.route.params .pipe( map((params: Params): string =&gt; params['carId']), switchMap((carId: string): Observable&lt;Car&gt; =&gt; this.cars.getCarByLinkId$(carId)), tap(this.onCarGotten), switchMap((car: Car): Observable&lt;Car&gt; =&gt; this.travels.getCarTravel$(car)), switchMap((car: Car): Observable&lt;number&gt; =&gt; interval(environment.refreshInterval)) ) .subscribe(this.timeGoesBy);&#125;La narrativa de lo que sucede en esta función es la siguiente:1 - Partimos de this.route.params, que es un stream observable de los estados de los parametros de la ruta activa, y que devuelve Observable&lt;Params&gt;.2 - Extraemos el parámetro carId, que es un string.3 - Realizamos una llamada asincrona para obtener el coche con es identificador. El resultado es un nuevo stream que retorna Observable&lt;Car&gt;.4 - Almacenamos el coche e inicializamos indicadores mediante tap. Sin cambiar nada en el curso del arroyo.5 - Para continuar el viaje hay que llamar de nuevo al servidor y de forma asíncrona completar o rellenar datos del coche. De nuevo una derivación en la corriente, auqne el tipo siga siendo el mismo: Observable&lt;Car&gt; .6 - Al tener los datos ya completos queremos ceder el control al usuario y refrescar los indicadores según su manejo. La repetición de funciones a intervalos encaja en la filosofía Observable y se incorpora en RxJs mediante la función interval(period:number) que retorna una secuencia de números a cada intervalo programado.7 - Por último podemos ejecutar una función callback ante cada suceso (emitido por el intervalo) usando la función .subscribe(callback).Reconozco que en un primer vistazo este código pueda resultar complejo. Tómate tu tiempo. Fíjate en los tipos de entrada y salida de cada función. Revísa la aplicación Autobot en el repositorio. Especialmente en cars.service.ts y travels.service.ts encontrarás muchos más ejemplos del trabajo con la librería RxJs y la manipulación de streams de eventos observables.Ya tenemos un servidor con el que nos comunicamos por http; aunque por ahora de forma anónima. Con el conocimiento actual de los observables y el httpClient estamos a un paso de darle seguridad a las comunicaciones. Sigue esta serie para añadirle vigilancia y seguridad en Angular mientras aprendes a programar con Angular6.Aprender, programar, disfrutar, repetir.– Saludos, Alberto Basalo","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/categories/Tutorial/"},{"name":"Angular","slug":"Tutorial/Angular","permalink":"https://academia-binaria.com/categories/Tutorial/Angular/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"http","slug":"http","permalink":"https://academia-binaria.com/tag/http/"},{"name":"Angular","slug":"Angular","permalink":"https://academia-binaria.com/tag/Angular/"},{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/tag/Introduccion/"},{"name":"Angular6","slug":"Angular6","permalink":"https://academia-binaria.com/tag/Angular6/"},{"name":"Observables","slug":"Observables","permalink":"https://academia-binaria.com/tag/Observables/"},{"name":"RxJS","slug":"RxJS","permalink":"https://academia-binaria.com/tag/RxJS/"},{"name":"Angular7","slug":"Angular7","permalink":"https://academia-binaria.com/tag/Angular7/"}]},{"title":"TypeScript, programa en el front igual que en el back","slug":"typescript-programa-en-el-front-igual-que-en-el-back","date":"2017-03-14T18:02:11.000Z","updated":"2017-03-14T18:10:13.000Z","comments":true,"path":"typescript-programa-en-el-front-igual-que-en-el-back/","link":"","permalink":"https://academia-binaria.com/typescript-programa-en-el-front-igual-que-en-el-back/","excerpt":"Hasta hace bien poco había dos mundos en la programación casi enfrentados: el desarrollo back end y el front end. El primero era el de los programadores de verdad, con lenguajes serios y patrones de diseño. El último era el universo de los diseñadores, con lenguajes de segundo nivel y micro scripts o código espagueti descontrolado.","text":"Hasta hace bien poco había dos mundos en la programación casi enfrentados: el desarrollo back end y el front end. El primero era el de los programadores de verdad, con lenguajes serios y patrones de diseño. El último era el universo de los diseñadores, con lenguajes de segundo nivel y micro scripts o código espagueti descontrolado.Pero la llegada de los frameworks MVC en el cliente, llevó grandes cantidades de código al navegador y el desarrollo front end ya nunca sería lo mismo. Primero se portaron los patrones, después las buenas prácticas, más tarde las herramientas y así hasta haber eliminado las fronteras entre back y front.Pero quedaba algo pendiente, el leguaje. En el lado del servidor había multitud de opciones, siendo Java y C# las más aceptadas por la empresa, administración y banca. Pero al otro lado del cable seguía, con algunos retoques, el viejo JavaScript.Y entonces eclosionó TypeScript. Un proyecto maduro creado por el equipo de desarrollo de Microsoft y que lleva a JavaScript al siguiente nivel. Con tipos estáticos (de ahí su nombre) propicia que las herramientas de desarrollo mejoren la productividad y experiencia de los programadores. Y como consecuencia suaviza la rampa de entrada al front para los desarrolladores back.Ya no queda excusas para programar en el cliente igual de bien que en el servidor. Prueba el TypeScript si dominas y te gusta la POO, serás un full stack cuestión de horas.","categories":[{"name":"Opinión","slug":"Opinion","permalink":"https://academia-binaria.com/categories/Opinion/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://academia-binaria.com/tag/TypeScript/"}]},{"title":"Código de ejemplo curso de Angular2","slug":"codigo-de-ejemplo-curso-de-angular2","date":"2016-09-21T06:37:13.000Z","updated":"2016-10-10T06:10:33.000Z","comments":true,"path":"codigo-de-ejemplo-curso-de-angular2/","link":"","permalink":"https://academia-binaria.com/codigo-de-ejemplo-curso-de-angular2/","excerpt":"Enlace a los repositorios con el código de ejemplo para los cursos de Angular2 :","text":"Enlace a los repositorios con el código de ejemplo para los cursos de Angular2 :2.0 cliAcademiaBinaria/angular2Este proyecto es un work in progress.Está basado en el generador Angular-CLI, el más adecuado para aplicaciones realesRC6 SeedAcademiaBinaria/angular2-RC6Aunque es para la RC6 el código es perfectamente compatible con la versión estable.Está basado en el proyecto Angular2-Seed, que es más sencillo que el CLI para empezar.","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"}]},{"title":"Formularios de datos en Angular2","slug":"formularios-de-datos-en-angular2","date":"2016-06-22T14:32:34.000Z","updated":"2016-06-22T16:05:58.000Z","comments":true,"path":"formularios-de-datos-en-angular2/","link":"","permalink":"https://academia-binaria.com/formularios-de-datos-en-angular2/","excerpt":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Formularios, tablas y modelos de datos en AngularLos formularios en AngularJS fueron un éxito inicial debido entre otras coas al double binding. Otra cosa que no fue nunca simple es la validación de controles en los formularios. En Angular 2 y con la última versión RC3 la cosa mejora, pero es aún un Work in progress.","text":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Formularios, tablas y modelos de datos en AngularLos formularios en AngularJS fueron un éxito inicial debido entre otras coas al double binding. Otra cosa que no fue nunca simple es la validación de controles en los formularios. En Angular 2 y con la última versión RC3 la cosa mejora, pero es aún un Work in progress.DependenciasCon el lío de versiones de los últimos días, conviene que os muestre con qué he hecho mi prueba.123456789101112131415\"dependencies\": &#123; \"@angular/common\": \"2.0.0-rc.3\", \"@angular/compiler\": \"2.0.0-rc.3\", \"@angular/core\": \"2.0.0-rc.3\", \"@angular/forms\": \"^0.1.1\", \"@angular/http\": \"2.0.0-rc.3\", \"@angular/platform-browser\": \"2.0.0-rc.3\", \"@angular/platform-browser-dynamic\": \"2.0.0-rc.3\", \"@angular/router\": \"3.0.0-alpha.7\", \"es6-shim\": \"^0.35.0\", \"reflect-metadata\": \"0.1.3\", \"rxjs\": \"5.0.0-beta.6\", \"systemjs\": \"0.19.26\", \"zone.js\": \"^0.6.12\" &#125;Como veis están actualizadas a la RC.3 y forms 0.1.1.Si usas SystemJS, acuérdate de incluir @angular/forms en el fichero system-config.jsonEn el main.ts debemos registrar los providers que permiten la convivencia de la actual versión de forms y la anterior (de la semana pasada) ya obsoleta.12345import &#123; disableDeprecatedForms, provideForms &#125; from '@angular/forms';bootstrap(CashFlowAppComponent,[ disableDeprecatedForms(), provideForms()]);Plantillas html para hacer formulariosVamos a tratar de mantener el html limpio hasta dónde sea posible. En un futuro espero que incluso sea prescindible y que se pueda generar de forma automática a partir de datos de configuración.123456789101112131415161718192021222324&lt;form [formGroup]=\"formularioMovimiento\"&gt; &lt;label&gt;Tipo:&lt;/label&gt; &lt;input type=\"text\" formControlName=\"tipo\"&gt; &lt;p&gt; &lt;span *ngIf=\"formularioMovimiento.controls['tipo'].touched &amp;&amp; !formularioMovimiento.controls['tipo'].valid\"&gt; Necesitamos el tipo de movimiento &lt;/span&gt; &lt;/p&gt; &lt;label&gt;Categoría:&lt;/label&gt; &lt;input type=\"text\" formControlName=\"categoria\"&gt;&lt;p&gt;&lt;/p&gt; &lt;label&gt;Fecha:&lt;/label&gt; &lt;input type=\"date\" formControlName=\"fecha\"&gt;&lt;p&gt;&lt;/p&gt; &lt;label&gt;Importe:&lt;/label&gt; &lt;input type=\"number\" formControlName=\"importe\"&gt; &lt;p&gt; &lt;span *ngIf=\"formularioMovimiento.controls['importe'].touched &amp;&amp; !formularioMovimiento.controls['importe'].valid\"&gt; Necesitamos el tipo de movimiento &lt;/span&gt; &lt;/p&gt; &lt;button type=\"submit\" [disabled]=\"!formularioMovimiento.valid\" (click)=\"guardarMovimiento()\" &gt;Guardar &lt;/button&gt;&lt;/form&gt;Se incluyen la lógica para mostrar mensajes de validación y activación del botón de guardado. He optado por no usar la definción de variables en la plantilla mediante #.Lógica y datos en el componenteTrataremos de llevar la lógica de generación y validación de datos al componente y programarlo en TypeScript. Puede ser por mi pasado backender pero me encuentro más cómodo cuanto más lejos de un lenguaje de marcas.Para empezar necesitamos registrar las herramientas. El proveedor FormBuilder nos ayuda a definir los controles asociados al formulario y sus validaciones.12345import &#123; REACTIVE_FORM_DIRECTIVES, FormBuilder, FormGroup, Validators &#125; from '@angular/forms';@Component(&#123; directives: [REACTIVE_FORM_DIRECTIVES], providers:[FormBuilder]&#125;)En el evento OnInit construimos la estructura de soporte al formulario. Se puede hacer mucho más compleja, mediante la inclusión de grupos de controles anidados.12345678ngOnInit() &#123; this.formularioMovimiento = this.formBuilder.group(&#123; tipo: ['',Validators.required], categoria: [], fecha: [], importe:['',Validators.required] &#125;); &#125;Antes de enviar datos a un serviciop se pueden hacer validaciones y ttransformacipnes previas. El acceso a los valores del formulario se hace través de su propiedad .value. Con esto ya realizaremos los envíos a los servicios…123guardarMovimiento() &#123; this.miServicio.Guardar(this.formularioMovimiento.value);&#125;ValidaciónLa validación temprana es el objetivo fundamental de un desarrollo de formularios. Es buena para el usuario y buena para el sistema. Angular2 facilita la implementación de las validaciones estándar y permite la creación de las tuyas propias.Lo veremos en próximas entregas. Sígueme en mi cuenta de twitter o suscríbete a la revista mensual de Academia Binaria y serás el primero en ser informado.Aprender, programar, disfrutar, repetir.– Saludos, Alberto BasaloACTUALIZACIÓNPara una versión más reciente del contenido visita la página Formularios, tablas y modelos de datos en Angular","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Forms","slug":"Forms","permalink":"https://academia-binaria.com/tag/Forms/"}]},{"title":"Comunicaciones http observables con Angular2","slug":"comunicaciones-http-observables-con-angular2","date":"2016-06-16T09:47:28.000Z","updated":"2017-02-16T16:44:21.000Z","comments":true,"path":"comunicaciones-http-observables-con-angular2/","link":"","permalink":"https://academia-binaria.com/comunicaciones-http-observables-con-angular2/","excerpt":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Comunicaciones HTTP en AngularEn AngularJS, y en otros frameworks del lado cliente, la idea de fue simple desde el principio: dame plantillas estáticas y datos dinámicos. Las comunicaciones http son las arterias vitales de transporte de esos datos dinámicos. Y en Angular 2 se han revisado por completo, llevando las comunicaciones asíncronas al siguiente nivel.","text":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Comunicaciones HTTP en AngularEn AngularJS, y en otros frameworks del lado cliente, la idea de fue simple desde el principio: dame plantillas estáticas y datos dinámicos. Las comunicaciones http son las arterias vitales de transporte de esos datos dinámicos. Y en Angular 2 se han revisado por completo, llevando las comunicaciones asíncronas al siguiente nivel.La librería http y otras…Como cabe esperar Angular 2 dispone de su propio módulo de comunicaciones. En la librería @angular/http encontramos el nuevo servicio http que es el cliente usado para enviar y recibir datos.Lo realmente novedoso viene de parte del proyecto Reactive Extensions o RxJS. En su librería rxjs/Observable exporta la clase Observable. Esta clase implementa el patrón observador aplicado a streams de datos. El equipo de Angular ha decidido adoptarlo para procesar los streams de entrada y salida de datos http.Un servicio típico que necesite comunicaciones con el servidor importará al menos estos objetos.1234// Importar objetos de la librería httpimport &#123; Http, Response, RequestOptions, Headers &#125; from '@angular/http';// Importar la clase Observable desde la librería rxjsimport &#123; Observable &#125; from 'rxjs/Observable';Los servicios importados han de ser registrados como providers para poder ser inyectados como dependencias antes de ser consumidos. Ya que se trata de servicios de amplio uso en cualquier aplicación, se recomienda registrarlos en módulos de alto nivel. De esa forma pueden ser reutilizados como singletons.123456789101112// importar la constante con los proveedores de httpimport &#123; HttpModule, Http &#125; from '@angular/http';@NgModule(&#123; declarations: [ ], imports: [ HttpModule, // El módulo con todo lo necesario ], providers:[ Http, // El servicio proveedor ]&#125;);A partir de ese momento cualquier componente o servicio puede reclamar su inyección en el constructor, y lo podrá usar en sus propios métodos.12345678/*** Constructor que reclama dependencias inyectables* Http se encuentra por haberse registrado en este módulo o en uno superior**/constructor(private http: Http) &#123; // en el constructor no debe contener lógica extra // su función es únicamente recibir las dependencias&#125;Observables en lugar de promesasLa naturaleza asíncrona de las comunicaciones entre maquinas se implementó mediante callbacks en JavaScript. Esta forma de programar degenera en código difícil de mantener. Con el tiempo el patrón promesa se impuso, y en AngularJS 1.x es la manera recomendada de programar.Pero las promesas también tiene sus limitaciones, y ahí aparecen los observables. Este patrón requerirá un artículo para el sólo, pero como adelanto se resume en lo siguiente:Tratar todo tipo de información como un stream observable de entrada y de salida, al cual se le pueden agregar operaciones que procesan los flujos de datos.Esto encaja muy bien con las comunicaciones http asíncronas y es la razón de su adopción en Angular 2. Un método de servicio par leer datos REST se parecerá a este snippet:12345678// las llamadas devuelven observablesleerDatos(): Observable&lt;Response&gt; &#123; // Se declara cómo va a ser la llamada // ocultando los pormenores a los consumidores return this.http .get(`$&#123;this.urlBase&#125;/recurso`); // En este momento aún no se efectuó la llamada&#125;Para enviar información via post o put usaremos una estrategia similar, pero con unos requisitos específicos. En Angular 2 se requiere una configuración previa de las llamadas de escritura. Es engorroso pero fácilmente automatizable. Una típica operación de escritura REST sería algo así:12345678910111213141516escribirDatos(unDato): Observable&lt;Response&gt; &#123; // Los envíos de información deben configurarse a mano // esto es fácilmente generalizable y reutilizable let body = JSON.stringify(unDato); let headers = new Headers(&#123; 'Content-Type': 'application/json' &#125;); let options = new RequestOptions(&#123; headers: headers &#125;); // declarar la llamada y retornar el observable // las variables de configuración y los datos, van como parámetros if (unDato._id) &#123; return this.http .put(`$&#123;this.urlBase&#125;/recurso/$&#123;unDato._id&#125;`, body, options); &#125; else &#123; return this.http .post(`$&#123;this.urlBase&#125;/recurso`, body, options); &#125;&#125;Por supuesto esto es lo que se programa a bajo nivel, en los servicios de comunicaciones. En Angular2 se mantiene la recomendación de bajar a servicios la responsabilidad de las comunicaciones al tiempo que dejamos los componentes lo más ligeros posible.Por encima de los servicios de comunicaciones habrá otros servicios de lógica o directamente componentes. En cualquier caso, los consumidores llamarán a métodos que siempre les devolverán objetos observables. Las clases de alto nivel se suscribirán a esos observables y procesarán la respuesta recibida… cuando esta esté disponible.123456789101112// La carga de datos se hace al iniciarse el componente// este es el lugar donde programar lógica de inicio// nunca en el constructorngOnInit() &#123; // en el momento de la suscripción es cuando se dispara la llamada this.datosService .leerDatos() .subscribe(res =&gt; &#123; this.datos = res.json(); &#125;); // Sería similar en procesos de escritura&#125;La clase http no realiza la llamada hasta que algún consumidor se suscriba a la respuesta. Mientras tanto queda como una definición congelada.El método .subscribe() recibe como argumento un puntero a la respuesta http. Los datos se encuentran en formato JSON y hay que reclamarlos mediante el método .json()Extensiones en lugar de interceptoresUna de las características destacables de los servicios $http de AngularJS 1.x era la posibilidad de usar interceptores. Estos eran funciones que se incrustaban durante el envío o recepción de las comunicaciones.Un uso habitual era emplearlos para agregar cabeceras de seguridad o controlar errores de comunicación de manera centralizada. Ahora la forma recomendable de hacer eso mismo en Angular2 es mejorar el servicio http extendiéndolo. El servicio derivado resultante implementará los interceptores en funciones llamadas durante la comunicación.Esta es una posible implementación con funcionalidad suficiente para facilitar los envíos, detectar errores y enviar cabeceras de seguridad.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@Injectable()/** * Extensión personalizada de la clase HTTP * Permite la configuración de todas las peticiones * Captura los envíos y respuestas * */export class HttpService extends Http &#123; /** Las direcciones base deberían venir de la configuración del environment*/ public apiProxyUrl = 'http://localhost:4030/api/'; private authorization = ''; constructor( backend: XHRBackend, defaultOptions: RequestOptions, private router: Router, private userStore: SessionStoreService ) &#123; super(backend, defaultOptions); this.subscribeToToken(); &#125; /** * Reescribe el método de la clase base, ejecutando acciones para cada petición * La peticiíón en curso puede llegar como una ruta o una clase request * Si viene sólo la cadena, debería traer las opciones aparte * */ request(request: string | Request, options: RequestOptionsArgs = &#123; headers: new Headers() &#125;): Observable&lt;Response&gt; &#123; this.configureRequest(request, options); return this.interceptResponse(request, options); &#125; private subscribeToToken() &#123; // suponemos un servicio que nos avisa de la recepción de tokens this.userStore .getDataObservable() .subscribe((data: Session) =&gt; this.authorization = 'Bearer ' + data.token); &#125; private configureRequest(request: string | Request, options: RequestOptionsArgs) &#123; // Adapta la ruta y asigna cabeceras if (typeof request === 'string') &#123; request = this.getProxyUrl(request); this.setHeaders(options); &#125; else &#123; request['url'] = this.getProxyUrl(request['url']); this.setHeaders(request); &#125; &#125; private interceptResponse(request: string | Request, options: RequestOptionsArgs) : Observable&lt;Response&gt; &#123; const observableRequest = super .request(request, options) .catch(this.onCatch()) .finally(this.onFinally()); return observableRequest; &#125; /** * Transforma la url para llamar a trave´s de un proxy * Útil en caso de problemas con el CORS */ private getProxyUrl(currentUrl) &#123; if (!currentUrl.includes('/assets/')) &#123; return this.apiProxyUrl + currentUrl; &#125; else &#123; return currentUrl; &#125; &#125; /** * Interceptor para componer las cabeceras en cada petición * */ private setHeaders(objectToSetHeadersTo: Request | RequestOptionsArgs) &#123; const headers = objectToSetHeadersTo.headers; headers.set('Content-Type', 'application/json'); headers.set('Authorization', this.authorization); &#125; /** * Interceptor para captura genérica de errores http * */ private onCatch() &#123; return (res: Response) =&gt; &#123; // Security errors if (res.status === 401 || res.status === 403) &#123; // redirigir al usuario para pedir credenciales this.router.navigate(['user/login']); &#125; // To Do: Gestión común de otros errores... return Observable.throw(res); &#125;; &#125; private onFinally() &#123; return () =&gt; console.log('Fin'); &#125;&#125;Podemos usarlo de manera transparente en el resto de la aplicación. Sólo se necesita ajustar el registro de proveedores para dirigir al inyector de dependencias hacia esta nueva clase.123456 providers: [ &#123; provide: Http, // reemplaza el servicio del framework useClass: HttpService // con la clase personalizada que lo extiende &#125;]Este es uno de los usos más potentes de la inversión de control en Angular. Es el programador integrador el que decide el servicio a usar. El programador funcional declara la dependencia en los constructores de sus componentes y servicios, pero no decide la instancia concreta que recibirá.Angular 2 ha trastocado todo lo que hacíamos en las versiones 1.x, pero sólo en la forma. El fondo sigue siendo el mismo: el navegador envía y recibe datos en formato JSON que mezcla con plantillas estáticas para crear HTML en la máquina local y relajar al servidor.Por cierto, por ahora ni rastro del viejo $resource. No tardará en aparecer una versión basada en streams observables. Sígueme en mi cuenta de twitter o suscríbete a la revista mensual de Academia Binaria y en cuanto me entere serás el primero en ser informado.Aprender, programar, disfrutar, repetir.– Saludos, Alberto BasaloACTUALIZACIÓNPara una versión más reciente del contenido visita la página Comunicaciones HTTP en Angular","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"http","slug":"http","permalink":"https://academia-binaria.com/tag/http/"}]},{"title":"Enrutador de componentes con Angular2 el nuevo SPA","slug":"enrutado-con-angular2-el-nuevo-spa","date":"2016-06-02T06:52:04.000Z","updated":"2016-12-07T17:23:02.000Z","comments":true,"path":"enrutado-con-angular2-el-nuevo-spa/","link":"","permalink":"https://academia-binaria.com/enrutado-con-angular2-el-nuevo-spa/","excerpt":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Páginas y rutas Angular SPACódigo asociado en angular2/6-routing/La capacidad de gestionar las rutas en el cliente es una de las grandes ventajas de AngularJS. En la versión 1 nos ofrecían una solución demasiado simple que obligaba a usar librerías de terceros como la famosa ui-router. Hemos esperado años la promesa de un nuevo enrutador compatible con las versiones 1 y 2. El resultado es @angular/router.De todo Angular2, este es el componente que más ha cambiado durante la fase Release Candidate. Actualmente confiamos en que las pequeñas dudas se resuelvan definitivamente y podamos relajarnos creando modernos desarrollos SPA.","text":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Páginas y rutas Angular SPACódigo asociado en angular2/6-routing/La capacidad de gestionar las rutas en el cliente es una de las grandes ventajas de AngularJS. En la versión 1 nos ofrecían una solución demasiado simple que obligaba a usar librerías de terceros como la famosa ui-router. Hemos esperado años la promesa de un nuevo enrutador compatible con las versiones 1 y 2. El resultado es @angular/router.De todo Angular2, este es el componente que más ha cambiado durante la fase Release Candidate. Actualmente confiamos en que las pequeñas dudas se resuelvan definitivamente y podamos relajarnos creando modernos desarrollos SPA.Módulo de enrutado en base a componentesLas aplicaciones Angular2 son árboles de módulos. Al menos el módulo raíz AppModule y cuantos módulos funcionales nos hagan falta. Utilizando angular-cli podemos crear módulos con la capacidad de enrutado generada en… un módulo específico.A ver si desbrozamos algo este bosque de módulos.1ng new mi-aplicacion --routing trueTanto para la raíz como para las ramas funcionales se creará un fichero. En la raíz será llamado app-routing.module.ts con un contenido como este:123456789101112131415161718192021/** Módulos de enrutado de Angular2 */import &#123; RouterModule, Routes &#125; from '@angular/router';import &#123; NgModule &#125; from '@angular/core';// Array con las rutas de este módulo. Ninguna funcional.const routes: Routes = [ &#123; path: '', redirectTo: '' &#125;, &#123; path: 'inicio', redirectTo: '' &#125;, &#123; path: '**', redirectTo: '', pathMatch: 'full' &#125;];@NgModule(&#123; imports: [ RouterModule.forRoot(routes) // configuración para el módulo raíz ], exports: [ RouterModule // se importará desde el módulo padre ]&#125;)export class AppRoutingModule &#123; &#125;Este módulo de un único fichero sirve para definir las rutas de otro módulo padre asociado, app.module.ts, el cual quedará más o menos así:123456789101112131415161718// importación de módulo de enrutado asociadoimport &#123; AppRoutingModule &#125; from './app-routing.module';// importación de otros módulos de funcionalidadimport &#123; HomeModule &#125; from './home/home.module';// decorador que define un módulo@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, FormsModule, HttpModule, HomeModule, // el módulo funcional para la 'página home' AppRoutingModule // el módulo de rutas ya configurado ], providers: [] bootstrap: [ AppComponent ] &#125;)export class AppModule &#123; &#125;Módulos funcionalesEl módulo raíz es fundamental pero nada operativo. Toda el que sea de interés para los usuarios estará en módulos funcionales. En las aplicaciones SPA es una buena práctica crear un módulo por cada ruta principal. Incluida la página home. Por ejemplo usando el siguiente comando:1ng generate module home --routing trueAparece un fichero llamado home-routing-module.ts. Este módulo se debe configurar para que gestione sus propias rutas.123456789101112131415161718192021import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';/** Componente enrutable */import &#123; HomeComponent &#125; from './home.component';/** Rutas asociadas a componentes */const routes: Routes = [ &#123; path: '', component: HomeComponent &#125;,];/** array de componentes enrutables */export const routableComponents = [ HomeComponent];@NgModule(&#123; imports: [ RouterModule.forChild(routes) // Para módulo funcional ], exports: [ RouterModule // listo para importarlo en HomeModule ]&#125;)export class HomeRoutingModule &#123; &#125;Se crean dos arrays relacionados. EL principal, routes, contendrá las rutas pareadas con sus componentes respectivos.Los cuales también se exportan directamente en la variable routableComponents. Esto se hace por comodidad. Para no tener que volver a importarlos en la declaración del módulo padre, que quedará así:1234567891011121314import &#123; NgModule &#125; from '@angular/core';import &#123; CommonModule &#125; from '@angular/common';/** Importación de las rutas y sus componentes */import &#123; HomeRoutingModule, routableComponents &#125; from './home-routing.module';@NgModule(&#123; imports: [ CommonModule, HomeRoutingModule // el módulo que sabe enrutar ], declarations: [ routableComponents // los componentes de enrutado ]&#125;)export class HomeModule &#123; &#125;Carga de componentes según la rutaTodo este trabajo de configuración se materializa en las vistas. Necesitaremos un lugar dónde inyectar el componente de turno asociado a la ruta actual. Presentamos el router-outlet. Y para que la aplicación pueda llevarnos de un lugar a otro usaremos la directiva routerLink.De forma que la plantilla raíz app.component.html quedará normalmente así:12345678&lt;!--menú de navegación, sin href--&gt;&lt;nav&gt; &lt;a [routerLink]=\"['/']\"&gt;Inicio&lt;/a&gt; &lt;a [routerLink]=\"['/login']\"&gt;Log In&lt;/a&gt; &lt;a [routerLink]=\"['/contacto']\"&gt;Contacto&lt;/a&gt;&lt;/nav&gt;&lt;!--Este componente nativo hace que el enrutador cargue una página dinámicamente--&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;Rutas hijas y con parámetrosDe poco vale un enrutador que sólo atienda a los casos sencillos. Las aplicaciones profesionales plantean mayores retos.Rutas hijasUn ejemplo son las rutas anidadas, aquí llamadas rutas hijas. Son aquellas en las que una parte de la visualización es común y otra depende de la ruta concreta.Veamos un ejemplo dónde se pretende dar de alta y mostrar una lista de elementos. La base de cualquier CRUD. Así quedaría el fichero movimientos-routing.module.ts.1234567891011121314151617181920212223242526/** Importación de los componentes enrutables */import &#123; MovimientosComponent &#125; from './movimientos.component';import &#123; ListaComponent &#125; from './lista/lista.component';import &#123; NuevoComponent &#125; from './nuevo/nuevo.component';const routes: Routes = [ &#123; path: 'movimientos', component: MovimientosComponent, children: [ // rutas hijas, se verán dentro del componente padre &#123; path: 'nuevo', // la ruta real es movimientos/nuevo component: NuevoComponent &#125;, &#123; path: 'lista', component: ListaComponent &#125; ] &#125;];export const routableComponents = [ NuevoComponent, ListaComponent, MovimientosComponent]Este mini-módulo es muy denso. Contrasta con la simplicidad del movimientos.module.ts que reduce su responsabilidad. Sólo tiene que importar los módulos adecuados.12345678910111213141516171819import &#123; FormsModule &#125; from '@angular/forms';import &#123; NgModule &#125; from '@angular/core';import &#123; CommonModule &#125; from '@angular/common';/** Módulo de enrutado y componentes */import &#123; MovimientosRoutingModule, routableComponents &#125; from './movimientos-routing.module';@NgModule(&#123; imports: [ CommonModule, FormsModule, MovimientosRoutingModule ], // dependencias de otros módulos, especialmente el de enrutado declarations: [ routableComponents ], // Los componentes vienen del fichero movimientos-routing.module.ts exports: [ ], // no necesita exportar nada&#125;)Vemos que la idea es que los ficheros de definición de módulos funcionales deleguen toda la lógica posible a su propio módulo de enrutado.Mientras tanto en la vista… Habíamos dejado la template del componente raíz con un router-outlet. Será ahí dónde se cargue el MovimientosComponent cuando se active la ruta ‘/movimientos’. Pero, ¿y las rutas hijas?, ¿qué se carga y dónde se carga cuando se activa la ruta ‘/movimientos/nuevo’ o la ruta ‘/movimientos/lista’ ?.Echemos un vistazo a movimientos.component.html para comprobar que dispone de su propio router-outlet.12345&lt;nav&gt; &lt;a routerLink=\"/movimientos/nuevo\" &gt;Nuevo Movimiento&lt;/a&gt; &lt;a routerLink=\"/movimientos/lista\" &gt;Lista de Movimientos&lt;/a&gt;&lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;Será en este elemento donde se inyecten los componentes asociados a las rutas hijas. Este anidamiento permite hacer aplicaciones modulares y acceder a vistas específicas con rutas específicas.Rutas con parámetrosHasta ahora usé rutas fijas para navegar. Lo más normal es que estas plantillas contengan segmentos variables llamados parámetros. Para incorporar parámetros a tu esquema de rutas tienes que actuar en tres fases:1- Definir la parte paramétrica de la plantilla generadora de rutasEl path del objeto ruta se convierte en una plantilla que admite distintos valores. Así queda ahora el módulo enrutador de movimientos:1234567891011121314151617181920const routes: Routes = [ &#123; path: 'movimientos', component: MovimientosComponent, children: [ // rutas hijas, se verán dentro del componente padre &#123; path: 'nuevo', // la ruta real es movimientos/nuevo component: NuevoComponent &#125;, &#123; path: 'lista', component: ListaComponent &#125; ] &#125;, &#123; path: 'movimientos/:id', // parámetro variable id component: EditorComponent &#125;];Los parámetros se prefijan con : y en cada ruta se pueden usar tantos como sea necesario.Obsérvese que en este caso la ruta ‘movimientos/:id’ es hermana, no hija, de la primera. Por tanto se mostrará en el router-outlet del componente raíz. Se ha hecho así para mostrar distintas maneras de trabajar en el ‘router’.2- Montar los enlaces asignando valores a los parámetrosEsto se puede hacer en las plantillas HTML o en por código. Siempre usando el array de routerLink sin necesidad de concatenar cadenas para para montar rutas. Este array en su segunda posición llevará un objeto que represente los valores de los parámetros.En un caso de navegación por código sencillo tendrá esta pinta:12// para ir a la ruta /movimientos/42this.router.navigate(['movimientos', 42])Usando desde la vista en igual de sencillo con la directiva routerLink, como en este ejemplo HTML:1&lt;a [routerLink]=\"['/movimientos', 42 ]\"&gt;42&lt;/a&gt;3- Recuperar los valores de los parámetros a partir de las rutasLa novedad más llamativa es la presencia de OnInit. Es un hook, o evento de la vida de un componente. Este evento se ejecuta al iniciarse el componente pero cuando ya la ruta se ha resuelto completamente.En ese momento puedes usar ActivatedRoute, un servicio que entre otras cosas te dará acceso a un observable que emite los valores actuales de los parámetros.Por ejemplo, esto sería el código del componente editor.component.ts que se activa con rutas como ‘/movimientos/42’12345678910111213141516171819202122232425import &#123; Component, OnInit &#125; from '@angular/core';/** Servicio para acceder a la ruta activa */import &#123; ActivatedRoute &#125; from '@angular/router';import &#123; DatosService &#125; from './../datos.service';@Component(&#123; selector: 'app-editor', templateUrl: './editor.component.html', styleUrls: ['./editor.component.css']&#125;)export class EditorComponent implements OnInit &#123; public movimiento; constructor( private route: ActivatedRoute, private datosService: DatosService) &#123; // constructor vacío. sólo se usa para reclamar dependencias &#125; ngOnInit() &#123; // subscripción al observable params this.route.params .subscribe(params =&gt; &#123; const _id = params['id'].toString(); this.movimiento = this.datosService.getMovimientoBy_Id(_id); &#125;); &#125;&#125;Hay una estrategia opcional que emplea Observables para mantener potenciales cambios de estado en los valores de los parámetros. Si te interesa busca información sobre Router .Carga diferidaEsta es la funcionalidad más esperada y que sigue siendo un work in progress. Cuando las aplicaciones AngularJS crecen en funcionalidad producen un impacto negativo en la primera vista de un usuario. Eso es debido a que Angular necesita disponer de todo tu código para montar el armazón de dependencias. Esto es así aunque el usuario no vaya a navegar mas que por un conjunto reducido de rutas.En aplicaciones de intranet o de uso muy intensivo esto no suele ser un gran problema. Esa espera inicial de unos pocos segundos se recupera durante el uso continuado de la aplicación. Pero ciertos desarrollos realmente grandes o, sobre todo, aplicaciones web públicas para usuarios ocasionales necesitaban un tratamiento especial.La solución es implementar un modelo de lazy loading o carga diferida. En este caso el navegador descarga el HTML y el código de la aplicación según el usuario navegue.En Angular2 se incluye esta funcionalidad, pero a día de hoy aún no está disponible con angular-cli. Se puede tunear WebPack a mano para conseguirlo, pero, si no hay urgencia en salir a producción, no te lo recomiendo. Es preferible esperar un poco y usar el la solución definitiva que implemente la herramienta.En cuanto sea usable actualizaré este artículo y difundiré la buena nueva a los cuatro vientos. Como sabes aún estamos esperando la primera Release Candidate de angular-cli y habrá mejoras importantes.Mantente a la última recibiendo el boletín de noticias de Academia Binaria o siguiéndome en las redes sociales.Aprender, programar, disfrutar, repetir.– Saludos, Alberto BasaloACTUALIZACIÓNPara una versión más reciente del contenido visita la página Páginas y rutas Angular SPA","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"SPA","slug":"SPA","permalink":"https://academia-binaria.com/tag/SPA/"}]},{"title":"Angular2 DI: Inyección de dependencias","slug":"angular2-di-inyeccion-de-dependencias","date":"2016-05-30T09:09:09.000Z","updated":"2016-11-10T13:52:13.000Z","comments":true,"path":"angular2-di-inyeccion-de-dependencias/","link":"","permalink":"https://academia-binaria.com/angular2-di-inyeccion-de-dependencias/","excerpt":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Servicios inyectables en AngularCódigo asociado en angular2/4-injection/AngularJS2 tiene vocación de framework para grandes aplicaciones de negocio. Los grandes desarrollos requieren modularidad en el código. En AngularJS se resuelve mediante la Inyección de Dependencias, siguiendo el conocido patrón Dependency Injection.Los cambios en la versión 2 son sobre todo sintácticos, pero también conceptuales. Se mantiene el mismo objetivo, permitir hacer aplicaciones de negocio con HTML y JavaScript de manera controlable.","text":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Servicios inyectables en AngularCódigo asociado en angular2/4-injection/AngularJS2 tiene vocación de framework para grandes aplicaciones de negocio. Los grandes desarrollos requieren modularidad en el código. En AngularJS se resuelve mediante la Inyección de Dependencias, siguiendo el conocido patrón Dependency Injection.Los cambios en la versión 2 son sobre todo sintácticos, pero también conceptuales. Se mantiene el mismo objetivo, permitir hacer aplicaciones de negocio con HTML y JavaScript de manera controlable.Módulos, componentes y serviciosEn AngularJS 1 teníamos muy presente el concepto de módulo. Rara era la aplicación que no comenzase con el mítico angular.module(&#39;miAplicacion&#39;). Dada la carencia de un sistema modular nativo en JavaScript, AngularJS nos proveía de uno propio.Hoy en día se nos sugiere que usemos las versiones avanzadas de JS, o mejor aún TypeScript. Estos lenguajes nos ofrecen las instrucciones export e import que permiten definir módulos estancos en ficheros independientes. Nunca más el engorroso envolvimiento IIFE (function () { … }()).A partir de ahí es el programador el que selectivamente exporta funcionalidad que importará para ser consumida mas tarde. De este modo, Angular se desentiende de la creación de módulos de código y se centra en la comunicación entre los objetos que componen la aplicación.ComponentesSon los bloques de construcción agrupables en compuestos que forman la interfaz visual de una aplicación. Encapsulan la vista, los datos y la lógica para interactuar con el usuario.Ni la vista ni la lógica deben crecer y realizar tareas que no sean de su exclusiva capa de responsabilidad. Esas tareas debe ser delegadas en otros objetos.Modelo de composición de componentes visuales para crear vistas complejas. La comunicación o Data Flow se realiza de manera declarativa. Enviando datos a las propiedades de los hijos y esperando eventos con respuestas.ServiciosLos servicios serán objetos especializados y reutilizables por otros servicios y componentes. En su definición debes aplicar los mismos principios de arquitectura de software que ya conoces y aplicas en lenguajes clásicos tipo Java o C#.net.La sintaxis de la comunicación involucra varios bloques en ambos lados del canal:la definición del servicio decorado como @Injectable() en el proveedor,la exportación en el proveedor y la importación en el consumidor,el registro en el array providers:[] del componente consumidor (o mejor del módulo) conumidor yel consumo en el constructor del componente o servicio consumidor.1234567891011121314import &#123; Component, OnInit &#125; from '@angular/core';import &#123; MovimientosService, Movimiento &#125; from '../shared/';@Component(&#123; selector: 'movimiento', templateUrl: 'movimiento.component.html', providers: [MovimientosService] &#125;)export class MovimientoComponent &#123; movimiento: Movimiento constructor(public movimientosService: MovimientosService) &#123; &#125; guardarMovimiento() &#123; this.movimientosService.guardarMovimiento(this.movimiento) &#125;&#125;DirectivasLas directivas eran el ADN de AngularJS1. Ahora han mutado en componentes reutilizables como elementos en las vistas de otros componentes de rango superior. Pero la idea es la misma, desglosar las plantillas de HTML en bloques con un propósito único.La sintaxis de las directivas es similar:la definición del servicio decorado como @Injectable() en el componente hijo,la exportación del hijo y la importación en el padre,el registro en el array directives:[] del componente padre (o del módulo padre) yel consumo declarativo en la plantilla de la vista padre.12345678910111213import &#123; Component &#125; from '@angular/core';import &#123; MovimientoComponent &#125; from './movimiento';@Component(&#123; selector: 'injection-app', template: '&lt;h1&gt; &#123;&#123;titulo&#125;&#125; &lt;/h1&gt; &lt;movimiento&gt;&lt;/movimiento&gt;', directives:[MovimientoComponent]&#125;)export class InjectionAppComponent &#123; titulo = 'Inyectores listos!';&#125;RegistroLa inyección de las dependencias funciona de manera jerárquica en AngularJS 2. Cuando un módulo registra una dependencia la pone a disposición de todos sus componentes hijos. Es más, si algún hijo la volviese a registrar se le proveería de otra instancia.Esta copia puede provocar efectos colaterales indeseados. Para compartir datos o ahorrar memoria se recomienda registrar las dependencias lo más arriba posible. Esto siempre sin sacrificar la modularidad o la escalabilidad de aplicaciones que requieran lazy loading.Atención a la copia de routeService que se registra por segunda vez. No importa que ya la haya registrado su padre. Otro registro implica otra instancia.Para ciertos casos, AngularJS 2 permite modelos de inyección más avanzados. Mediante el uso de factorías y el registro de cadenas con los nombres de los servicios facilita la inyección a voluntad o la carga diferida.Algunas de estas posibilidades están siendo retocadas durante la actual Release Candidate, y se esperan cambios de cara a las próxima versión estable.El viejo principio de divide y vencerás se aplica rotundamente en las aplicaciones Angular 2. Si creas módulos reutilizables estarás sentando las bases para crear grandes aplicaciones de negocio con AngularJS.Aprender, programar, disfrutar, repetir.– Saludos, Alberto BasaloACTUALIZACIÓNPara una versión más reciente del contenido visita la página Servicios inyectables en Angular","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"DI","slug":"DI","permalink":"https://academia-binaria.com/tag/DI/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"}]},{"title":"DataBinding el flujo de datos de Angular2","slug":"databinding-el-flujo-de-datos-de-angular2","date":"2016-05-25T15:26:32.000Z","updated":"2016-11-10T13:56:46.000Z","comments":true,"path":"databinding-el-flujo-de-datos-de-angular2/","link":"","permalink":"https://academia-binaria.com/databinding-el-flujo-de-datos-de-angular2/","excerpt":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Flujo de datos entre componentes AngularCódigo asociado en angular2/3-databinding/El doble binding o enlace vista controlador en ambos sentidos es una de las claves del éxito de AngularJS. Usando la célebre directiva ng-model enganchamos una propiedad del modelo con un control de la vista. De manera automágica Angular se suscribe a cambios en el DOM y observa el estado del modelo manteniéndolos en sincronía.Pero esto tiene un coste en rendimiento que Angular2 supera con un patrón distinto para el control del flujo de datos entre la vista y el modelo. Este nuevo paradigma ofrece soluciones para distintos escenarios:","text":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Flujo de datos entre componentes AngularCódigo asociado en angular2/3-databinding/El doble binding o enlace vista controlador en ambos sentidos es una de las claves del éxito de AngularJS. Usando la célebre directiva ng-model enganchamos una propiedad del modelo con un control de la vista. De manera automágica Angular se suscribe a cambios en el DOM y observa el estado del modelo manteniéndolos en sincronía.Pero esto tiene un coste en rendimiento que Angular2 supera con un patrón distinto para el control del flujo de datos entre la vista y el modelo. Este nuevo paradigma ofrece soluciones para distintos escenarios:Sólo lectura: modelo hacia la vista1- InterpolaciónEn este primer caso todo nos resultará muy familiar. En efecto la sintáxis de interpolación es la mismoa que en AngularJS 1.x. eso si, en este caso y por defecto, los datos son de sólo lectura y Angular no se preocupa de actualizar la variable.12&lt;p&gt;Hola &#123;&#123;nombreDelProgramador&#125;&#125; bienvenido a Angular2&lt;/p&gt;&lt;p&gt;Fecha de nacimiento: &#123;&#123;fechaDeNacimiento | date&#125;&#125;&lt;/p&gt;2- Enlace a propiedadesEs la comunicación básica hacia la vista, hacia el usuario. En este caso cualquier atributo de un elemento HTML puede enlazarse al valor de una propiedad encerrándola entre corchetes y asignándole una expresión. [propiedad]=&quot;expresion&quot;1234&lt;p&gt;Hola &lt;input [value]=\"nombreDelProgramador\" readonly &gt;&lt;/input&gt; bienvenido a Angular2&lt;/p&gt;&lt;a [href]=\"url-academia-binaria\"&gt;Academia Binaria&lt;/a&gt;&lt;div [hidden]=\"usuarioAutenticado\"&gt;Identifícate&lt;/div&gt; &lt;div [hidden]=\"!usuarioAutenticado\"&gt;Hola &#123;&#123;nombreUsuario&#125;&#125;&lt;/div&gt;Sólo escritura: de la vista hacia el modelo1- EventosLa comunicación desde la vista hacia el modelo se realiza mediante eventos. Es una buena práctica llamar a funciones del componente de forma declarativa en la vista.La sintaxis requiere que se nombre el evento entre paréntesis y se le asigne una expresión como valor. (evento)=&quot;expresion&quot;12345&lt;input (keyup)=\"onKey($event)\" /&gt;&lt;input #nombre (keyup.enter)=\"propiedad=nombre.value\" (blur)=\"propiedad=nombre.value\"&gt;&lt;button (click)=lanzarCohete()&gt;Lanzar cohete&lt;/button&gt;Lectura y escritura: bidireccional1- Enlace doble.Este es el caso más común en la edición de formularios. Y es el equivalente al viejo y glorioso doble binding. Es la combinación de los dos anteriores y eso se refleja en la sintaxis. Recordad [] para leer propiedades y () para enviar datos en respuesta a eventos: el resultado es la llamada banana in a box [()]. En este caso se completa con la directiva ngModel y la propiedad enlazada. [(ngModel)]=&quot;propiedad&quot;12&lt;input type=\"text\" [(ngModel)]=\"nombreDelProgramador\" &gt;Hola &#123;&#123;nombreDelProgramador&#125;&#125;ResumenEste es un ejemplo recopilatorio de las capacidades de Angular2 en cuanto a la sintaxis declarativa en las plantillas HTML de los componentes. Recordad este mantra que revisaremos durante la composición de componentes en aplicaciones complejas:Los datos fluyen hacia las propiedades de los componentes hijos. Los eventos brotan desde los hijos hacia los padres. Sólo usamos enlace doble en los formularios que así lo requieran.1234567891011121314151617&lt;h1&gt; &lt;!--Interpolación de variables definidas en el modelo del componente--&gt; &#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;form&gt; &lt;label&gt;¿Cómo te llamas?&lt;/label&gt; &lt;!--Enlace doble (lectura y escritura) entre la vista y el modelo--&gt; &lt;input type=\"text\" [(ngModel)]=\"aprendiz\" /&gt; &lt;p&gt;Bienvenido a Angular 2 &#123;&#123; aprendiz &#125;&#125; &lt;/p&gt; &lt;!--Expresiones--&gt; &lt;p&gt;Soy capaz de multiplicar por &#123;&#123;1 * 2&#125;&#125; tus habilidades &lt;/p&gt; &lt;!--Eventos--&gt; &lt;button (click)=\"visible=true\"&gt;Saludar&lt;/button&gt; &lt;!--Propiedades--&gt; &lt;p [hidden]=\"!visible\"&gt;Hola Mundo!!!&lt;/p&gt;&lt;/form&gt;En estos ejemplos se han visto propiedades y eventos estándar. Pero todo lo dicho es aplicable a las propiedades y eventos especialmente creados para tus componentes.El objetivo, conseguido, es aumentar el rendimiento. Y un efecto colateral es la simplificación del API de AngularJS. Desaparecen casi todas las directivas estructurales. Especialmente las famosas ng-click ng-blur y demás directivas asociadas a eventos. Tampoco se necesitan más las directivas de ng-show y ng-hide.Las únicas directivas estructurales que permanecen son *ngIf *ngSwitch y *ngFor. Pero esas merecen tratamiento aparte.Aprender, programar, disfrutar, repetir.– Saludos, Alberto BasaloACTUALIZACIÓNPara una versión más reciente del contenido visita la página Flujo de datos entre componentes Angular","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"Forms","slug":"Forms","permalink":"https://academia-binaria.com/tag/Forms/"}]},{"title":"Componentes, los bloques de construcción de Angular2","slug":"componentes-los-bloques-de-construccion-de-angular-2","date":"2016-05-23T12:07:27.000Z","updated":"2016-11-07T17:39:26.000Z","comments":true,"path":"componentes-los-bloques-de-construccion-de-angular-2/","link":"","permalink":"https://academia-binaria.com/componentes-los-bloques-de-construccion-de-angular-2/","excerpt":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Base para una aplicación AngularCódigo asociado en GitHub: angular2/2-modulos/Los componentes son los bloques de construcción de la web moderna. En Angular 2 sustituyen al viejo par Vista-Controlador, el cual ya era opcional en las últimas versiones 1.x Ahora el componente es el rey.Las aplicaciones en Angular2 se desarrollan como árboles de componentes. Estos árboles pueden llegar a ser muy frondosos y conviene dirigir su crecimiento agrupándolos en módulos para no perderse. Yo procuro estructurarlo en niveles para una mejor comprensión. En cada nivel se crea un módulo y dentro de él se declaran los componentes.1- Nivel Raíz:Toda aplicación parte de un componente raíz. Suele recibir el nombre de la aplicación desarrollada y el sufijo App o simplemente App.2- Nivel Troncal:Generalmente dos o tres componentes troncales para la estructura de las páginas. Es común el patrón Navegador-Contenedor, con algún elemento auxiliar para ayudas, mensajes, menús complejos…3- Nivel de Ramas:En este símil, las ramas equivalen a rutas o vistas de la aplicación. En un SPA cada ruta tiene una vista asociada que se carga dentro del componente troncal contenedor4- Nivel de Hojas:Cada una de las vistas está a su vez formada por múltiples componentes de negocio a modo de hojas.Con la salvedad de que muchos de estos componentes los puedes reutilizar en distintas vistas.","text":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Base para una aplicación AngularCódigo asociado en GitHub: angular2/2-modulos/Los componentes son los bloques de construcción de la web moderna. En Angular 2 sustituyen al viejo par Vista-Controlador, el cual ya era opcional en las últimas versiones 1.x Ahora el componente es el rey.Las aplicaciones en Angular2 se desarrollan como árboles de componentes. Estos árboles pueden llegar a ser muy frondosos y conviene dirigir su crecimiento agrupándolos en módulos para no perderse. Yo procuro estructurarlo en niveles para una mejor comprensión. En cada nivel se crea un módulo y dentro de él se declaran los componentes.1- Nivel Raíz:Toda aplicación parte de un componente raíz. Suele recibir el nombre de la aplicación desarrollada y el sufijo App o simplemente App.2- Nivel Troncal:Generalmente dos o tres componentes troncales para la estructura de las páginas. Es común el patrón Navegador-Contenedor, con algún elemento auxiliar para ayudas, mensajes, menús complejos…3- Nivel de Ramas:En este símil, las ramas equivalen a rutas o vistas de la aplicación. En un SPA cada ruta tiene una vista asociada que se carga dentro del componente troncal contenedor4- Nivel de Hojas:Cada una de las vistas está a su vez formada por múltiples componentes de negocio a modo de hojas.Con la salvedad de que muchos de estos componentes los puedes reutilizar en distintas vistas.MódulosLos árboles de componentes pueden ocultarnos fácilmente el bosque de nuestra aplicación. Los módulos son agrupaciones de componentes. Nos ayudan a mantener un orden y a encapsular funcionalidad para crear aplicaciones desacopladas con bloques re-utilizables.No confundir con los módulos de JavaScript ES6 o de TypeScript. En estos casos se les llama módulos a los ficheros de código que exportan funcionalidad.Podemos imaginar un módulo como una fábrica de funcionalidad.Importa componentes que otros módulos exportan.Declara los componentes que el mismo fabrica.Exporta algunos de estos componentes, para que los consuman otros módulos.Anatomía de un ComponenteEn el artículo de bienvenida a Angular 2 teníamos una aplicación de un sólo módulo con un sólo componente. Y nos sirvió para ver su estructura: plantilla, decorador y clase.La plantilla en HTML y la clase en JS equivalen a las antiguas vistas y controladores. La metadata une ambos mundos y registra el componente para que interacciones con el resto del mundo Angular.La comunicación de datos entre la plantilla y el componente se realiza siguiendo un remozado workflow de propiedades y eventos. El nuevo data-binding de Angular2 merece estudio en detalle pues su sintaxis ha cambiado para poder estar a la altura del rendimiento exigido.Generación de módulos y componentes con angular-cliSobre la base de ese ‘Hola Mundo’ vamos construir una mini aplicación muy sencilla para guardar movimientos económicos. El To Do List de los ingresos y gastos.Empezaré creando otro módulo con su componente para ser integrado en el componente raíz del módulo raíz. Por ahora será un componente de negocio vacío: el componente movimientos. Puedes escribir a mano cada nuevo módulo o componente, pero si usas Angular CLI lo tendrás generado con un sólo comando:1234567891011ng g m movimientos``` Verás que se ha creado una carpeta llamada `movimientos` con una estructura que pronto te será muy familiar. Para empezar un archivo para el nuevo módulo, el `movimientos-module.ts`. Después una serie de ficheros para crear su componente principal. Un fichero `movimientos-component.ts` para la clase controladora y el decorador con la *metadata*, y otro fichero `movimientos-component.html` para la plantilla.Reproduzco ahora su contenido básico. Primero la plantilla HTML```html&lt;p&gt; movimientos works!&lt;/p&gt;Y ahora la definición del componente en TypeScript. El cual no sabe en qué módulo acabará.123456789101112import &#123; Component, OnInit &#125; from '@angular/core';// decoración con metadata para el componente@Component(&#123; selector: 'app-movimientos', // ojo al prefijo, por defecto app templateUrl: './movimientos.component.html', // podrían ser inline styleUrls: ['./movimientos.component.css'] // podrían ser inline&#125;)export class MovimientosComponent implements OnInit &#123; constructor() &#123; &#125; ngOnInit() &#123; &#125;&#125;Para que este componente sea conocido ha de estar al menos declarado y exportado en algún módulo. En este caso aparece en el fichero movimientos-module.ts1234567891011121314151617import &#123; NgModule &#125; from '@angular/core';import &#123; CommonModule &#125; from '@angular/common';/** Importa un componente que declara y que luego exporta */import &#123; MovimientosComponent &#125; from './movimientos.component';@NgModule(&#123; imports: [ CommonModule ],// dependencias de otros módulos declarations: [ MovimientosComponent ],// Componente que el módulo mismo declara exports: [ MovimientosComponent ] // exporta los componentes importables desde otros módulos&#125;)export class MovimientosModule &#123; &#125;Consumo desde un componente padreEl componente movimientos está creado pero nadie lo usa. Para darle utilidad hay que consumirlo. Vamos tocar los ficheros ‘app.module.ts’ y ‘app.component.html’ Son siempre estos tres sencillos pasos:1- Importar el módulo que lo exporta12// 1 importación del código del módulo funcionalimport &#123; MovimientosModule &#125; from './movimientos/movimientos.module';2- Registro en el array de importaciones del módulo raíz123...imports:[..., MovimientosModule] // 2 registro del modulo importado con todo lo que exporta...3- Uso del componente como un elemento html en la plantilla del padre1234567&lt;h1&gt; &lt;!--enlace con propiedades del componente--&gt; &#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;!-- 3 los componentes personalizados se usan como elementos estándar en html--&gt;&lt;!--componente movimientos--&gt;&lt;app-movimientos&gt;&lt;/app-movimientos&gt;Esta manera de encapsular componentes unos dentro de otros permite crear grandes aplicaciones de tamaño empresarial sin sacrificar la limpieza del código. Cada componente debe diseñarse de forma que resuelva un problema de negocio concreto, por tanto manejable. Y si puede ser reutilizable mucho mejor.La agrupación de componentes en módulos ayuda a mantener la aplicación organizada.Aprender, programar, disfrutar, repetir.– Saludos, Alberto BasaloACTUALIZACIÓNPara una versión más reciente del contenido visita la página Base para una aplicación Angular","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"CLI","slug":"CLI","permalink":"https://academia-binaria.com/tag/CLI/"}]},{"title":"Hola Mundo Angular 2","slug":"hola-mundo-en-angular-2","date":"2016-05-18T14:10:18.000Z","updated":"2016-10-31T11:36:28.000Z","comments":true,"path":"hola-mundo-en-angular-2/","link":"","permalink":"https://academia-binaria.com/hola-mundo-en-angular-2/","excerpt":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Hola Angular CLICódigo asociado en GitHub: angular2/1-HolaMundo/Qué lejanos aquellos tiempos dónde un Hola Mundo en AngularJS se hacía en 2 líneas de código. Ahora necesitaré miles de ficheros y media hora de explicación. Pero el resultado valdrá la pena. Estaremos en la pista de lanzamiento para crear aplicaciones de nivel empresarial con Angular 2.Ya he explicado que Angular ha pasado de framework a plataforma, y que ya no es para aficionados. Grandes desarrollos en equipo requieren herramientas y procedimientos a la altura. La primera opción que te recomiendo es Angular CLI, un generador de aplicaciones trufado de buenas prácticas y procedimientos. Por raro que te parezca, cualquier otra opción es aún más compleja que la que te muestro.","text":"ACTUALIZACIÓN: para una versión más reciente del contenido visita la página Hola Angular CLICódigo asociado en GitHub: angular2/1-HolaMundo/Qué lejanos aquellos tiempos dónde un Hola Mundo en AngularJS se hacía en 2 líneas de código. Ahora necesitaré miles de ficheros y media hora de explicación. Pero el resultado valdrá la pena. Estaremos en la pista de lanzamiento para crear aplicaciones de nivel empresarial con Angular 2.Ya he explicado que Angular ha pasado de framework a plataforma, y que ya no es para aficionados. Grandes desarrollos en equipo requieren herramientas y procedimientos a la altura. La primera opción que te recomiendo es Angular CLI, un generador de aplicaciones trufado de buenas prácticas y procedimientos. Por raro que te parezca, cualquier otra opción es aún más compleja que la que te muestro.Preparando el entornoLas herramientas que voy a usar requieren NodeJS. Te recomiendo que instales una de sus últimas versiones. Tras la instalación tendrás acceso a npm para poder instalar librerías y utilidades como Angular CLI.1npm install -g angular-cliA partir de ahora en tu linea de comandos podrás usar el programa ng seguido de algún comando como new generate serve lint test e2e build. Usaremos algunos en esta demo.Creando aplicaciones y componentesEscoge un directorio en un disco con espacio libre. No es broma, hasta 300 mb o más para empezar. Tranquilo, en distribución la cosa pinta mucho mejor y Angular es muy ligero. Ahora teclea:1ng new hola-angular-2Unos segundos o minutos más tarde… podrás abrir la recién creada carpeta, yo lo hago con VSCode, y explorar el contenido de sus 3 directorios y miles de ficheros!!!Después del susto, tranquilidad de nuevo. La mayoría son dependencias de terceros productos, herramientas necesarias para ejecutar aplicación o para alguno de sus procesos de test, lint o distribución. Centrémonos en el directorio src dónde están los fuentes, el código que tendríamos que haber creado nosotros.De un primer vistazo puede que sólo reconozcas al viejo index.html. No te agobies, por ahora es suficiente. Contendrá algo como esto:1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HolaAngular2&lt;/title&gt; &lt;base href=\"/\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!--Componente raíz de la aplicación--&gt; &lt;app-root&gt;Loading...&lt;/app-root&gt;&lt;/body&gt;&lt;/html&gt;De lo que es Angular 2 lo único interesante es el componente &lt;app-root&gt;Loading...&lt;/app-root&gt;. Todo, incluida la aplicación principal, debe ser definido y declarado como un componente. De hecho definiremos las aplicaciones Angular2 como árboles de componentes. Y tdodo árbol debe tener una raíz. Mientras Angular no entre en fucionamiento, el susario verá el mensaje de Loading… después la magia de Angular2 lo sustituirá por el contenido del componente app-root predefinido por el generador.TypeScriptSin entrar en debates de qué lenguaje usar para programar en Angular2 te resumo mi posición:1.- TypeScript te permite anotar tu JavaScript con tipos. Esto tiene dos ventajas: intellisense mientras codificas y chequeo de tipos cuando compilas.2.- TypeScript es la única opción automatizada a día de hoy con Angular CLI.Por lo demás no hay porqué alarmarse. TypeScript es un superset de JavaScript ES6 con unas mejoras evidentes que no tardarás en dominar. Eso si, tienes que aprender JavaScript ES2015 o ES6.Sabiendo esto, entra sin miedo en cualquier fichero de extensión .ts y verás que es muy parecido a cualquier .js de la nueva versión. Por ejemplo en el citado main.ts aparecerá algo así:1234567891011121314151617// importaciones de dependencias TypeScript al estilo ES6// primero los básicos para compatibilidad con navegadoresimport './polyfills.ts';// luego cosas de Angularimport &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; enableProdMode &#125; from '@angular/core';// después nuestro código, empezando por la configuraciónimport &#123; environment &#125; from './environments/environment';// y por último la aplicación a leída desde el módulo raíz, llamado app por convenio.import &#123; AppModule &#125; from './app/';// condiciones para ejecutar en modo desarrollo o producciónif (environment.production) &#123; enableProdMode();&#125;// arranque de la aplicación invocando al módulo raízplatformBrowserDynamic().bootstrapModule(AppModule);Centrándonos en el código que habremos de mantener fíjate en la línea import { AppModule } from &#39;./app/&#39;;. Le indica a WebPack que importe el contenido de la carpeta ./app/. Para ello buscará en dicho directorio un archivo index.ts. Ese fichero sirve de índice y contiene las instrucciones para exportar el código interesante del resto de la carpeta. En nuestro caso son el módulo y el componente raíz.El módulo raízLas aplicaciones Angular2 están pensadas para crecer. Para ello es fundamental cierto grado de modularidad. EL viejo angular.module ha vuelto en la versión 2. Mira dentro del fichero app.module.ts y verás código similar a este:1234567891011121314151617181920212223// objetos con utilidades comunes del frameworkimport &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; FormsModule &#125; from '@angular/forms';import &#123; HttpModule &#125; from '@angular/http';// importación del componente raíz, definido en esta misma carpetaimport &#123; AppComponent &#125; from './app.component';// decorador con metadata que define un módulo@NgModule(&#123; declarations: [ AppComponent ], // cosas declaradas en este módulo imports: [ BrowserModule, FormsModule, HttpModule ], // otros módulos que necesitamos para que este funcione providers: [] , // inyección de servicios comunes para la aplicación bootstrap: [AppComponent] // componente raíz para el arranque&#125;)// los módulos son clases contendoras // habitualmente con poco o ningún códigoexport class AppModule &#123; &#125;Un módulo no es más que una clase contenedora. Cada módulo puede incluir múltiples componentes y servicios. Normalmente un módulo dependerá de otros. El módulo raíz declara un componente especial para el arranque de la aplicación: El componente raízEl componente raízBuceando a mayor profundidad nos encontramos con el resto del contenido de la carpeta ./app/. Son archivos con nombres tipo app.component.* y se usan para definir un componente.Los componentes son los bloques de construcción de Angular 2 que representan regiones de la pantalla. Las aplicaciones se definen como árboles de componentes. Nuestra aplicación es un árbol que tiene una raíz, habitualmente llamado app y que es común a cualquier desarrollo.Cada componente a su vez está formado por tres partes:La vista: es el código que se renderizará para los usuarios. Esta plantilla estará en un fichero de extensión .html.La clase controladora: En ES6 usaremos clases para declarar los controladores que exponen datos y funcionalidad a la vista.Metadata: Se declara como un decorador, una función especial de TypeScript, que recibe un objeto de configuración. Esto acompaña al controlador en un fichero de extensión .tsEmpecemos por este último fichero, el app.component.ts.12345678910111213141516import &#123; Component &#125; from '@angular/core';// Función decoradora que registra un componente@Component(&#123; selector: 'app-root', // elemento html consumidor templateUrl: './app.component.html', // ruta relativa a la vista styleUrls: ['./app.component.css'] // potencialmente múltiples hojas de estilo&#125;)// clase que representa un controlador // con su modelo de datos (title ) y métodos de acción (aún no tiene)// Esta clase es todo lo que se exporta en este fichero// y esto se importará en app.module.ts para ser incorporado el módulo raízexport class AppComponent &#123; // las propiedades de la clase representan el modelo de datos // son accesibles desde la vista title = 'app works!';&#125;Seguro que la parte más novedosa es @Component({...}). Es el equivalente a los antiguos Objetos de Definición de Directivas. Lo que hace es asociar al controlador una plantilla HTML app.component.html y un selector para ser invocado desde otra vista &lt;app-root&gt;&lt;/app-root&gt;. El resto por ahora puedes obviarlo.Y hablando de la plantilla, echemos un vistazo a app.component.html. Contendrá algo así:1234&lt;h1&gt; &lt;!--Interpolación de variables definidas en el modelo del componente--&gt; &#123;&#123; title &#125;&#125;&lt;/h1&gt;Estas son cosas que te resultarán muy familiares como la interpolación Hola Mundo Angular 2 que permite mostrar el famoso app works!, nueva versión del hola mundo. Ya está, el resto ya es sólo usar este componente en el index.html,Recuerda:12&lt;!--Componente raíz de la aplicación--&gt;&lt;app-root&gt;Loading...&lt;/app-root&gt;Angular2 en acciónPara lanzar y probar tu aplicación necesitas otro comando de Angular-CLI. Este comando se ocupa entre otras cosas de todo el proceso necesario para transformar el código TypeScript en JavaScript reconocible por el navegador. También crea un mini servidor estático y además refresca el navegador a cada cambio los fuentes. Un salvavidas para un recién llegado a Angular 2. Teclea en tu terminal:1ng serveSi todo ha ido bien, no siempre ocurre con estas versiones tan verdes, podrás disfrutar de tu primera aplicación con Angular 2 en http://localhost:4200Este vídeo emitido con la colaboración de DesarrolloWeb.com contiene una explicación mas extensa del proceso de trabajo con Angular 2 CLI.Aprender, programar, disfrutar, repetir.– Saludos, Alberto BasaloACTUALIZACIÓNPara una versión más reciente del contenido visita la página Páginas y rutas Angular SPA","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://academia-binaria.com/tag/Tutorial/"},{"name":"CLI","slug":"CLI","permalink":"https://academia-binaria.com/tag/CLI/"}]},{"title":"Angular2, la evolución de la plataforma","slug":"angular2-primeras-impresiones","date":"2016-05-06T13:57:50.000Z","updated":"2016-06-08T06:10:11.000Z","comments":true,"path":"angular2-primeras-impresiones/","link":"","permalink":"https://academia-binaria.com/angular2-primeras-impresiones/","excerpt":"Coincidiendo con la ngConf 2016 acaba de presentarse la esperada Release Candidate de Angular 2. Nunca antes una versión de una herramienta para desarrolladores había causado tal expectación. Hace ya 18 meses que se había anunciado como una evolución rupturista con respecto a AngularJS 1. Y ahora esa ruptura se ha materializado.Los programadores somos muy conscientes de que lo único estable es el cambio. Asumimos, por experiencia, que los cambios en una tecnología son evoluciones graduales constantes. Pero esto no es así en Angular2, y lo sabemos desde su anuncio hace año y medio. Desde ese momento todos fuimos advertidos de que estábamos ante otra cosa. Algo nuevo que sólo comparte paternidad y nombre con la anterior versión.","text":"Coincidiendo con la ngConf 2016 acaba de presentarse la esperada Release Candidate de Angular 2. Nunca antes una versión de una herramienta para desarrolladores había causado tal expectación. Hace ya 18 meses que se había anunciado como una evolución rupturista con respecto a AngularJS 1. Y ahora esa ruptura se ha materializado.Los programadores somos muy conscientes de que lo único estable es el cambio. Asumimos, por experiencia, que los cambios en una tecnología son evoluciones graduales constantes. Pero esto no es así en Angular2, y lo sabemos desde su anuncio hace año y medio. Desde ese momento todos fuimos advertidos de que estábamos ante otra cosa. Algo nuevo que sólo comparte paternidad y nombre con la anterior versión.Un poco de historiaEn septiembre de 2011 me tropecé con AngularJS buscando una alternativa a Backbone y KnockOut. Yo venía del mundo encorsetado del desarrollo para multinacionales basado en tecnologías serias como .Net y Java. Necesitaba un cambio, una apertura… pero con ciertas garantías.En esos tiempos el desarrollo web vivía su eclosión de la mano del HTML5. Era un mundo de startups (ahí estaba yo), de earlyadopters y de picaflores tecnológicos. Buscábamos tecnologías simples, universales y de bajo coste. Muy en la línea con el método empresarial lean. Pero el riesgo de escoger el framework perdedor era enorme, y cada pocos meses aparecían o desaparecían candidatos.Angular superó a sus contendientes por dos razones: una fue (rellena aquí con el argumentario técnico que más te satisfaga) y la otra fue Google. Un padrino así abre muchas puertas y da el punto de valor suficiente para alejarte de Oracle o Microsoft sin temor.En enero de 2013 abandoné mi sueño de convertirme en el nuevo Zuckerberg. Volví al viejo sector servicios fundando una empresa de consultoría. Aprovechando los conocimientos y métodos ágiles aprendidos por el camino startup, ofrecimos desarrollos low cost para pequeñas empresas. Para complementar los servicios empecé a impartir cursos sobre estas tecnologías a otros desarrolladores. Al principio sólo acudían freelances y pequeñas consultoras.En marzo de 2015 tuve los primeros contactos con grandes empresas tanto a nivel docente como consultor. Volví a un mundo familiar pero con una tecnología distinta. AngularJS había crecido de manera exponencial en número de desarrolladores. Pero ahora estaba jugando en las grandes ligas.Y de repente aparecieron los problemas.Dos problemasEl lenguajeJavaScript es dinámico, asíncrono y nada modular. Ideal para espíritus libres, pero una amenaza para equipos estrictos. Y necesitas control si vas a migrar grandes aplicaciones de negocio, ERPs , banca, servicios de administración pública.Tampoco se emocionaban los arquitectos de software con las herramientas. Como siempre todo empezó de manera sencilla: ficheros y editores de texto. Luego llegó la minificación, la combinación, el pre y pos procesado, las anotaciones, la documentación, las pruebas… Cada mes era mayor el arsenal de micro herramientas que había que orquestar.La escalabilidadLas aplicaciones empresariales son pesadas en lógica y datos. La falta de un cargador dinámico decente hacía muy difícil reducir el tiempo antes del primer impacto. Una vez lanzadas las aplicaciones iban razonablemente bien.Hasta que alguien creaba informes editables. Con miles de datos de los que preocuparse la técnica del doble binding saturaba los watchers.AngularJS moría de éxito.Dos solucionesEl lenguaje: TypeScriptLa lenta evolución de JavaScript parece haber salido de su hibernación. En el último año disfrutamos ya de las mejoras de ES6 (ES2015) y empezamos a probar ES7 (2016). Pero no es suficiente.Para grandes desarrollos, con miles de líneas de código, toda ayuda es poca. TypeScript asume todas las mejoras y propuestas del más avanzado JS estándar y además aporta tipos. Esa es la principal razón de su elección como lenguaje de cabecera en AngularJS2.Al rededor de esa piedra angular crece el ecosistema de herramientas. Principalmente VSCode que lo aprovecha ofreciendo intellisense y refactoring a la altura de los grandes.La oferta se completa con Interfaces, Generics y otras novedades que harán las delicias de los programadores orientados a objetos.Cabe señalar que TypeScript no es ni mucho menos obligatorio. Se puede desarrollar en ES5 y ES6 sin problemas. Pero la idea, los ejemplos, la documentación y los blogueros haremos que tu vida sea más fácil si escoges TypeScript.La plataforma: renderización, observables, componentes, carga dinámica, SEO, apps, herramientas…El doble binding era el plato estrella de AngularJS, pero salía caro. Así que se replanteó una solución que no requiriese un pull constante preguntando el estado de un montón de variables. Las respuesta vino de la mano de otra colaboración con los de Redmond: ReactiveX. Este cambio será el primero al que te enfrentes si vienes de las conocidas versiones 1.El mismo patrón observable se aplicó también a las comunicaciones HTTP. Nuestra aplicación es ahora un conjunto de streams que emiten eventos. Solo tenemos que suscribirnos y observar el estado cambiante de nuestro modelo. Resultado, aplicaciones hasta cinco veces más rápidas.Los principios de encapsulación, modularidad y reutilización ya estaban en el ADN de AngularJS. Pero no era fácil implementarlos con las viejas directivas. Desde la versión 1.5 disponemos de componentes. Esta versión puente trae una simplificación y una guía sobre como estructurar aplicaciones. En AngularJS 2 van más allá, y tal como habían amenazado, matan al controlador y coronan al componente como nuevo rey del front end.La inyección de dependencias fue uno de los grandes aciertos iniciales de AngularJS 1. Pero con el tiempo se convirtió en una rémora para crear grandes SPAs, pues requería disponer de toda la lógica, todo tu código, desde el primer segundo. Este problema se ha resuelto, aunque de forma demasiado tediosa. Hay margen de mejora en la actual implementación y espero que se vaya simplificando.Uno de los pocos puntos débiles de AngularJS, y otros frameworks client side, era la dificultad para la indexación SEO on site. La solución normalmente pasaba por algún tipo de prerenderizado más o menos engorroso. Con la aparición de Angular Universal, podemos ejecutar Angular en el servidor. Esto abre las puertas al SEO y a la reducción de la espera en la primera visita.Las aplicaciones híbridas han sido la solución low cost para que cualquier empresa accediese a los elitistas mercados de aplicaciones para móviles. Pero la solución no era perfecta. Con el Angular Mobile Tookit se ofrecen aplicaciones progresivas que compiten en rendimiento y funcionalidad con las nativas.Poner en marcha y depurar una aplicación moderna de gran tamaño requiere herramientas a la altura. La oferta en este caso es total:Angular CLI una herramienta en línea de comandos para generar aplicaciones preconfiguradasAugury para depurar y visualizar en el navegador el estado del programaProtractor para los tests e2eGuías de estilo y analizadores de código…Una alternativaReact, la propuesta de Facebook para el desarrollo web, es una herramienta formidable. Rápido en ejecución, más cercano al estándar JS y mucho menos exigente en cuanto a herramientas.Parte con la enorme desventaja numérica que supone el más de un millón de programadores que ya conocen AngularJS y el ecosistema de librerías, componentes y material docente que ha surgido a su alrededor.Será por esto último que aún no ha enganchado en la gran empresa. Por tanto aún no tira de ofertas de trabajo ni genera el ruido de la apuesta de Google. Eso sí, merece mucho la pena conocerlo, e incluso incorporarlo en algún caso junto a Angular 2.Angular 2 no es plataforma para aficionadosEl resumen es que AngularJS 1.x ha mutado de framework a plataforma en Angular 2. En este sentido estará cada vez más orientada a grandes desarrollos empresariales, y a salir definitivamente del navegador y ocupar servidores, escritorios y teléfonos.Seguro que requiere un gran esfuerzo de aprendizaje por su novedades radicales. Seguro que por el camino habrá giros por su bisoñez y amplitud. Pero seguro que estamos ante la plataforma de desarrollo empresarial con mejor futuro. De momento.En esta presentación tienes un resumen rápido de mis impresiones acerca de Angular2, y de cómo empezar a programar aplicaciones universales.","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"https://academia-binaria.com/tag/Angular2/"}]},{"title":"Node 6.0.0 actualización con nvm","slug":"node-6-0-0-actualizacion-con-nvm","date":"2016-05-05T07:39:40.000Z","updated":"2016-05-05T08:02:26.000Z","comments":true,"path":"node-6-0-0-actualizacion-con-nvm/","link":"","permalink":"https://academia-binaria.com/node-6-0-0-actualizacion-con-nvm/","excerpt":"","text":"Acabamos de recibir la buena noticia de la versión 6 de NodeJS. En este caso con mejoras de rendimiento e incorporación de sintaxis de ES6. ¿Cómo obtener esta nueva versión?. Y sobretodo, ¿cómo manejar la convivencia de distintas versiones? La ayuda se llama nvmEstos son los pasos que has de seguir para instalar la herramienta.Se recomienda desinstalar las versiones de node y npm instaladas previamente. No es obligatorio.LINUX &amp; OS X1- Comprobamos que tenemos instaladas las dependencias1.1 - Dependencias Linux12sudo apt-get updatesudo apt-get install build-essential1.2 -Dependencias OSX (herramientas de linea de comandos para XCode)1xcode-select --install2- Descargamos y ejecutamos el script de instalación1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash3- Comprobamos que está instalado NVM1command -v nvmdebe devolver nvm4- Instalamos la versión de Node que deseamos1nvm install 6.0.05- Elegimos la versión de Node instalada que deseamos usar1nvm use 6.0.0WINDOWSPara Windows no existe una versión nativa de nvm, pero si hay dos opciones para gestionar las versiones de node instaladas.1- nvm-windowshttps://github.com/coreybutler/nvm-windowsEs un wrapper de npm para windows, el instalador se encuentra en la URL (https://github.com/coreybutler/nvm/releases).Los comandos para instalar y la versión de Node son los mismos que en Linux y OSX.2- nodistEs un gestor de versiones parecido a NVM solo para WindowsLa URL del instalador (https://github.com/marcelklehr/nodist/releases/download/v0.7.2/NodistSetup-v0.7.2.exe).Los comandos se encuentran en la documentación. (https://github.com/marcelklehr/nodist)","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://academia-binaria.com/tag/NodeJS/"}]},{"title":"npm: de instalador a publicador","slug":"npm-de-instalador-a-publicador","date":"2016-04-18T14:07:46.000Z","updated":"2016-04-19T05:01:25.000Z","comments":true,"path":"npm-de-instalador-a-publicador/","link":"","permalink":"https://academia-binaria.com/npm-de-instalador-a-publicador/","excerpt":"","text":"Seguro que estás harto de repetir la mítica instrucción npm install paquete-x Pero, ¿has pensado en publicar tus propios módulos?. Es muy recomendable crear soluciones distribuidas y muy fácil publicarlas en npm.Sigue este proceso y te convertirás en un creador de paquetes para npm :ProgramaTodo empieza por tener una necesidad y resolverla encapsulando su código en un módulo. Por supuesto que ese módulo puede requerir paquetes externos. Y por supuesto que tu código puede, y debe, escribirse en varios módulos.Antes de continuar vamos a fijar un par de conceptos:- módulo: Fichero .js que exporta un funcionalidad y oculta su implementación.- paquete: Uno o más módulos, con sus dependientes de otros paquetes que proponen una solución reutilizable.Conocidos los ingredientes, la receta es sencilla:Debes crear un proyecto para el paquete que vas a publicar.Has de subir el código a un repositorio público.Y debes rellenar convenientemente el package.json de tu proyecto.Este es un ejemplo que he creado y publicado en github que te puede servir de base.Presta especial atención al nombrado de tu proyecto porque ha de ser único en el repositorio de npm. Para reducir riesgos de colisiones de nombre te recomiendo que utilices un prefijo con tus iniciales o las de tu empresa.No te olvides de incluir un juego de pruebas y documentación necesaria para sus uso.PublicaPuedes descargar librerías y herramienta desde el repositorio de npm de forma anónima. De hecho, eso es lo más corriente. Pero, como era de esperar, tienes que registrarte para poder publicar contenido. El proceso de registro vía web es sencillo y grátis.Una vez verificado puedes hacer login en la web. Pero también en la terminal de tu ordenador: npm login te pedirá el nombre de usuario y contraseña. A partir de es momento estás identificado y puedes usar las herramientas de autor:1npm publishPuedes encontrar más información acerca de este mega comando en la documentación de npmjs. Pero siguiendo la máxima de cuanto menos, mejor, la herramienta hará con sus valores por defecto un publicación y actualización limpias.La clave está en que tu fichero de configuración package.json sea correcto y lo más completo posible. Escribe un completo readme.md que se convertirá en portada de tu paquete en el repositorio de npm. Mira en mi ejemplo cómo el contenido subido a github se transforma y se ve en la página de información de npm.Comprueba en un directorio vacío que npm install nombre-de-tu-paquete descarga todo lo necesario… y tómate un café mientras ves crecer la hierba y las estadísticas de descargas.ActualizaCon el tiempo mejorarás y corregirás tu solución. Te recomiendo que sigas el patrón de nombrado de versiones semántico:x.y.z = 1.2.3 = ruptura.mejora.parcheEs bueno que etiquetes tu repositorio con estas mismas versiones para que, una vez desplegadas, se encuentre con facilidad en github.12git tag 0.1.2git push --tagsDisfrutaFinalmente podrás utilizar ese código en todas tus aplicaciones. Sería fantástico que además otros lo encontrasen útil. Y mejor aún si te ayudan o al menos te proponen mejoras. Pero en cualquier caso siempre habrás ganado. El esfuerzo analítico que requiere se cobra con creces: dividiendo el problema, creando micro soluciones eficientes y reutilizando código siempre es rentable.","categories":[{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/categories/Avanzado/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://academia-binaria.com/tag/NodeJS/"}]},{"title":"Soluciones BackEnd 2016","slug":"soluciones-backend-2016","date":"2016-03-21T10:50:58.000Z","updated":"2016-04-01T06:02:55.000Z","comments":true,"path":"soluciones-backend-2016/","link":"","permalink":"https://academia-binaria.com/soluciones-backend-2016/","excerpt":"","text":"Las soluciones JavaScript para el servidor que marcan tendencia en el desarrollo back end durante este 2016. Continuación de la saga que iniciamos con FrontEdge.Mi apuesta de mercado sigue empezando por la base, el lenguaje JavaScript. En concreto su última y muy necesaria versión: el conocido ES6. En el lado del servidor destaco la disponibilidad de Promesas de forma nativa..Las aplicaciones crecen y se controlan por su API.Así que este es el punto al que más atención debes prestarle. Por supuesto que hay que cumplir con el estándar REST y hay que documentar todo nuestro código. Pero para ser más productivo y mantener actualizado el sistema, te propongo que uses RAML. Un lenguaje para documentar APIs que con las herramientas adecuadas permite la generación de pruebas, esqueletos de aplicaciones e infraestructura.El ya viejo conocido NodeJS se ha modernizado y a partir de la versión 4, especialmente en la 5, admite la mayor parte de la sintaxis ES6. Además ha mejorado su velocidad en un 25% gracias a la actualización del motor V8 que procesa internamente el JavaScript.En la base de datos irrumpe con fuerza la nueva versión de MongoDB 3.2, que incorpora grandes novedades como: sistema de almacenamiento más rápido, índices parciales, validación de esquema y el esperado join entre colecciones .En esta presentación tienes más información acerca de lo que llamo backEdge : tecnología utilizable, de última generación y con enorme potencial.En este video tienes la charla que di con o que llamo Desarrollo Web presentando las tendencias tecnológicas del 2016.","categories":[{"name":"Opinión","slug":"Opinion","permalink":"https://academia-binaria.com/categories/Opinion/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://academia-binaria.com/tag/MongoDB/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://academia-binaria.com/tag/NodeJS/"},{"name":"BackEnd","slug":"BackEnd","permalink":"https://academia-binaria.com/tag/BackEnd/"}]},{"title":"Soluciones FrontEnd 2016","slug":"soluciones-frontend-2016","date":"2016-01-14T09:39:32.000Z","updated":"2016-01-14T10:17:31.000Z","comments":true,"path":"soluciones-frontend-2016/","link":"","permalink":"https://academia-binaria.com/soluciones-frontend-2016/","excerpt":"","text":"Inicio el año proponiendo una selección de tecnologías que serán tendencia en el desarrollo front end durante este 2016.Mi apuesta de mercado empieza por la base, el lenguaje JavaScript. En concreto su última y muy necesaria versión: el conocido ES6. Tras siete años desde la anterior gran revisión, el éxito y la popularidad de JS no podía esperar más. Y tu tampoco debes esperar más para conocerlo y usarlo.Existe una creciente necesidad de dependencias externas en nuestra aplicaciones y sobre todo incorporar librerías provenientes de otros entornos y desarrolladas con variantes de JS. Para administrar todo ello propongo JSPM, que se incorporará definitivamente a nuestro toolbox durante el 2016.De entre las librerías y frameworks disponibles, AngularJS continuará siendo el rey. Este viejo conocido está creciendo en ya en grandes empresas, banca y administraciones públicas. Mientras esperamos la gloriosa venida de la versión 2.0, tenemos la oportunidad de adecuar nuestro estilo de programación y desarrollar de manera mas limpia con la versión puente AngularJS1.5En la parte visual, el look &amp; feel propuesto por Google con Material Design es un éxito de aceptación para el desarrollo de aplicaciones empresariales. La librería AngularMaterial es una implementación para Angular de dicha especificación gráfica. Moderno y con enorme potencial.En esta presentación tienes más información acerca de lo que llamo frontEdge : tecnología utilizable, de última generación y con enorme potencial.Presentación frontEdgeSi tienes tiempo, mira este vídeo con una charla en la que comentamos estas y otras tecnologías para programadores.video frontEdge","categories":[{"name":"Opinión","slug":"Opinion","permalink":"https://academia-binaria.com/categories/Opinion/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://academia-binaria.com/tag/AngularJS/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://academia-binaria.com/tag/FrontEnd/"}]},{"title":"7 formas de incluir Bootstrap en nuestro proyecto","slug":"formas","date":"2015-11-12T14:40:12.000Z","updated":"2015-11-12T15:55:15.000Z","comments":true,"path":"formas/","link":"","permalink":"https://academia-binaria.com/formas/","excerpt":"","text":"1- Descargando los archivosHaz clic en el botón “Download Bootstrap” y se descargará una carpeta comprimida, al descomprimirla te encontrarás las versiones compiladas y minificadas de Bootstrap así como los iconos que utiliza:12345678910111213141516171819bootstrap/├── css/│ ├── bootstrap.css│ ├── bootstrap.css.map│ ├── bootstrap.min.css│ ├── bootstrap.min.css.map│ ├── bootstrap-theme.css│ ├── bootstrap-theme.css.map│ ├── bootstrap-theme.min.css│ └── bootstrap-theme.min.css.map├── js/│ ├── bootstrap.js│ └── bootstrap.min.js└── fonts/ ├── glyphicons-halflings-regular.eot ├── glyphicons-halflings-regular.svg ├── glyphicons-halflings-regular.ttf ├── glyphicons-halflings-regular.woff └── glyphicons-halflings-regular.woff22- Para usuarios de GitHubBootstrap es un proyecto en código abierto así que puedes clonar o hacer fork desde GitHub3- Código fuente originalLo obtienes al hacer clic en el botón “Download source”. Lo que obtienes son los archivos LESS y Javascript originales. Esta opción requiere Grunt y Node.js y se estructura dentro de la siguiente manera:12345678910bootstrap/├── less/├── js/├── fonts/├── dist/│ ├── css/│ ├── js/│ └── fonts/└── docs/ └── examples/4- Fans de BowerSi tenemos Git y Bower instalado simplemente debes teclear en tu terminal:1$ bower install bootstrapY el pajarito hará todo el trabajo.5- NPM InstallTan fácil como con Bower solo que esta vez debes teclear en tu terminal:1$ npm install bootstrap6- Versión en SASSA pesar de que Bootstrap 3 fue escrito en LESS (aspecto que cambiará en la versión 4, que será en SASS), existe una versión para SASS que puedes descargar en el botón “Download SASS” para facilitar su inclusión en proyectos en Rails, Compass o solo SASS.7- CDNPor último, si no quieres descargarte nada puedes utilizar los links del proveedor de CDN y referenciarlos en tu HTML:12345678&lt;!-- CSS --&gt;&lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css\" integrity=\"sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==\" crossorigin=\"anonymous\"&gt;&lt;!-- Tema opcional --&gt;&lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css\" integrity=\"sha384-aUGj/X2zp5rLCbBxumKTCw2Z50WgIr1vs/PFN4praOTvYXWlVyh2UtNUU0KAUhAX\" crossorigin=\"anonymous\"&gt;&lt;!-- JavaScript --&gt;&lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js\" integrity=\"sha512-K1qjQ+NcF2TYO/eI3M6v8EiNYZfA95pQumfvcVrTHtwQVDG+aHRqLi/ETn2uB+1JqwYqVG3LIvdm9lj6imS/pQ==\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;Esta es la manera más fácil pero no podrás trabajar sin conexión a internet.","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://academia-binaria.com/tag/Bootstrap/"}]},{"title":"Introducción a Bootstrap","slug":"introduccion-a-bootstrap","date":"2015-11-05T16:44:55.000Z","updated":"2015-11-12T14:56:16.000Z","comments":true,"path":"introduccion-a-bootstrap/","link":"","permalink":"https://academia-binaria.com/introduccion-a-bootstrap/","excerpt":"","text":"Bootstrap es un conjunto de archivos HTML, CSS y Javascript bien definidos y exhaustivamente testados que componen una sólida estructura sobre la cual construir tu proyecto web o aplicación.¿Por qué debo utilizar Bootstrap en mi proyecto?Empezar un proyecto web desde cero puede ser laborioso y te puede llevar bastante tiempo mientras vas construyendo los diferentes componentes y testándolos en los diversos navegadores.Bootstrap te provee de una biblioteca de componentes reusables que puedes usar en cada proyecto, desde un sistema de rejilla o “grid”, una barra de navegación, botones o estilos tipográficos, todos ellos preparados para funcionar en todos los navegadores y adaptarse a todos los tipos de pantalla, tanto de móvil, como tablet o escritorio.Con Bootstrap te ahorras todo el trabajo inicial y además tienes un código revisado y testado que además es mantenible y escalable, una sólida estructura sobre la cual construir tu proyecto.Práctica comúnHoy en día su uso se encuentra muy extendido, y no es extraño encontrarse ofertas de trabajo en las cuales además de conocimientos de HTML y CSS y Javascript se exige el dominio de Bootstrap. La suave curva de aprendizaje hace que sea una herramienta sencilla de usar por todos los miembros de un equipo de desarrollo, lo que incrementa la productividad.¿Por dónde empezar?Para descargar la última versión debes acudir a la página http://getbootstrap.com/ y pulsar el botón “Download Bootstrap” una vez hecho esto te dirigirá a la sección “Download” de la página. Hay diferentes maneras de integrar Bootstrap en tu proyecto, en este artículo hablaremos de la primera de ellas que es descargarnos la carpeta comprimida.En el apartado “Bootstrap” de la sección “Download” te encontrarás otra vez el botón de “Download Bootstrap”, esta vez al clicarlo se descargará una carpeta comprimida que se compone de:Una carpeta ”css”: Incluye todos los estilos predefinidos por Bootstrap.Una carpeta “fonts”: Incluye una fuente de iconos svg listos para usar.Una carpeta “js”: Con todo el javascript necesario para que los componentes y efectos de Bootstrap funcionen.Una práctica común es empezar el proyecto con estas carpetas e incluir a través de tu HTML los archivos que vas a utilizar. Normalmente bootstrap.min.css y bootstrap.min.js. Además deberás incluir JQuery en tu proyecto para el correcto funcionamiento de los plugins.Una vez hecho esto te debería quedar un HTML inicial parecido a esto:12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- Los 3 metatags de arriba deben ir al principio del head --&gt; &lt;title&gt;Mi primer tema con Bootstrap&lt;/title&gt; &lt;!-- Incluye el css de Bootstrap --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- Incluye nuestro propio CSS --&gt; &lt;link href=\"css/styles.css\" rel=\"stylesheet\"&gt; &lt;!-- Este código es necesario si queremos dar soporte a IE8 --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://oss.maxcdn.com/respond/1.4.2/respond.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hola!&lt;/h1&gt; &lt;!-- Incluye jQuery --&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- Incluye el JS de Bootstrap --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;Con esto ya estarías listo para empezar tu proyecto con Bootstrap y, con la ayuda de la documentación de Bootstrap, ir incluyendo los módulos y clases que necesites.Cómo norma general nunca modifiques los archivos originales de Bootstrap, para añadir tus estilos propios o modificar los de bootstrap.css lo mejor es que crees una hoja de estilos independiente de bootstrap.css, lo mismo para el archivo bootstrap.js, así para actualizar tu versión de Bootstrap simplemente tendrás que descargarte la última versión y sustituir los archivos bootstrap.min.css y bootstrap.min.js por los de la nueva versión.En siguientes artículos profundizaremos un poco mas sobre las diferentes opciones que tienes para incluir Bootstrap en tu proyecto.","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://academia-binaria.com/tag/Bootstrap/"}]},{"title":"Para qué puedo usar NodeJS","slug":"para-que-puedo-usar-nodejs","date":"2015-08-20T12:28:01.000Z","updated":"2015-08-20T12:53:50.000Z","comments":true,"path":"para-que-puedo-usar-nodejs/","link":"","permalink":"https://academia-binaria.com/para-que-puedo-usar-nodejs/","excerpt":"","text":"NodeJS se ha hecho muy popular por dos razones relacionas: potencia y escalabilidad. Ambas derivadas de su modelo de ejecución asíncrona no bloqueante.Se basa en el lenguaje JavaScript: sencillo, versátil y ampliamente conocido. NodeJS complementa a JS con librerías de sistema que sacan un gran rendimiento a los ejecutables.El uso más inmediato de NodeJS está en la programación de servicios web. Tanto en la creación de APIs como sirviendo páginas tradicionales. Esto le ha valido que se le conozca como el JavaScript del lado del servidor.Pero, más allá de la web destaca en entornos empresariales. Se puede utilizar para construir aplicaciones de escritorio con iniciativas como (NW)[] y (electron)[]. También y sobre todo se usa para scripts de administración o monitorización en departamentos IT. Pequeños proyectos aplicables a sistemas de ficheros, máquinas y servidores. Y una derivada de esto son los proyectos de ayuda al desarrollador que se integran en los development workflows de cada vez más empresas de programación en cualquier lenguaje.Dada la capacidad de procesamiento asíncrono es una herramienta ideal para generar sistemas que respondan en tiempo real. Y por su escasa demanda de hardware se usa también en proyectos de Internet of ThingsEn definitiva podemos decir que NodeJS y su ecosistema proponen un nuevo paradigma de desarrollo que eleva a JavaScript como lenguaje de propósito general.","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://academia-binaria.com/tag/NodeJS/"}]},{"title":"Por qué AngularJS","slug":"por-que-angularjs","date":"2015-08-18T06:31:24.000Z","updated":"2015-08-20T12:45:22.000Z","comments":true,"path":"por-que-angularjs/","link":"","permalink":"https://academia-binaria.com/por-que-angularjs/","excerpt":"","text":"En este vídeo charlamos sobre AngularJS y el momento actual de desarrollo, y el porqué de su éxito.Video en YouTube","categories":[{"name":"Opinión","slug":"Opinion","permalink":"https://academia-binaria.com/categories/Opinion/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://academia-binaria.com/tag/AngularJS/"}]},{"title":"Introducción a MongoDB","slug":"introduccion-a-mongodb","date":"2015-08-15T09:00:54.000Z","updated":"2015-08-25T04:26:25.000Z","comments":true,"path":"introduccion-a-mongodb/","link":"","permalink":"https://academia-binaria.com/introduccion-a-mongodb/","excerpt":"","text":"¿Qué es MongoDB?MongoDB es una base de datos orientada a documentos con esquema dinámico. Esto le permite ofrecer un alto rendimiento y facilita el desarrollo de aplicaciones. A cambio nos impide tener Joins y Transacciones algo muy habitual en bases de datos relacionales, pero sin lo que se puede vivir.¿De qué se compone?Después de su instalación disponemos en un directorio de varios ejecutables que componen la aplicación servidora y sus herramientas. El ejecutable fundamental será mongod que es el servidor, es el motor de manejo de datos. Para acceder al servidor se nos ofrece una aplicación de consola llamada mongo. Este es un intérprete de JavaScript y con él, podemos comunicarnos con la base de datos.¿Cómo funciona?MongoDB almacena documentos en formato JSON. Bueno realmente lo hace en BSON que es un superconjunto de JSON. BSON es un formato binario que optimiza espacio, rendimiento y aporta funciones extra sobre JSON. Pero esencialmente para nosotros como usuarios toda la entrada salida es en JSON.Como los documentos se almacenan en JSON y la consola es un interprete JavaScript, la verdad es que la consola ofrece una potencia enorme para realizar operaciones de inserción, selección y manipulación de datos. Cabe destacar que la consola es un programa e intérprete síncrono. Con algunos drivers como el de NodeJS el trabajo es puramente asíncrono.¿Se parece a SQL?Si vienes del mundo relacional, cuando llegues a Mongo tendrás que ajustar tu punto de mira al definir tus estructuras de datos. Como una primera guía te diré que hay una ligera equivalencia entre Mongo y los SQLSQL -&gt; MongoDBDataBase -&gt; DataBaseTable -&gt; CollectionRow -&gt; DocumentField -&gt; PropertyJoin -&gt; EmbeddedIndex -&gt; IndexLa enorme diferencia está en que en una colección se pueden guardar documentos con esquemas distintos, y que esos esquemas pueden incluir documentos complejos, como arrays y subdocumentos. A esta falta de rigor al definir el esquema se la conoceen inglés como schemaless. Estamos ante una base de datos que almacena documentos de esquema dinámico.Lo anterior es sin duda un valor diferencial a favor de Mongo pues facilita mucho el desarrollo y evolución de las aplicaciones. Otra cosa es la ausencia de Joins y Transacciones entre colecciones que obliga a diseñar y codificar de manera metódica para garantizar eficiencia e integridad en las consultas. La sugerencia es aprovechar sus fortalezas para minimizar las debilidades.¿Y entonces?MongoDB tienes campos de aplicación en los que supera a los sistemas relacionales en potencia y facilidad de desarrollo. Pero, hay que saber escoger la herramienta mas adecuada para cada caso. Ahora que ya sabes un poco de que va esto de MongoDB puedes empezar a buscar aplicaciones dónde seguro que le sentará como un guante.","categories":[{"name":"Introducción","slug":"Introduccion","permalink":"https://academia-binaria.com/categories/Introduccion/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://academia-binaria.com/tag/MongoDB/"}]},{"title":"ng* el ecosistema de AngularJS","slug":"ng-el-ecosistema-de-angularjs","date":"2015-08-15T08:55:14.000Z","updated":"2015-08-20T12:45:59.000Z","comments":true,"path":"ng-el-ecosistema-de-angularjs/","link":"","permalink":"https://academia-binaria.com/ng-el-ecosistema-de-angularjs/","excerpt":"","text":"Lista de componentes para ampliar AngularJS que te ayudarán a mejorar tus proyectos.AngularUI: Antes de programar nada mira si estos chicos ya lo han hecho antes: utilidades, componentes visuales, bootstrap y…ng-grid: Si tienes que mostrar datos en forma de tabla, este es tu punto de partida.ngProgress: Para incorporar una barra de progreso que informe a tus usuarios de la actividad de la aplicación.RestAngular: Librería especializada para consumir servicios REST de manera avanzada e intensiva.angular-aop: El AOP encapsula los Aspectos del código relacionados con instrumentación y seguimiento, liberándolo para la lógica de negocio.textAngular: Editor de textos cpn doble binding, formatos, estilos…angular-translate: Tener una interfaz en distintos idiomas es una tarea cada vez mas común… y complicada. Esta librería es un gran ayuda.angular-field-splitter: Útil para descomponer un campo lógico en varios inputs físicos: Códigos de cuenta, teléfonos, fechasangular-gm: Para mostrar mapas de Google de forma dinámica enlazados con tu modelong-slider: Una barra con punteros para selecionar rangos de forma visual","categories":[{"name":"Avanzado","slug":"Avanzado","permalink":"https://academia-binaria.com/categories/Avanzado/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://academia-binaria.com/tag/AngularJS/"}]}]}